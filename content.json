{"meta":{"title":"Tiko.T's Blog","subtitle":null,"description":"出尘入世 · 静心修行","author":"Tiko.T","url":"http://aojueliuyun.github.io"},"pages":[{"title":"About","date":"2017-10-14T16:00:00.000Z","updated":"2018-06-23T14:07:10.282Z","comments":true,"path":"about/index.html","permalink":"http://aojueliuyun.github.io/about/index.html","excerpt":"","text":"You are defined by what you do, not by what you own or where you are from. 博主学生，XDU，微电子专业，大三在读，现退EE转CS保平安。不会C++，前途不明，方向未定。 交流邮箱：aojue-tiko-t@foxmail.comGithub：aojueliuyun 博客搭建时间：2017年十月中旬。如何搭建：Hexo + GitHub Pages + NexT.Mist。搭建目的：一来是为了记录自己在学习中的收获，方便以后查阅，二来分享即学习，三来好记性不如烂笔头。博客内容：计算机/编程/数学/算法基础，我的价值观与生活感悟。查看文章系列。 联系目前没有开启评论，因为开了也应该没有什么人会来评论。如果你在我的文章里发现了错误、不严谨或者有争议的地方，并且想告诉我的话，欢迎发邮件。请注明是哪一篇文章，我收到后会及时查看与更新。另外，欢迎技术交流与互添友链。 版权每篇文章末尾均附有版权声明。本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明出处并给出原文链接！ 很洒脱，自在的一首歌。"},{"title":"categories","date":"2018-06-23T13:59:26.000Z","updated":"2018-06-23T14:02:28.742Z","comments":true,"path":"categories/index.html","permalink":"http://aojueliuyun.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2018-06-23T14:01:33.000Z","updated":"2018-06-23T14:01:34.009Z","comments":true,"path":"archives/index.html","permalink":"http://aojueliuyun.github.io/archives/index.html","excerpt":"","text":""},{"title":"札记","date":"2018-02-01T16:00:00.000Z","updated":"2018-06-24T03:42:28.882Z","comments":true,"path":"notes/index.html","permalink":"http://aojueliuyun.github.io/notes/index.html","excerpt":"","text":"生活记录：2017 &amp; 2018 2018年6月每一个粉色傲娇双马尾都应当被温柔以待。 2018年5月保持动力的原因是成就感，而不是所谓的兴趣。没有一步步实践带来的成就感，兴趣就是空谈，兴趣都是培养出来的。 2018年4月抱歉，我已经无法收获幸福了因为，我发现我早就已经…被幸福包围了啊！ ——《末日时在做什么？有没有空？可以来拯救吗？》 程序就像性爱一样：尽管他们可以带来一些实际的成果，但那并不是我们喜欢做他们的原因。—— Bjarne Stroustrup 引自 Richard Feynman（原指物理） 不积跬步，无以至千里；不积小流，无以成江海。 话说hexo博客里面的代码块默认TAB键缩进不是4个空格长度而是8个，与一般的编辑器不一致，就比较尴尬。注释就全部不规整了，难道以后要采用四个空格缩进？而且规范的代码风格是要求用4个空格缩进的，究其原因就是TAB键长度不确定。如果碰到8个空格长度的情况，缩进层数多了代码宽度就会被拉长很多。空格输入又比较麻烦，但在所有编辑器里面都会保持一致，而且每个空格占一个字符大小，而TAB只占一个。这是程序员圈子里面的无数圣战之一。见知乎：为什么规范的代码缩进通常用soft tab四个空格而不是tab？目前我认为最好的解决方案：在编辑器中使用TAB，编辑器自动将其替换为4个空格，如果支持的话（VS用户可在Tools-&gt;Options-&gt;Text Editer对编写每一种语言时候的Tab进行控制，极端好用，不愧宇宙最强IDE）。简洁的书写，严格的对齐。 仔细想了一想，收回上面的话，换行无可避免的要用到制表符，将TAB换为空格就会造成TAB空格混用，这无疑是非常糟糕的。而且TAB本身就是制表符，就是用来缩进的。还是继续用制表符吧，换为空格肯定会令我这个强迫症会无比难受。其实最重要的应该使用唯一的风格，不要混用即可。这里不要混用指的是代码的换行缩进对齐要么全用空格，要么全用tab。所以我的解决方案是：将类和函数的注释与其对齐（如要缩进用tab）放在行首，只有有必要的变量注释才放在行尾（变量一般情况下都是并列对齐的，所以注释的对齐使用空格）。这样tab不一致的情况下也会保持比较好的对齐。其他的需要注释但行首不对齐的一律与代码对齐放在上一行。简而言之：除了每一行行首的缩进用tab，其余全用空格。说得那么复杂的感觉。保持清晰美观就好。 其实这种东西，唯一的目的就是可读性。没必要太过纠结具体的细节，宏观上保证在不同环境下都具有较高的可读性就好。 2018年3月 上帝创造了自然数，其余的是人的工作。——L.Kronecker 发现一个非常有趣的数学科普纪录片——《维度：数学漫步 Dimensions: A Walk Through Mathematics》，讲了许多有趣的数学里面的东西，如四维空间中的正多胞体、复数、分形（fractals）、纤维化理论（fibrations）等，由 Jos Leys、Étienne Ghys、Aurélien Alvarez 制作 。甚至专门建了一个网站，B站可看，点击观赏。 2018年2月《三体》黑暗森林法则：宇宙就是一座黑暗森林，每个文明都是带枪的猎人，像幽灵般潜行于林间，轻轻拨开挡路的树枝，努力不让自己发出一点儿声音，连呼吸都小心翼翼……他必须小心，因为林中到处都是和他一样的猎人。如果他发现了别的生命，不管是不是猎人，不管是天使还是魔鬼，不管是娇嫩的婴儿还是步履蹒跚的老人，也不管是天仙般的少女还是天神般的男孩，能做的只有一件事：开枪消灭之。在这片森林中，他人就是地狱，就是永恒的威胁，任何暴露自己存在的文明都将很快被消灭。这就是宇宙文明的图景，这就是对费米悖论的解释。 注：费米悖论：宇宙显著的尺度和年龄意味着高等地外文明应该存在，但是人类目前为止并没有发现任何有关外星人存在的蛛丝马迹，包括飞船、探测器以及电磁信号。 MC动画《我的三体·罗辑传》主题曲 但愿有生之年能用代码写出一个知己。 润峰为眉，不描而翠，古井甘霖一滴泪，误将世间双瞳剪水，拟作望穿澄空断雁的欢悲。江枫渔火，平野星垂，云山枕藉以相对，弹指涟漪，锦鳞一尾，撞碎哪面静影沉壁的心扉。观百川泱泱灌河，幕天席地于涓涓毫末，怎知谁与孤鹜落霞，共长天一色，不是夜雨临池的涨落？白露横江，飞霜而淬，束作袖中三尺晖，扁舟散发，抽刀断水，竟欲斩去清浊分明的泾渭。观百川泱泱灌河，幕天席地于涓涓毫末，怎知谁与孤鹜落霞，共长天一色，不是夜雨临池的涨落？剪去归期未期的烛火。剪去归期未期的烛火。——来自银临歌曲《秋水》 个人认为非常大气也非常喜欢的一首歌。链接。 2018年1月人们常说科学的本质是怀疑，宗教的本质是相信。对任何自己不能分辨、不了解的事物抱有怀疑的态度是一个理性的人必备的素质。 做人不能盲目，不能随波逐流，不能别人说什么就是什么，别人做什么就去做什么。做任何事之前都需要进行思考，思考对自己的帮助与弊害，思考接下来该做什么，思考自己是否喜爱。每个人都是一个独立的个体，独立的个体就需要有独立的清晰的思维。如果无法判断别人说的是真还是假，是对还是错，那就去学习。 弱小和无知不是生存的障碍，傲慢才是。——《三体》 退EE转CS保平安。"},{"title":"tags","date":"2018-06-23T13:58:48.000Z","updated":"2018-06-23T14:03:00.816Z","comments":true,"path":"tags/index.html","permalink":"http://aojueliuyun.github.io/tags/index.html","excerpt":"","text":""},{"title":"2017 & 2018","date":"2018-05-28T13:54:32.281Z","updated":"2018-05-28T13:54:28.712Z","comments":true,"path":"notes/2017&2018/index.html","permalink":"http://aojueliuyun.github.io/notes/2017&2018/index.html","excerpt":"","text":"均是我看过的中认为比较值得看的。 BooksComputer Systems: A Programmer’s Perspective DramasRick and Morty Season 1 to 3The Expance Seasons 1 to 3West World Season 1 &amp; 2Silicon Valley Season 1 to 5Mr. Robot Season 1 to 3BoJack Horseman Season 1 to 4Better Call Saul Season 1 to 3Breaking Bad Season 1 to 5Game of Thrones Season 1 to 7 Animations宝石之国Re：从零开始的异世界生活末日时在做什么？有没有空？可以来拯救吗？血界战线 &amp; BEYONDJust Because!比宇宙更远的地方Megalo Box言叶之庭声之形龙的牙医"}],"posts":[{"title":"正则表达式入门","slug":"2018.6.10--regular-expression","date":"2018-06-09T16:00:00.000Z","updated":"2018-06-11T08:25:58.953Z","comments":true,"path":"2018/06/10/2018.6.10--regular-expression/","link":"","permalink":"http://aojueliuyun.github.io/2018/06/10/2018.6.10--regular-expression/","excerpt":"内容：如题前置技能：None教程：30分钟正则入门","text":"内容：如题前置技能：None教程：30分钟正则入门 前言最近喜欢各种入门，这里入门一下正则表达式。字数很少比较水。 字符串可以说是编程是遇到的最多的一种数据结构，也是最简单的数据结构，对字符串操作的需求可谓无处不在。给人阅读的文本可以看做字符串，内存中存储的特定编码序列可以看做字符串，一个网页的html文本是字符串，浏览器对html文本解析的过程是字符串处理，无论是编译型语言还是解释型语言，编译和解释的过程都可以看做字符串处理。字符串操作重要性不言而喻。而在字符串中一种很常见的操作就是字符串的匹配。编写程序去处理特定的需要匹配的字符串可以做到，但耗时耗力，且代码不具有重用性。所以我们需要正则表达式。 正则表达式（Regular Expression）是一种匹配规则，用来匹配你想要的各种形式的字符串。规则有了还不行，还需要一个正则引擎来支持它，正则引擎可以看做一种编译器，实现需要用到编译原理的知识，支持语法越多越复杂，这里不讨论（有时间实现，挖坑，以后填）。 在Shell中我们常用*来表示匹配所有项，比如ls *.v表示列出该目录下所有.v文件。*是正则的语法，能这样用是因为Shell部分支持正则表达式。*也称为通配符。 正则表达式是什么呢？正则表达式是： 通用的字符串表达式框架 简洁表达一组字符串的表达式 也就是说将一组字符串的特征准确地提取出来，用简洁的语法表示出来。例如: 用\\b\\w+ly\\b 表示以ly结尾的单词。 正则表达式的作用： 判断某字符串的特征归属 查找一个文本字符串的特征 同时查找或者替换一组字符串 匹配某个字符串的部分或者全部 正则表达式是难于读写的，所以需要对其正确性进行测试，可以使用上面那篇教程的作者写的一个正则表达式测试器，也可以使用这个在线正则表达式测试器。 正则语法元字符首先如果想要匹配特定字符串，直接使用该字符串即可。 另外一些匹配字符或者位置的元字符： \\b 匹配一个位置，单词的开头或者结尾 . 匹配除了换行符以外的任何字符 \\d 匹配一个数字，即0到9 \\s 匹配空白符，包括空格、制表符、换行等 \\w 匹配一个字母数字下划线或者汉字等 ^ 匹配字符串开始的位置 $ 匹配字符串结尾的位置 其中\\b ^ $ 匹配位置而不是字符，就是说他们不匹配为一个字符，即不占一个字符的位置。 重复代表重复的限定符不匹配字符，仅代表限定符前的字符可以重复的次数。 * 指定*前面的内容可以使用任意次（0次或者多次） + 与*类似，不过是1次或者多次 ? 重复0或者1次 {n} 重复n次 {n,} 重复n次或者更多次 {n,m} 重复n到m次 eg: ^[1-9]\\d{4,9}$匹配一个5到10位的不以0开头的数字串，可以是QQ号 但是如果要匹配上面这些已经有特殊意义的字符呢？当然是转义了：\\* \\. \\- \\\\ 字符类使用[aeiou]表示aeiou中的任何一个字符。而[0-9]就等同于\\d。这里可以使用-表示范围。 分枝条件使用|表示或者。\\d|[a-zA-Z]匹配字母或者数字。 分组使用()进行分组，每个分组也称为子表达式。可以对每个子表达式使用上面的表示重复的语法。如果要匹配(或者)，则需要转义\\( \\)。[] {}同理。 eg：匹配一个IP地址 -&gt; ((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?) ，其中(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)表示0到255。 反义能匹配符合某种模式的，肯定也需要匹配不满足某种模式的。 \\W 匹配任意不是字母数字下划线汉字的字符 \\S 匹配不是空白符的字符 \\D 匹配非数字字符 \\B 匹配非单词开始和结尾的任何位置 [^X] 匹配除X以外的任何字符 [^aeiou] 匹配除aeiou外的所以字符 后向引用使用()指定子表达式时，每个分组会自动拥有一个组号，从1开始依次增加。后向引用可以重复使用前面某个分组匹配的文本。使用\\k表示匹配编号为k的分组捕获的内容。 eg：匹配重复单词 \\b(\\w+)\\b\\s+\\1\\b ，注意是匹配重复单词，而不是两个单词，即是第一个分组捕获了一个单词并被\\1引用。 另外可以自己指定组名，使用语法 (?&lt;Word&gt;\\w+) 或者 (?&#39;Word&#39;\\w+) 则组名指定为 Word，引用该分组捕获的内容则使用\\k&lt;Word&gt;。上面的例子：\\b(?&lt;Word&gt;\\w+)\\b\\s+\\k&lt;Word&gt;\\b (?:exp) 匹配exp，但不捕获文本，也不分配组号。 零宽断言 (?=exp)，零宽度正预测先行断言，断言自身出现的位置的后面能匹配表达式exp，即匹配表达式exp前面的位置。 (?&lt;=exp)，零宽度正回顾后发断言，匹配表达式exp后面的位置 (?!exp)，零宽度负预测先行断言，匹配后面不是exp的位置 (?&lt;!exp)，宽度正回顾后发断言，匹配前面不是exp的位置 忽略它们的名字，语法均是()中以?开头，然后有&lt;代表后面的位置，没有则代表前面，=代表匹配，!代表不匹配。注意它们都匹配位置而不是字符。 另外一个与()相关的语法是注释：(?#comment) 贪婪与懒惰上面的重复如* {n,m}等蕴含着一个问题。即是使用a.*b来匹配字符串aabab是得到aab还是aabab。答案是aabab，因为默认情况下是贪婪匹配，即在匹配的情况下尽可能多重复。 在重复匹配的语法后面加上一个?可以将其变为懒惰匹配，即尽可能少重复。语法：*? +? ?? {n,}? {n,m}? 处理选项如果语法太死的话似乎会给人不够灵活的感觉。在.Net下，有一些处理选型可以改变处理正则的方式，比如在某些时候需要忽略大小写是很必要的。详见：正则表达式选项。 转义字符匹配上面用到的特殊字符时都需要转义，另外ASCII编码本身定义的转义字符也是支持的。详见：正则表达式中的字符转义。","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://aojueliuyun.github.io/categories/计算机科学/"}],"tags":[{"name":"python","slug":"python","permalink":"http://aojueliuyun.github.io/tags/python/"}]},{"title":"Python入门","slug":"2018.6.2--get-started-with-python","date":"2018-06-01T16:00:00.000Z","updated":"2018-06-23T15:31:08.871Z","comments":true,"path":"2018/06/02/2018.6.2--get-started-with-python/","link":"","permalink":"http://aojueliuyun.github.io/2018/06/02/2018.6.2--get-started-with-python/","excerpt":"Life is short, I use Python. 版本：3.6文档：The Python Language Reference入门：廖雪峰Python教程环境：Win 10 / Linux安装：sudo apt install python本文：基础、函数、高级特性、函数式编程","text":"Life is short, I use Python. 版本：3.6文档：The Python Language Reference入门：廖雪峰Python教程环境：Win 10 / Linux安装：sudo apt install python本文：基础、函数、高级特性、函数式编程 基础hello,world!1print('hello,world!') Python之禅12345678910111213141516171819202122&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those! 指定解释器，对Linux1#!/usr/bin/python3 输入输出12a = input()print(a) 数据类型：整数，浮点数，字符串格式化输入输出（与C语言一致）：%d %f %s %x整数浮点运算：* / // %123print(10/3)print(10//3)print(10%3) 字符串与编码指定编码格式，确保编辑器使用UTF-8 without BOM编码1# -*- coding: utf-8 -*- list（可变） &amp; tuple（不可变对象） &amp; dict（可变）&amp; set（可变）1234A = [1, 2, 'hello', 'world']B = (1,23,5,'shit')C = &#123;1:10, 'hello':'world'&#125;D = &#123;1,2,3&#125; 条件分支1234567a = 5if a &gt; 10: print('a &gt; 10')elif a &gt; 5: print('5 &lt; a &lt;= 10')else: print('a &lt;= 5') 循环1234567A = [1,2,3]for a in A: print(a)n = 1while n &lt; 10: print(n) n = n+1 缩进控制代码块层次，推荐使用空格而不是制表符。 函数内建函数函数定义123def power2(x): return x*xprint(power2(10)) 默认参数，从后往前添加（与C++类似）123456def power(x, n = 2): res = 1 while n &gt; 0: res *= x n = n-1 return res 可变参数12345678910111213# variable arguments, pass arguments as a tupledef calc(*numbers): sum = 0 for n in numbers: sum = sum + n*n return sumprint(calc(1,2,3,4))print(calc(*[1,2,3,4]))# use * to change elements of a tuple or list into variable argumentsnums = [1,2,3,4,5]print(calc(*nums))print(*nums) 关键字参数可选123456789101112# keyword arguments, pass alternative arguments to kw as a dictdef person(name, age, **kw): if 'job' in kw: pass if 'gender' in kw: pass if 'city' in kw: pass print('name:', name, 'age:', age, 'other:',kw)person('Michael', 18, job='coder', gender='man')person('Michael', 18, **&#123;'job':'coder', 'gender':'man'&#125;) 命名关键字参数，*前面的为位置参数，后面为命名关键字参数，命名关键字参数需传入其参数名12345# named keyword arguments after *, must be passed with it's namedef person2(name, age, *, city = 'Shanghai', job): print(name, age, city, job)person2('lucy', 18, job = 'coder') 上面几种参数可组合使用。 递归函数12345678# recursive function def fun(n): if n == 1: return 1 else: return fun(n-1) * nprint(fun(100))print(fun(999)) # maximum recursion depth exceeded 默认最大递归深度限制为1000，上面传入999就会挂，修改限制1sys.setrecursionlimit(2000) 据说可以这样进行尾递归优化，但实际实验并没有什么卵用，尾递归请直接改为循环12345678# tail-call optimizationdef fun2(n, res=1): if n == 1: return res else: return fun2(n-1, res * n)print(fun2(1800)) 经典递归问题：汉诺塔12345678910# the tower of hanio, move n disks from a to cdef move(n, a, b, c): if n==1: print(a, '--&gt;', c) else: move(n-1, a, c, b) move(1, a, b, c) move(n-1, b, a, c)move(3, 'A', 'B', 'C') 高级特性切片：12345# slice print(L[0:3])print(L[::5]) # fetch first one from every five elementsprint(L[-10:]) # last 10 elementsprint('ABCDEF'[::2]) 例程，去掉一个字符串首尾两端的空格，简单而健壮12345678# strip spaces at head and tail of a string# simple and strongdef trim(s): while s[:1] == ' ': s = s[1:] while s[-1:] == ' ': s = s[:-1] return s 瞬间感觉到python的编写风格与C/C++之流太不一样了。 迭代：1234567891011# iterationD = &#123;1:2, 'hi':'luck', 'holy':'shit'&#125;for key in D: print('%s:%s'%(key,D[key]))for value in D.values(): print(value)# 同时迭代key和valuefor k,v in D.items(): print('%s:%s'%(k,v))for ch in 'ABC': print(ch) 可迭代对象：list tuple set dict123from collections import Iterableprint(isinstance(123, Iterable)) # Falseprint(isinstance([1234, 2342, 243], Iterable)) # True 例程：找到一个序列中最大与最小值12345678910def findMinAndMax(L): if len(L) == 0: return None, None min = max = L[0] for x in L: if x &lt; min: min = x if x &gt; max: max = x return min, max 函数：range(n, m) 生成n到m-1的整数列表生成式：[x*x for x in [1,2,3]] 将生成方法写在[]中12for x in range(10): print(x) 例程：打印1到100的所有偶平方数构成的list生成一个’ABCD’与’XYZ’的全排列构成的list1234L1 = [x * x for x in range(1, 11) if x % 2 == 0]print(L1)L2 = [m + n for m in 'ABCD' for n in 'XYZ']print(L2) 生成器：generator特点：生成一个序列，但是并不完整创建，而是保存生成的算法一边使用，一边生成语法：列表生成式[]换为()，使用next()获得generator的下一个返回值123456g = (x * x for x in range(10))print(g) # generator object &lt;genexpr&gt; at 0x00000186CD989D58&gt;print(next(g)) # 0print(next(g)) # 1print(next(g)) # 4print(next(g)) # 9 也可以在函数定义中使用yield返回1234567891011def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done'f = fib(10)print(f) # &lt;generator object fib at 0x0000012E71849B48&gt;for x in f: print(x) 迭代器Iterator： 凡是可作用于for循环的对象都是Iterable类型 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象 for循环的本质就是先获得一个Iterator对象，再不断调用next()实现的 Iterator对象表示一个数据流，而数据流可以是无限的 12345678910111213from collections import Iterablefrom collections import Iteratorprint(isinstance('abc', Iterable))print(isinstance([], Iterable))print(isinstance(&#123;&#125;, Iterable))print(isinstance((), Iterable))print(isinstance([x ** x for x in range(10)], Iterable))print(isinstance(iter([]), Iterator))def f(n): for x in range(n): yield x * xfun = f(10)print(isinstance(fun, Iterator)) 函数式编程函数式大法好？这我不评价，但函数式肯定是很有趣的。Python对函数式编程提供部分支持。 可以函数赋给变量，也可以给函数名赋值来覆盖。函数也可以作为参数传递，并且可以返回函数。1234def add(x, y, f): return f(x) + f(y)print(add(-1, -3, abs)) 高阶函数：map reduce filter sorted123456789101112131415# high-level functions# map(function, Iterable) # reduce(function, Iterable) -&gt; f(f(f(x1,x2),x3),x4)from functools import reduceA = range(0, 11);def f(x): return x * xB = map(f, range(0, 11)) # B is a Iteratorprint(list(B))# numbers to characterprint(list(map(str, range(0,10))))def add(x, y): return x + yprint(reduce(add, [1,3,42,345,34,5])) 例程：将表示一个浮点数的字符串变为浮点数（没有错误处理）12345678910111213141516# string to floatfrom functools import reducedigits = &#123;'0':0, '1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9&#125;def str2float(s): def f1(x, y): return x * 10 + y def char2num(c): return digits[c] def find(s): i = 0 for a in s: if a == '.': return i i = i + 1 return len(s)+1 return (reduce(f1, map(char2num, s[:find(s)])) + reduce(f1, map(char2num, s[find(s)+1:]))/pow(10, len(s)-find(s)-1)) 例程：埃托拉色尼筛法求素数（generator真好用）123456789101112131415161718192021def _odd_iter(): n = 1 while True: n = n + 2 yield n# x is not divisialbe by n, return a lambda functiondef _not_divisible(n): return lambda x : x % n &gt; 0def primes(): yield 2 it = _odd_iter() # 初始序列，奇数序列 while True: n = next(it) yield n it = filter(_not_divisible(n), it)# 打印1000以内的素数for n in primes(): if n &lt; 1000: print(n) else: break 其中的_not_divisible(n)为返回的函数，接受的参数若不能被n整除则返回True. 例程：回文数12345# 判断是否是回文数def is_palindrome(s): return str(s)[::-1] == str(s)print(list(filter(is_palindrome, range(1,1000)))) 排序：sorted12345L = [234, 1234, -234, 43, -8, 0, -10, -4, ]A = sorted(L, key = abs)print(A)B = sorted(L, key = abs, reverse = True)print(B) 例程：对list中的tuple按照姓名和分数排序12345678910L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]def by_name(t): return t[0]L1 = sorted(L, key = by_name)print(L1)def by_score(t): return t[1]L2 = sorted(L, key = by_score)print(L2) 函数作为返回值，惰性求值1234567891011def lazy_sum(*args): def sum(): res = 0 for n in args: res += n return res return sumf = lazy_sum(1, 3, 5, 7, 9)print(f) # &lt;function lazy_sum.&lt;locals&gt;.sum at 0x0000019BEF2C7EA0&gt;print(f()) # 25 python中的闭包，与离散数学中关系的闭包感觉就不是一个东西。这里的闭包意思是：在一个外函数中定义了一个内函数，内函数使用了外函数的临时变量，并且外函数的返回值是内函数的引用。用处：装饰器、面向对象。注意：返回内函数时，内函数并未执行。返回函数不要引用任何循环变量，或者后续会发生变化的变量。例程：计数器，每次调用返回下一个值12345678910def createCounter(): ax = 0 def counter(): nonlocal ax # nonlaocal 指定为非局部变量 ax += 1 return ax return countercounterA = createCounter()print(counterA(), counterA(), counterA(), counterA(), counterA()) # 1 2 3 4 5 匿名函数：即lambda表达式，不能用return，表达式结果就是返回值12f = lambda x : x * xprint(list(map(f, [1,3,4,5]))) 装饰器：函数运行期间动态增加功能，而不改变函数定义，使用语法@1234567891011121314# decorator# warpper(*args, **kw) 可以接受任何参数import functoolsdef log(func): def wrapper(*args, **kw): print('call %s :'%func.__name__) return func(*args, **kw) return wrapper@logdef now(): print('2018-6-2')now()print(now.__name__) # wrapper 更复杂一点，再加一层12345678910111213def log(text): def decorator(func): def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator@log('execute')def now(): print('2018-6-2')now()print(now.__name__) # wrapper 但是上面的工作还没有做完，函数亦是对象，装饰器的使用使得now的__name__属性变成了wrapper，所以需要将now的__name__等属性复制到wrapper中。使用Python内置的@functools.wraps()来完成这个事情。完善：1234567891011121314import functoolsdef log(func): @functools.wraps(func) def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper@logdef now(): print('2018-6-2')now()print(now.__name__) # now 偏函数：functools.partial123import functoolsint2 = functools.partial(int, base = 2)print(int2('1010101'))","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://aojueliuyun.github.io/categories/编程语言/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://aojueliuyun.github.io/tags/Python/"}]},{"title":"The Linux Command Line","slug":"2018.5.25--the-linux-command-line","date":"2018-05-24T16:00:00.000Z","updated":"2018-06-03T13:16:46.388Z","comments":true,"path":"2018/05/25/2018.5.25--the-linux-command-line/","link":"","permalink":"http://aojueliuyun.github.io/2018/05/25/2018.5.25--the-linux-command-line/","excerpt":"This passage is about getting started with GNU/Linux by reading The Linux Command Line. Chinese version is available here. It’s an excellent introductory book of Linux. No more talk, let’s just get it started. If you want to see more details, read this book, because I will ignore many details of a commmand like “How many options does this command have?” or “How to use every option of a command ?”.","text":"This passage is about getting started with GNU/Linux by reading The Linux Command Line. Chinese version is available here. It’s an excellent introductory book of Linux. No more talk, let’s just get it started. If you want to see more details, read this book, because I will ignore many details of a commmand like “How many options does this command have?” or “How to use every option of a command ?”. 我的环境: Unbuntu 18.04LTS virtual machine.还是不用我那四级水平的英语了。这不是文档，只是笔记。详细信息请使用man或者查看文档。 Part 1 – Learning The Shellshell首先什么是Shell？Shell翻译为壳，是对应于核的概念，shell是CLI（Command Line Interface，与之对应的为GUI）的命令解析工具，类似于windows下的cmd。Shell读取用户从键盘的输入，将其解释为对应的命令，然后执行对应的程序。在Linux中，常用的Shell有Bash，这里使用的即是Bash。 当使用GUI时，通常我们需要使用终端模拟器来和Shell交互。不同GUI叫法不太一样，或Terminal（终端）或Console（控制台）或其他。 Terminal Emulators 终端模拟器12tiko@killing-boat:~$ #普通用户root@killing-boat:/home/tiko# #superuser 键入每一条命令前的Shell提示符：username@machinename : current-working-directory $last character: # means superuser/administrator. 最简单的几条命令： date - display datecal - display the calenderdf - to see the current amount of free space on your disk drivesfree - display the amount of free memoryexit - closing the terminal emulator window The Console Behind The Curtain:Pressing Ctrl-Alt-F1 through Ctrl-Alt-F6 to switch.My machine : Ctrl-Alt-F1/F2 are GUIs, Ctrl-Alt-F3 to F6 are CLIs. CommandShell命令基本格式：1command [选项options] [参数arguments] 有的选项不需要参数像ls -l，有的选项参数可选，像ls &lt;file&gt;不给参数则使用默认参数.。有的命令可以带多个参数。选项分长选项与短选项，长选项如--help以--开头，短选项如-l以-开头。多个短选项可合并如ls -alh。 每个命令具体选项信息、参考文档可以通过以下帮助命令得到：1234command --help # 获取命令帮助的选项，较为简略help command # Shell内部命令帮助，仅对内部命令有效，比如cdman command # 命令手册manual，常用info command # 比man更为详细 Navigation使用下面的命令在系统中游走：pwd - Print name of current working directorycd - Change directory1234cd .. # 上一级cd - # 上一次工作目录cd ./subdir # 子目录cd . # 当前目录 Linux中使用目录（directory）而不使用文件夹（folder）的概念。文件与目录的路径可以是绝对路径（like /root/code/me）或者相对路径（like ../mydir/mydir/file ./subdir/file）。 ls - List directory contents1ls dir-or-file-path # default is . 常用选项：1234567891011ls -a # 所有文件与目录，包括.开头的隐藏文件ls -l # 长格式ls -h # 文件大小以人可读的方式列出ls -d # 列出目录本身，而不是其中的内容ls -F # 在文件结尾附加文件类型 # * 可执行文件 # / 目录 # @ 链接文件 # | 管道文件 # = 套接字 # &gt; 进程间通讯设备 上面的-a -l等称为选项（options），而后跟参数（parameter）。ls命令所有选项与详细信息可使用下列命令得到：123ls --helpman lsinfo ls 根目录/下每一个目录都有其作用，可参见这里。12345678910111213141516/ 根目录，万物起源/bin 二进制程序/boot Linux内核，RAM系统映像，启动加载程序/dev 设备节点，一切皆是文件/etc 系统层面配置文件，shell脚本/home 普通用户家目录上一级/lib 系统核心程序库文件/media 可移除设备自动挂载点/mnt 同上，早期linux系统中/opt 安装可选软件/proc 虚拟文件系统，内核相关/root root用户家目录/sbin 系统二进制文件，为root用户保留/tmp 存储临时文件，重启清空/usr 包含用户所需要所有程序和文件/var 动态文件存储地址 我的根目录：123tiko@killing-boat:~$ ls -F /bin/ cdrom/ etc/ initrd.img@ lib/ lost+found/ mnt/ proc/ run/ snap/ swapfile tmp/ var/ vmlinuz.old@boot/ dev/ home/ initrd.img.old@ lib64/ media/ opt/ root/ sbin/ srv/ sys/ usr/ vmlinuz@ file – Determine file type 显示文件类型less – View file contents 查看文本文件内容cat – 亦是查看文本内容，与less有区别tree – 以树形结构打印目录文件（需要先安装：sudo apt-get install tree） Manipulating Files And Directoriescp – Copy files and directories使用-i选项来提示是否要覆盖已存在文件，若没有则直接覆盖。mv – Move/rename files and directories移动到不同目录即移动，移动到当前目录即重命名。mkdir – Create directories12mkdir dir1 dir2 ../dir3mkdir -p ./mydir1/mydir2 # 递归创建 rm – Remove files and directories 删除文件与目录1rm -rf /* # 人们常开的玩笑 -f 强制执行，-r递归删除目录与文件 其中*是通配符，详细信息查看这里。ln – Create hard and symbolic links 创建硬链接或者符号链接12ln fun fun-hard # to create a hard link, point to a block of diskln -s fun fun-soft # to create a symbolic link, point to the path of a file Working With Commandstype – Indicate how a command name is interpreted 表明命令类型，分类：alias别名、bulitinShell内建命令、file磁盘可执行文件、functionShell函数、keyword关键字/Shell保留字。123456tiko@killing-boat:~$ type lsls 是 `ls --color=auto' 的别名tiko@killing-boat:~$ type cd cd 是 shell 内建tiko@killing-boat:~$ type cpcp 是 /bin/cp which – Display which executable program will be executed12tiko@killing-boat:~$ which gcc/usr/bin/gcc help – Get help for shell builtinsman – Display a command’s manual page 使用man查手册apropos – Display a list of appropriate commandsinfo – Display a command’s info entrywhatis – Display a very brief description of a command12tiko@killing-boat:~$ whatis lsls (1) - list directory contents alias – Create an alias for a command 给命令创建别名1alias ll='ls -alF' 使用alias不加选项与参数打印当前已经创建的别名。常用的已经创建的别名：12345alias grep='grep --color=auto'alias l='ls -CF'alias la='ls -A'alias ll='ls -alF'alias ls='ls --color=auto' 键入alias命令创建的别名在终端关闭后失效。 Redirection 重定向cat － 连接文件并显示1cat log.txt test.txt sort － 排序文本行uniq － 报道或省略重复行12cat log.txt | uniq # 打印出log.txt中内容，重复行只打印一次cat log.txt | uniq -d # 只打印重复行 grep － 打印匹配行wc － 打印文件中换行符，字，和字节个数12tiko@killing-boat:~$ wc new.txt 19 61 416 new.txt head － 输出文件第一部分1head -n 10 new.txt # 查看前10行 tail - 输出文件最后一部分1tail -n 10 new.txt # 查看尾10行 &gt; - 重定向标准输出&gt;&gt; - 以追加的方式重定向标准输出1cat log.txt test.txt &gt; new.txt # 将前面两个文件的内容连接并输出到 2&gt; - 重定向标准错误输出2&gt;&gt; - 以追加的方式重定向标准错误输出123tiko@killing-boat:~$ ahsjkfh 2&gt; log.txttiko@killing-boat:~$ cat log.txt ahsjkfh：未找到命令 | - 管道符，将一个命令的输出作为另一个命令的输入12tiko@killing-boat:~$ ll | sort | grep code # 多个管道符连接使用，过滤器drwxrwx--x 8 tiko tiko 4096 5月 20 22:53 code/ 重定向到文件，管道符到命令，千万不要混淆。 tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件1cat log.txt | tee new.txt | grep ha 使用| tee和重定向&gt;作用类似，但是| tee可以在输出到文件的同时将信息输出到终端。 Seeing The World As The Shell Sees Itecho － 显示一行文本12345678910111213141516tiko@killing-boat:~$ echo hello.world!hello.world!tiko@killing-boat:~$ echo * code examples.desktop log.txt new.txt snap test.txt 公共的 模板 视频 图片 文档 下载 音乐 桌面tiko@killing-boat:~$ echo /*n/bin /run /sbintiko@killing-boat:~$ echo /usr/*/share/usr/local/sharetiko@killing-boat:~$ echo ~/home/tikotiko@killing-boat:~$ echo ~root/roottiko@killing-boat:~$ echo $SHELL/bin/bashtiko@killing-boat:~$ echo $((2+3))5 甚至可以求解表达式，形式：((expression))`，支持`+` `-` `*` `/` `%` `**`(取幂)操作，`表示变量或者参数。12tiko@killing-boat:~$ echo $(( (4-2+3**2*10) / 10 % 2))1 花括号展开，甚至可以嵌套123456tiko@killing-boat:~$ echo front-&#123;A,B,C&#125;-backfront-A-back front-B-back front-C-backtiko@killing-boat:~$ echo A&#123;B&#123;1,2&#125;,C&#123;3,4&#125;&#125;DAB1D AB2D AC3D AC4Dtiko@killing-boat:~$ echo &#123;A..Z&#125;A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 然后可以这样，超级棒有木有？解放生产力！1234567tiko@killing-boat:~$ mkdir mydir ; cd mydirtiko@killing-boat:~/mydir$ mkdir &#123;2007..2009&#125;-0&#123;1..9&#125; &#123;2007..2009&#125;-&#123;10..12&#125;tiko@killing-boat:~/mydir$ ls2007-01 2007-05 2007-09 2008-01 2008-05 2008-09 2009-01 2009-05 2009-092007-02 2007-06 2007-10 2008-02 2008-06 2008-10 2009-02 2009-06 2009-102007-03 2007-07 2007-11 2008-03 2008-07 2008-11 2009-03 2009-07 2009-112007-04 2007-08 2007-12 2008-04 2008-08 2008-12 2009-04 2009-08 2009-12 参数展开12tiko@killing-boat:~/mydir$ echo $USERtiko 命令替换，将一个命令的输出作为展开模式来使用，用法 $(command)12tiko@killing-boat:~$ ls -l $(which cp)-rwxr-xr-x 1 root root 141528 1月 18 17:43 /bin/cp 也可以使用一种旧语法，使用反引号 `12tiko@killing-boat:~$ ls -l `which cp`-rwxr-xr-x 1 root root 141528 1月 18 17:43 /bin/cp 使用双引号&quot; &quot;，除Shell的特殊字符$ \\ 和 ` 之外均会失去其特殊含义。双引号中，参数展开，算术表达式，命令替换展开任然有效。1234tiko@killing-boat:~$ echo there is a testthere is a testtiko@killing-boat:~$ echo \"there is a test\"there is a test 使用双引号可以很微妙，其中的空格不被当做分界符，而是一个字符。看一看下面：12345678910tiko@killing-boat:~$ echo $(cal)五月 2018 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31tiko@killing-boat:~$ echo \"$(cal)\" 五月 2018 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 如果想使用` `\\` \\` 这些字符则需要转义 `\\ \\\\ \\` 如果要禁止所有展开，则使用单引号&#39; &#39;12tiko@killing-boat:~$ echo '$(cal)'$(cal) 展开和引用是非常有用的东西，甚至可以说是学习Shell 最重要的部分。 echo的-e选项可以使其可以解释转义字符，转义字符参见ASCII码表的前32个字符。12tiko@killing-boat:~$ echo -e \"\\t$SHELL\\a\" /bin/bash 这里\\t是制表符，\\a是响铃。 Advanced Keyboard Tricks首先：clear － 清空屏幕history － 显示历史命令 至于光标移动，不熟悉不写，可以看这里。 自动补全使用Tab。如果有多个匹配项，则两次Tab显示所有匹配项。 !!执行上一条命令，直接上下箭头更方便。!number执行历史命令列表中number行的命令。只想问真的有人会这样用吗？？ 需要用到的话在回来看。 Permissions 权限Linux同Windows一样是多用户系统，所以需要管理用户、用户组与权限。某些时候我们读写文件时会遇到权限不够的情况。以长格式列出一个文件的信息：12tiko@killing-boat:~$ ls -l log.txt -rw-rw-r-- 1 tiko tiko 41 5月 26 11:11 log.txt 其中第一个字符表示文件类型。分类：-普通文件、d目录、l符号链接、c字符设备文件（如键盘）、b块设备文件（如硬盘）。【Linux中一切皆是文件】其后rw-rw-r--三个一组分别表示文件所有者、文件所有组、其他用户的读、写、执行权限。其后一个数字表示该文件硬链接数目，然后是文件所有者以及文件所属用户组、字节为单位的文件大小、上次修改文件日期，最后为文件名。 当没有这个权限的用户对该文件执行该操作就会提示权限不够：1234tiko@killing-boat:~$ ll /etc/shadow-rw-r----- 1 root shadow 1357 4月 30 16:13 /etc/shadowtiko@killing-boat:~$ cat /etc/shadowcat: /etc/shadow: 权限不够 id – 显示用户身份号12tiko@killing-boat:~$ iduid=1000(tiko) gid=1000(tiko) 组=1000(tiko),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare) 其中uid是用户ID，gid是组ID。用户帐户定义在/etc/passwd文件里面，用户组定义在/etc/group中，文件/etc/shadow包含了关于用户密码的信息。 chmod – 更改文件模式，仅文件/目录所有者和root用户可以更改 该命令两种使用方法：八进制数字表示、符号表示法。八进制法的意思是将rwx三种权限作为三位二进制数，有权限为1，无权限为0，表示为八进制数。更改是使用三个八进制数更改所有者、所有组、其他人的权限。1234ko@killing-boat:~$ ll log.txt -rwxrwxrwx 1 tiko tiko 41 5月 26 11:11 log.txttiko@killing-boat:~$ chmod 764 log.txt ; ll log.txt -rwxrw-r-- 1 tiko tiko 41 5月 26 11:11 log.txt* 上面的764表示为文件log.txt赋予rwxrw-r--权限。末尾的*表示该文件可执行（其实只有执行权限，执行会出现错误），不是文件名的一部分。符号表示法比较麻烦，不写。用八进制表示法就很方便。 umask – 设置默认的文件权限 使用八进制掩码作为参数，默认权限rw-rw-rw-，掩码位为1，则创建新文件时该位权限被关闭。常用系统掩码位0002，默认屏蔽其他用户的写权限。一般情况下不需要更改。12345678tiko@killing-boat:~$ umask0002tiko@killing-boat:~$ umask 0000tiko@killing-boat:~$ umask 0000tiko@killing-boat:~$ touch new.txttiko@killing-boat:~$ ll new.txt -rw-rw-rw- 1 tiko tiko 0 5月 26 15:29 new.txt 其实除了读写执行外还有其他权限，这里略过。 su – 以另一个用户的身份来运行 shell12345678tiko@killing-boat:~$ su密码： root@killing-boat:/home/tiko# su tikotiko@killing-boat:~$ exitexitroot@killing-boat:/home/tiko# exitexittiko@killing-boat:~$ 可以看到su会重新启用一个Shell，exit退出该Shell返回原先Shell，不加参数默认切换到root用户。 sudo – 以另一个用户的身份来执行命令12tiko@killing-boat:~$ sudo apt-get update[sudo] tiko 的密码： 其配置文件为/etc/sudoers，修改可配置sudo权限。 chown – 更改文件或者目录所有者123456tiko@killing-boat:~$ ll -d .drwx--x--x 20 tiko tiko 4096 5月 26 15:37 ./root@killing-boat:/home/tiko# chown root:root .root@killing-boat:/home/tiko# ll -d .drwx--x--x 20 root root 4096 5月 26 15:37 ./ chgrp – 更改文件组所有权123root@killing-boat:/home/tiko# chgrp root .root@killing-boat:/home/tiko# ll -d .drwx--x--x 20 tiko root 4096 5月 26 15:37 ./ passwd – 更改用户密码1passwd user 其他用来创建和维护用户与用户组的命令，见名知意：adduser useradd groupadd Processes 进程进程详细定义见操作系统类教材，Linux Kernel核维护每一个进程的信息，并为每一个进程分配一个数字称PID。进程按PID升序排列。进程也有所有者和用户ID。 ps – 报告当前进程快照1234tiko@killing-boat:~$ ps PID TTY TIME CMD 10383 pts/2 00:00:00 bash 10553 pts/2 00:00:00 ps top – 显示任务jobs – 列出活跃的任务在一个任务后加&amp;将其作为后台任务，与执行一个前台任务时按Ctrl-Z功能相同，均为将任务中止转入后台等待，使用fg %number将其移入前台运行，bg %number将其移入后台运行。而执行一个任务时Ctrl-C为终止该任务。bg – 把一个任务放到后台执行fg – 把一个任务放到前台执行12345tiko@killing-boat:~$ jobs[1] 已停止 vim new.txt[2]- 已停止 vim if.txt[3]+ 已停止 sudo visudotiko@killing-boat:~$ fg %3 # 则唤醒任务sudo visudo kill – 给一个进程发送信号123kill [-signal] PID...kill PID # 杀死PID对应进程kill -l # 获得完整信号列表 killall – 杀死指定名字的进程shutdown – 关机或重启系统 12345678910111213141516171819tiko@killing-boat:~$ xlogo &amp;[1] 10987tiko@killing-boat:~$ xlogo &amp;[2] 10994tiko@killing-boat:~$ ps PID TTY TIME CMD 10836 pts/0 00:00:00 bash 10987 pts/0 00:00:00 xlogo 10994 pts/0 00:00:00 xlogo 10995 pts/0 00:00:00 pstiko@killing-boat:~$ fg %1xlogo^Ctiko@killing-boat:~$ killall xlogotiko@killing-boat:~$ ps PID TTY TIME CMD 10836 pts/0 00:00:00 bash 11003 pts/0 00:00:00 ps[2]+ 已终止 xlogo 其他命令：pstree – 输出一个树型结构的进程列表，这个列表展示了进程间父/子关系。vmstat – 输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。xload – 一个图形界面程序，可以画出系统负载的图形。tload – 与 xload 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。 关机与重启（root用户不需要sudo）：12345678sudo shutdown -h now # 立即关机sudo poweroff # 立即关机sudo init 0 # 立即关机sudo shutdown -h -t 60 # 60s后关机sudo shutdown -c # 取消关机sudo shutdown -r now # 立即重启sudo reboot # 立即重启sudo init 6 # 立即重启 OK, Part 1 is over. Let’s get to Part 2. Part 2 – Configuration And The EnvironmentThe Environmentprintenv - 打印部分或所有的环境变量不加选项执行之后你会看到所有环境变量。1234tiko@killing-boat:~$ printenv SHELL/bin/bashtiko@killing-boat:~$ echo $SHELL/bin/bash 一些有趣的环境变量： SHELL 使用的Shell程序，如/bin/bash HOME 用户家目录 PATH 可执行程序的搜索目录，用冒号分开的目录列表 PWD 当前工作目录 OLD_PWD 先前工作目录 USER 当前用户 PS1 用于订制Shell提示符 LANG 定义字符集与语言编码格式，我的为zh_CN.UTF-8 set - 显示环境变量与Shell变量export — 导出环境变量，让随后执行的程序知道alias - 创建命令别名 建立Shell环境的称为启动文件的配置脚本：登录Shell会话： /etc/profile，所有用户的全局配置脚本。 ~/.bash_profile，用户私有启动文件，用于扩展或重写全局配置脚本中的设置。 ~/.bash_login，如果上面这个文件没有找到，则读取这个。 ~/.profile，如果上面两个都没有找到，则读取这个，这是Debain发行版中的默认设置，比如Ubuntu中。 非登录Shell会话： /etc/bash.bashrc，全局配置脚本。 ~/.bashrc，用户私有启动文件。 vi &amp; vim不用多说，经典的编辑器。vim是vi的增强版，但我真的不会用，用不习惯，什么时候想好好折腾了再去理解vim的哲学吧。终端键入vimtutor即可开始vim练习，半小时即可入门（才怪）。vim的哲学。 Customizing The Prompt自己订制Shell提示符。详见这里。可以更改格式与颜色，比如这样： 更改环境变量$PS1，我的：1tiko@killing-boat:~$ PS1=\"\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;33m\\]\\w\\[\\033[00m\\]$ \" 终端重启后更改会丢失，若要为当前用户永久更改，在~/.bashrc文件末尾添加：1export PS1=\"\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;33m\\]\\w\\[\\033[00m\\]$ \" 其中一些主要转义字符：\\u 当前用户\\h 本地主机名\\w 当前工作目录\\$ 普通用户提示字符$ 另外还可以及进行颜色控制。 Part 3 – Common Tasks And Essential ToolsPackage ManagementLinux发行版两大阵营：Debian, RedHat 阵营 发行版 Debian Debian, Ubuntu, Xandros, Linspire RedHat Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS 包管理工具： 风格 底层工具 顶层工具 Debian dpkg apt-get,aptitude RedHat rpm yum 不过现在Ubuntu中好像鼓励用apt替代apt-get，原因是apt命令更简单，更友好。详见：Linux中apt与apt-get命令的区别与解释。 当然还有其他不属于这两个阵营的发行版。上一张图体会一下Linux大家族： Storage Media 存储媒介关于文件系统，这里就不多说了。Linux中大多使用ext3文件系统（我的是ext4，使用df -T或者cat /etc/fstab查看）。Linux维护单一的文件系统树，允许挂载不同文件系统的设备。挂载，顾名思义，就是将文件设备连接到系统文件树上（Linux中一切皆是文件，设备亦然）。 文件/etc/fstab列出了系统启动时要挂载的设备。/dev目录包含了所有系统中使用的外部设备。要使用就要将设备挂载到一个目录，然后通过访问该目录来访问设备。设备文件分为块设备（Block device）和字节设备（Character device）。其中 块设备文件，有缓冲可以随机存取（有物理设备与虚拟设备之分），如HDD，CD-ROM。 字节设备文件，无缓冲只能顺序读取，如键盘，鼠标。 mount – 挂载一个文件系统不带参数显示当前挂载的文件系统。列表格式：设备 on 挂载点 type 文件系统类型（可选的）。1mount -t [文件类型] /dev/设备 /mnt/挂载目录 umount – 卸载一个文件系统1umount /dev/设备 fsck – 检查和修复一个文件系统fdisk – 分区表控制器mkfs – 创建文件系统fdformat – 格式化一张软盘（软盘没有人用了吧！）dd — 把面向块的数据直接写入设备genisoimage (mkisofs) – 创建一个 ISO 9660的映像文件wodim (cdrecord) – 把数据写入光存储媒介md5sum – 计算 MD5检验码 Networking 网络ping - 发送 ICMP ECHO_REQUEST 软件包到网络主机1ping URL # 向指定URL的主机发送一种叫做IMCP ECHO_REQUEST的特殊网络数据包 traceroute - 打印到一台网络主机的路由数据包netstat - 打印网络连接，路由表，接口统计数据，伪装连接，和多路广播成员ftp - 因特网文件传输程序（文件传输协议）wget - 非交互式网络下载器使用wget可以从网站或者FTP服务器上下载数据，比如下载github的首页：1wget github.com ssh - OpenSSH SSH 客户端（远程登录程序） Searching For Files 查找locate – 通过名字来查找文件快速搜索数据库，输出每个与字符串匹配的文件名。支持路径匹配与通配符。现在一般使用slocate或者mlocate，但命令一般依旧使用locate。我的locate的数据库为/var/lib/mlocate/mlocate.db，可在man手册中找到。这个数据库由updatedb程序周期性运行创建。所以新建的文件搜索不到的话，可手动执行sudo updatedb创建。 find – 在目录层次结构中搜索文件1find ~ -type d | wc -l 可以使用-type指定搜索类型，更多选项参考man手册。 xargs – 从标准输入生成和执行命令行touch – 更改文件时间，如果文件不存在则创建文件stat – 显示文件或文件系统状态 Archiving And Backup 归档与备份文件压缩：gzip – 压缩或者展开文件bzip2 – 块排序文件压缩器归档：tar – 磁带打包工具zip – 打包和压缩文件文件同步程序：rsync – 同步远端文件和目录 Regular Expressions 正则正则内容不少，很早之前了解过，不过现在全忘了，什么时候需要用到了复习一下了，单独写。可参考这篇文章：正则表达式30分钟入门（才怪）。 Text Processing 文本处理cat – 连接文件并且打印到标准输出sort – 给文本行排序uniq – 报告或者省略重复行cut – 从每行中删除文本区域paste – 合并文件文本行join – 基于某个共享字段来联合两个文件的文本行comm – 逐行比较两个有序的文件diff – 逐行比较文件patch – 给原始文件打补丁tr – 翻译或删除字符sed – 用于筛选和转换文本的流编辑器aspell – 交互式拼写检查器 Formatting Output 格式化输出nl – 添加行号fold – 限制文件列宽fmt – 一个简单的文本格式转换器pr – 让文本为打印做好准备printf – 格式化数据并打印出来groff – 一个文件格式系统 Compiling Programs 编译程序学习Linux，必然少不了在Linux上进行代码编译。Linux上最常用的编译工具自然是GNU的GCC（GNU Compiler Collection，GNU编译器套件）了。 GNU make是Linux常用的维护程序的软件，我们用它来管理自己的项目。Make有自己的语法，可以在Makefile中编写项目中源文件的编译规则，指定源文件间的依赖关系。然后执行make命令即可编译整个项目。当项目中的源文件更改之后，make会检查源文件的时间戳，并重新编译所有依赖于被修改的文件的源文件。这在需要大量编译时间的大型项目中，是非常必要的。关于make的语法细节可参考Makefile经典教程，或者官方文档。 Part 4 – Writing Shell ScriptsShell脚本编写内容较多，放在下一次单独写。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://aojueliuyun.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://aojueliuyun.github.io/tags/Linux/"}]},{"title":"【write a toy cpu】实现","slug":"2018.5.16--write-a-toy-cpu--implementation","date":"2018-05-15T16:00:00.000Z","updated":"2018-05-25T09:50:46.211Z","comments":true,"path":"2018/05/16/2018.5.16--write-a-toy-cpu--implementation/","link":"","permalink":"http://aojueliuyun.github.io/2018/05/16/2018.5.16--write-a-toy-cpu--implementation/","excerpt":"自上大学开始，很早就听说过了CPU这个东西，唯一知道的是：这个东西很复杂，这个东西是计算机的核心，这个东西集成电路做的，而且主要应该是数字集成电路做的，就是说主要进行的是0和1的操作。但对内部工作原理还是一脸懵逼。众所周知，计算机的五个组成部分为运算器（数据通路）、控制器、存储器、输入/输出设备。而CPU的角色应该就是运算器与控制器，两者是结合而并非独立的。但内部呢？依旧不懂。而后有学过8086汇编，对汇编有了一点基础的了解。大概知道CPU是读取一条条的机器指令来执行的，特定的指令会对寄存器、内存、特定的标志位进行操作。处理器内部电路依旧不知，汇编如何翻译成机器码依旧不知。但也只剩下这两个问题了。所以现在只需要解决两个问题：汇编如何翻译成机器码，机器码是如何在CPU里面运行起来的。 而汇编，很明显，是与具体的处理器相关的。也即是不同处理器的指令集体系结构（ISA,Instruction Set Architecture）是不同的。对应的处理器设计也必然是不同的。主要可分为RISC和CISC，这里实现MIPS32指令集的部分指令。正文会简单介绍。 自4月份大概快结束时环境搭好后，实现大概花了半个月的课余时间，到现在都五月中旬了。很多时候在划水，其实应该要不了这么久的。而且我的目标只实现一部分指令就行了，能玩就可以了。按照实现顺序依次实现了：ori，逻辑运算、移位指令和空指令，移动操作指令，部分算术操作指令，条件分支、无条件转移指令，加载存储指令。没有实现协处理器相关指令和中断异常相关指令。至于什么指令级并行、数据级并行、乱序发射啥的统统都是没有的。不过有了前面的那些已经可以进行很多操作了。下面简单说一下实现思路。细节可参考《自己动手写CPU》，或者作者博客。我的实现基本上否是参考这本书，以及这个repo:abcdabcd987/toy-cpu.","text":"自上大学开始，很早就听说过了CPU这个东西，唯一知道的是：这个东西很复杂，这个东西是计算机的核心，这个东西集成电路做的，而且主要应该是数字集成电路做的，就是说主要进行的是0和1的操作。但对内部工作原理还是一脸懵逼。众所周知，计算机的五个组成部分为运算器（数据通路）、控制器、存储器、输入/输出设备。而CPU的角色应该就是运算器与控制器，两者是结合而并非独立的。但内部呢？依旧不懂。而后有学过8086汇编，对汇编有了一点基础的了解。大概知道CPU是读取一条条的机器指令来执行的，特定的指令会对寄存器、内存、特定的标志位进行操作。处理器内部电路依旧不知，汇编如何翻译成机器码依旧不知。但也只剩下这两个问题了。所以现在只需要解决两个问题：汇编如何翻译成机器码，机器码是如何在CPU里面运行起来的。 而汇编，很明显，是与具体的处理器相关的。也即是不同处理器的指令集体系结构（ISA,Instruction Set Architecture）是不同的。对应的处理器设计也必然是不同的。主要可分为RISC和CISC，这里实现MIPS32指令集的部分指令。正文会简单介绍。 自4月份大概快结束时环境搭好后，实现大概花了半个月的课余时间，到现在都五月中旬了。很多时候在划水，其实应该要不了这么久的。而且我的目标只实现一部分指令就行了，能玩就可以了。按照实现顺序依次实现了：ori，逻辑运算、移位指令和空指令，移动操作指令，部分算术操作指令，条件分支、无条件转移指令，加载存储指令。没有实现协处理器相关指令和中断异常相关指令。至于什么指令级并行、数据级并行、乱序发射啥的统统都是没有的。不过有了前面的那些已经可以进行很多操作了。下面简单说一下实现思路。细节可参考《自己动手写CPU》，或者作者博客。我的实现基本上否是参考这本书，以及这个repo:abcdabcd987/toy-cpu. ISA先来看一下ISA的定义，ISA-Wikipedia： An instruction set architecture (ISA) is an abstract model of a computer. It is also referred to as architecture or computer architecture. A realization of an ISA is called an implementation. An ISA permits multiple implementations that may vary in performance, physical size, and monetary cost (among other things); because the ISA serves as the interface between software and hardware. Software that has been written for an ISA can run on different implementations of the same ISA. This has enabled binary compatibility between different generations of computers to be easily achieved, and the development of computer families. Both of these developments have helped to lower the cost of computers and to increase their applicability. For these reasons, the ISA is one of the most important abstractions in computing today. 首先ISA是一个抽象模型，一个ISA可以有不同的实现。ISA的角色是硬件和软件的接口。CPU通过电路物理上实现ISA，软件通过编译器将高级语言编译为ISA对应的汇编语言进而翻译为机器码，即可在实现了该ISA的处理器上运行。ISA可以说是计算机中最重要的抽象。 只要ISA相同，实现方式的不同并不会影响软件的运行，这也是接口这个伟大的抽象的意义。接口面向调用者，需要进行的所有操作通过接口去调用，内部实现对调用者是完全透明的。这样对于一款处理器，知道其ISA，我们就可以编写程序，而不需要知道内部实现。 抽象-接口-分层有了接口这个抽象，我们便可以将计算机体系进行分层，分层在计算机科学中是广泛存在的，比如计算机层次结构： 和计算机网络中的国际标准OSI七层模型与事实工业标准的TCP/IP四层模型： 都是很好的体现。在哪一层操作，我们只需要知道其下层的接口，而不必知道具体实现。这可以简化问题的复杂度，使我们只需专心处理其中一层的问题。 指令集体系结构一个指令集体系结构定义了： 支持的数据类型（supported data types） 主存与寄存器（the main memory and registers） 内存一致性，寻址方式（memory consistency and addressing modes） 机器指令集合（the set of machine instructions） 输入输出模型（input/output model） MIPS指令集详细信息参见MIPS architecture - Wikipedia。MIPS指令集是精简指令集（CISC）的典型代表。龙芯使用的便是MIPS指令集。MIPS算是一类架构，并不单一，有各种扩展以及子架构等。如MIPS I，MIPS II，MIPS III…MIPS 32，MIPS 64，MIPS 64 R2…等等。这算是一个比较学院派的指令集，在商业上并不算成功（相比Intel x86-64），但这对这里的实现并不会有什么影响。其设计者John L. Hennessy与 David A. Patterson是去年(2017)ACM图灵奖的获得者。下面看一下MIPS32指令集的一些细节。 数据类型：一个字4个字节32bit，支持半字与字节。寄存器：定义了32个通用寄存器（与x86的专用寄存器设计不同）命名为$0...$31，很明显需要5个二进制位来寻址寄存器。并且还定义了两个专用寄存器HI和LO用来存储两个32位操作数的乘积或者商与余数。 指令类型：MIPS32的所有指令均为32位，分为三大类R型、I型、J型. 其中opcode为指令码，R型指令中rs,rt保存源操作数的寄存器号，I型指令中一般rs位源操作数，rt为目的操作数，具体的指令具体看。rd代表要写入的目的寄存器。shamt代表位移量（仅在移位指令中使用）。funct为功能码，opcode相同的不同R型指令通过funct字段来区分。immediate代表16位立即数。address为26位地址，在分支跳转指令中使用。 寻址方式：立即数寻址、寄存器寻址、基址寻址、PC相对寻址。 所有指令：详细信息可以在MIPS architecture - Wikipedia 和 MIPT-ILab/mipt-mips中找到，太多不抄。 处理器结构现在指令集有了，机器语言也有了（就是每一条汇编语句对应的32位机器码），那就需要来实现了。很明显我们需要对每条32位指令进行解码，然后执行，执行之前需要从寄存器堆中取出操作数。解码之前需要取出指令，所以就要有一个指向当前指令的程序计数器(PC)以及存储指令的指令存储器。执行完了之后需要将结果写入特定寄存器或者数据存储器。 那么一个处理器的大致结构就有了。具体怎么得到的请参考《计算机组成与设计：硬件软件接口》第三章（下面框图均来自该书）。这里没有包含控制模块，只给出了一些模块的控制信号。 简单解释一下： PC为程序计数器，最小编址单位为字节，一条指令32字节。上面的加法器+4使PC移动到下一条指令。 从指令存储器取出指令解码后，需要从寄存器堆中取出最多两个源操作数，以及写入一个目的操作数。所以有两个读端口，一个写端口。 Sign-extend即符号扩展，这里将16位立即数（I型指令后16位）符号扩展到32位传递到下一阶段参与下一步操作。 在ALU中对操作数执行操作，得到结果，具体执行什么操作由具体指令决定。 执行之后的结果保存至存储器或者寄存器堆。 右上角的为分支跳转指令的地址处理模块，左移两位代表着分支跳转指令中的地址单位是字，所以需要左移两位(乘以4)。 执行条件转移指令时，下一条执行的指令由条件判定得到，即最右上角多路选择器输入信号为条件判定结果。 ALU为通用的算术逻辑运算单元，可以对输入的32位操作数进行加减移位等操作。 流水线（pipeline）如果将上面所有操作都放在一个时钟周期内执行，那么时钟周期的取值必须要大于上面框图中最大的延时。我们可以将上述过程分为下列五个阶段： 取指（instruction fetch）IF 译码（instruction decode）ID 执行（execution）EX 访存（memory）MEM 写回（write back）WB 如果按照上面的数据流图来设计处理器，同一时刻必然只能执行上面五个操作中的一个，而执行其余操作额模块处于空闲状态，资源浪费明显。所以我们需要引入流水线机制。这五个阶段便是典型的五级流水线的流水阶段。我们在每一个阶段之间加入一个触发器，在时钟上升沿触发，将数据传送到下一阶段。如果流水线划分得当，可以使时钟周期下降为原来的五分之一。虽然一条指令需要五个周期才能执行完，但一个时钟周期内同时执行了五条指令。毫无疑问提高了效率。 MIPS的典型五级流水线框图： 这里加上了控制模块。其中的IF/ID、ID/EX、EX/MEM、MEM/WB均为触发器，时钟上升沿来临时将信息传递到下一阶段。 流水线冒险 任何事物都是有两面性的，如果一个事物看起来只有好处而没有任何坏处，那么它隐藏在水面下的暗流一定会在什么时候掀翻你的小船。——Tiko.T 流水线当然也不例外，伴随着流水线而来的便是冒险（hazard），冒险指的是下一个周期的下一条指令将不能按照预定的计划执行，如果执行便会产生非预期结果的情况。 冒险分为三类：结构冒险：硬件资源冲突，这在这里实现的流水线中非常容易避免。数据冒险：后面执行的指令依赖于前面指令执行的结果，然而在后面指令需要数据的时候，前面的指令还未将其写入指定存储位置/寄存器。控制冒险：流水线分支指令修改PC造成的冒险。 这里实现只会产生数据相关造成的冒险。解决途径：流水线暂停：将依赖于前面指令运行结果的指令暂停，等到前面指令将结果写入后，再运行即可。数据前推：某些指令在EX或者MEM阶段便已经得到结果。只需要将这时候的数据传递回ID阶段，便可以解决。结合上述两种方式，便可以解决这里要实现的所有数据相关问题。 verilog实现使用verilog进行编程，verilog的编写思路与高级编程语言很不一样，就我个人的感觉。用verilog写电路是已经有了这个电路的功能、连接关系、时序后直接将其翻译为相应的verilog描述即可。这里只采用行为级描述与RTL级描述。不需要任何结构描述，我们只需要知道功能以及接口就可以了，不需要从晶体管、逻辑门层级上去建模。所以使用的全都是最简单的语法如if，else，case，assign，&lt;=。verilog语法比较简单，但是就是因为简单，所以很多时候带来的是大量的冗余和重复代码下面介绍带参宏可以很好的解决这个问题。不得不说行为级描述非常棒，像我这种搞不懂晶体管的也可以写一个电路来娱乐一下。下面的代码就不贴了，已上传到Github，逻辑都比较简单，这里只简要叙述一下每个流水线阶段进行的操作。 第一条指令ori的实现第一条实现的指令是ori，执行立即数或操作。指令用法：ori rs,rt,immidiate操作：$rt = $rs | zero-extended(immidiate)，即将立即数无符号扩展（即零扩展，前面填16个0即可）至32位后，与寄存器rs的值进行按位或操作，结果写入寄存器rt。指令格式：I型，op = 6&#39;b001101 实现： IF阶段：将32bit指令从指令存储器中取经过信号线inst传递到到ID（中间会经过触发器IF/ID，后同）。 ID阶段译码：简单的case语句，判断inst[31:26]是否等于ori的op，是的话，将rs，rt寄存器的值，具体指令类型，符号扩展后的immidiate传到EX阶段。 EX阶段执行：根据前一阶段传递过来的类型，对两个源操作数执行或操作，生成1bit寄存器写使能信号we，5bit要写入的寄存器编号waddr，32bit要写入寄存器的值wdata到MEM阶段。 MEM阶段：仅传递这三个信号不执行任何其他操作。 WB阶段：将这三个信号传递到寄存器堆regfile。 regfile在下一个时钟周期上升沿来临时依据输入的三个信号，判断是否要写入，we有效则将值写入相应寄存器。则一条指令执行完成。 可以看到从ID到执行完毕，经过了四个触发器，并且regfile在时钟上升沿来临将值写入，指令执行完毕，共消耗五个时钟周期。ori实现完成。 上面的过程很简单，但是实际编码还是有一定的编码量的，需要实现的模块有： inst_rom，指令存储器，使用$readmemh读入指令文件inst_ori_test.txt pc_reg，程序计数器 if_id，触发器 id，译码阶段 regfile，寄存器堆 ex，执行阶段 ex_mem，触发器 mem，访存阶段 mem_wb，触发器 openmips，除去存储器之外的模块实例化，连接模块 open_mips_min_sopc，最小SOPC，openmips以及inst_rom实例化 open_mips_min_sopc_tb，test bench测试模块，使用$dumpvars和$dumnpfile将波形导出到open_mips_min_sopc_tb.vcd。 模块间连接关系如图（来自作者博客，侵删）： 测试使用的汇编源文件inst_ori_test.s:12345678 .org 0x0 # 指示地址从0x0开始 .global _start # 定义一个全局符号 _start .set noat # 允许自由使用寄存器$1_start: ori $1,$0,0x1100 ori $2,$0,0x0020 ori $3,$0,0xff00 ori $4,$0,0xffff 编译得到机器码用十六进制字符表示，文件inst_ori_test.txt123434011100340200203403ff003404ffff 如何编译查看上一篇文章：【write a toy cpu】环境搭建。 实现之后，依次执行下列命令编译、仿真、查看波形：123iverilog -s open_mips_min_sopc_tb -o a.out ./*.vvvp a.outgtkwave open_mips_min_sopc_tb.vcd 即可看到以下波形： 上述波形给出了很详细的主要阶段的信号变化。可以看到ori指令应该实现正确了。上面四条指令并没有出现数据相关，现在我们考虑数据相关。这里采用数据前推的方式解决。细节参见：自己动手写CPU之第五阶段（1）——流水线数据相关问题。 解决数据相关之后，测试如下汇编源文件：12345678 .org 0x0 .global _start .set noat_start: ori $1,$0,0x1100 ori $2,$1,0x0020 ori $3,$2,0xff00 ori $4,$3,0xffff 得到波形如下： ori实现之后的源码：点击下载。 后续指令实现后续依次实现逻辑、移位、空指令、移动操作指令（增加hilo_reg模块，同样采用数据前推处理数据相关）、算术操作指令（实现流水线暂停机制，增加模块ctrl）、转移指令（实现延迟分支）、加载存储指令（增加data_ram数据存储器模块，处理load相关，采用流水线暂停处理）。后续还有协处理器访问指令和异常相关指令，我并没有做实现。 细节不过多赘述，最后大概也就1k行代码左右，其中还有一半左右是输入输出信号线声明、模块实例化啥的，代码量不算大，但我感觉自己写了很久，还是太菜的缘故吧！有兴趣的话可参考《自己动手写CPU》，以及我的实现：aojueliuyun/toy_cpu。 tricks编写verilog时的一些小trick。 带参宏verilog的语法是很简单的，这导致了很多时候经常要进行重复的赋值操作。人肉编码很容易出错，copy，paste也很麻烦，波形看花眼。而verilog中的函数是不可综合的。但是依然可以使用带参宏，整洁美观，缩减了代码量，提高可维护性。 如id.v中定义的：123456789101112`define SET_INST(i_aluop, i_alusel, i_re1, i_reg1_addr, i_re2, i_reg2_addr, i_we, i_waddr, i_imm, i_inst_valid) if(1) begin \\ aluop_o &lt;= i_aluop ; \\ alusel_o &lt;= i_alusel ; \\ reg1_re_o &lt;= i_re1 ; \\ reg1_addr_o &lt;= i_reg1_addr ; \\ reg2_re_o &lt;= i_re2 ; \\ reg2_addr_o &lt;= i_reg2_addr ; \\ we_o &lt;= i_we ; \\ waddr_o &lt;= i_waddr ; \\ imm &lt;= i_imm ; \\ inst_valid &lt;= i_inst_valid ; \\end else if(0) 便可以很好的简化后续的赋值操作，这里使用了一个继承自C语言的梗do ... while(0)或者if(1) ... else if(0)。verilog中可使用后者。这样定义便可以像函数一样调用，后面就可以加上;。 内存分块在data_ram模块的实现中，因为需要进行字节操作，如果只定义一个一维的内存的话，实现起来会不方便。所以可以分块定义为四个块，每个地址的字就是将四个块中对应地址的字节组合起来。 1234reg [`ByteWidth] bank0 [0:`DataMemNum-1];reg [`ByteWidth] bank1 [0:`DataMemNum-1];reg [`ByteWidth] bank2 [0:`DataMemNum-1];reg [`ByteWidth] bank3 [0:`DataMemNum-1]; $dumpvars使用系统任务$dumpvars导出变量到波形。调用：$dumpvars(level, module1, module2, ...)，level为指定的模块向下的模块层次。也可以单独指定某一个信号，模块可以是某一模块的子模块。使用系统任务$dumpfile将波形导出到vcd文件。调用：$dumpfile(&quot;test.vcd&quot;) wire &amp; reg这是verilog基础，wire型只能使用assign进行连续性赋值，reg型只能在过程快中使用=或者&lt;=进行赋值，多用&lt;=非阻塞性赋值，不需要阻塞。并且多次使用&lt;=赋值以最后一个为准，这在高级语言中是不言自明的，但是&lt;=是非阻塞性赋值，是并行对所有信号线赋值的，所以这个需要注意。 输出一般情况下使用reg，某些信号也可以使用wire，输入均使用wire。定义存储器均使用reg。 input &amp; output输入输出信号声明可以是在模块的端口列表中，也可以是在模块内部，我使用的全部是在端口列表中声明。缺省类型wire。 123456789module data_ram ( input wire clk , input wire ce , input wire we , input wire [ 3:0 ] sel , input wire [`DataAddrBus] addr , input wire [`DataBus ] data_i , output reg [`DataBus ] data_o ); $signed使用$signed()将无符号数转换为有符号数，而无需自己通过检测最高位来判断有符号数的正负，这在有符号数加减法需要检测溢出时非常方便。ex.v中加减法以及置位指令实现片段：123456789case (aluop_i) `EXE_SLT_OP : arith_res &lt;= $signed(opv1_i) &lt; $signed(opv2_i); `EXE_SLTU_OP : arith_res &lt;= opv1_i &lt; opv2_i; `EXE_ADD_OP : arith_res &lt;= $signed(opv1_i) + $signed(opv2_i); `EXE_ADDU_OP : arith_res &lt;= opv1_i + opv2_i; `EXE_ADDI_OP : arith_res &lt;= $signed(opv1_i) + $signed(opv2_i); `EXE_ADDIU_OP : arith_res &lt;= opv1_i + opv2_i; `EXE_SUB_OP : arith_res &lt;= $signed(opv1_i) - $signed(opv2_i); `EXE_SUBU_OP : arith_res &lt;= opv1_i - opv2_i; 内建的 / &amp; *乘法和除法指令实现时为了方便我采用的是内建的/和*，这样乘法和除法均在一周期内完成，这样效率并不高。作者并没有这样实现，想查看细节可以参考：自己动手写CPU之第七阶段（9）——除法指令说明及实现思路。 溢出检测某些算术运算指令不检测溢出，但是某些需要。所以需要一个一位信号来保存。ex.v中：12wire sum_overflow = ($signed(opv1_i) &gt; 0 &amp;&amp; $signed(opv2_i) &gt; 0 &amp;&amp; $signed(arith_res) &lt; 0 || $signed(opv1_i) &lt; 0 &amp;&amp; $signed(opv2_i) &lt; 0 &amp;&amp; $signed(arith_res) &gt; 0); 初始化对存储器的初始化放在initial中一次性完成，initial是不可综合的，所以我编写时是将指令存储器的初始化放在了test bench中的。但最后综合出来其实没有太大意义，所以我没有做这一步，也不知道能否通过综合，就语法上来说应该是可以的。 初始化采用$readmemh任务读取，$readmemh任务采用16进制读取，要求输入文件每一行为8位16进制数，读取到存储单元的连续32bit中。 PC程序计数器模块是这样编写的：12345678910111213141516171819202122232425262728`include \"const.v\"module pc_reg ( input wire clk , input wire rst , input wire [`StallBus ] stall , input wire branch_flag_i , input wire [`RegBus ] branch_addr_i , output reg [`InstAddrBus] pc , output reg ce // chip enable to inst_rom); always @(posedge clk) begin if(rst == `RESET_ENABLE) begin ce &lt;= `CHIP_DISABLE; end else begin ce &lt;= `CHIP_ENABLE; end end always @(posedge clk) begin if(ce == `CHIP_DISABLE) begin pc &lt;= 0; end else if (stall[0] == `NOSTOP) begin // the pipeline do not stop if(branch_flag_i == `BRANCH) // branch pc &lt;= branch_addr_i; else pc &lt;= pc + 4; end endendmodule 可以看到这里在复位信号从有效变为无效后，需要最多两个周期，即下下个时钟周期上升沿来临之后，才会输出有效的PC信号，进行指令的读取。 regfile寄存器堆中读取是组合逻辑电路，而写入是时序逻辑电路。为了防止错误，必须这样做。因为如果读取和写入的是一个寄存器，我们必须先读取后写入。而如果都是组合逻辑，那么在上升沿来临之前，最后读取的寄存器值就会变成刚写入的结果。 regfile读写端口操作：1234567891011121314151617181920212223//write port operationalways @(posedge clk) begin if(rst == `RESET_DISABLE) begin if((we == `READ_ENABLE) &amp;&amp; (waddr != `RegNumLog2'h0)) begin regs[waddr] &lt;= wdata; end endend//read port 1 operationalways @(*) begin if(rst == `RESET_ENABLE) begin rdata1 &lt;= `ZERO_WORD; end else if(raddr1 == `RegNumLog2'h0) begin rdata1 &lt;= `ZERO_WORD; end else if((raddr1 == waddr) &amp;&amp; (we == `WRITE_ENABLE) &amp;&amp; (re1 == `READ_ENABLE)) begin rdata1 &lt;= wdata; // handle data-dependant hazard about instruction away from two inst end else if(re1 == `READ_ENABLE) begin rdata1 &lt;= regs[raddr1]; // read data end else begin rdata1 &lt;= `ZERO_WORD; endend 自动测试项目的test目录下是对每一个功能的自动测试。在汇编器没有做任何优化时（使用.set noreorder指示不要对指令重新排序），一段汇编的执行在任何一个时刻的CPU内部状态（包括PC、寄存器值、堆栈等）在仿真环境中都是可预测的。所以可以在test bench中对其进行断言，并输出是否通过测试的信息。 文件assert.v定义了几个相关宏：12345678910111213141516`ifndef ASSERT_V`define ASSERT_V`define ASSERT(x) if(1) begin \\ if (!(x)) begin \\ $display(\"\\033[91;1m[%s:%0d] ASSERTION FAILURE: %s\\033[0m\", `__FILE__, `__LINE__, `\"x`\"); \\ $finish_and_return(1); \\ end \\end else if(0)`define PASS(test) #2 if(1) begin $display(\"\\033[92;1m%s -&gt; PASS\\033[0m\", `\"test`\"); $finish; end else if(0)`define AR(id, expected) `ASSERT(open_mips_min_sopc0.openmips0.regfile1.regs[id] === expected) // generic register assertion`define AHI(expected) `ASSERT(open_mips_min_sopc0.openmips0.hilo_reg0.hi_o === expected) // register HI assertion`define ALO(expected) `ASSERT(open_mips_min_sopc0.openmips0.hilo_reg0.lo_o === expected) // register LO assertion`endif 这里只需要对使用了的通用寄存器、HI、LO进行断言判断是否正确按照预期执行就OK了。 run test上面的都编写完之后，可以写一个makefile来一键运行所有测试。但是我的开发环境是windows，用不了make，虚拟机体验又不太好。所以写了一个shell脚本来替代一下，windows下（需要一个Bash，Git Bash就很好）和linux下都能运行。 有兴趣clone下来运行一下的话可以执行如下命令： 123git clone https://github.com/aojueliuyun/toy_cpu ./toy_cpucd ./toy_cpu/test./runtest.sh -t 依赖：Git，Icarus verilog，Gtkwave reference[1] 雷思磊.自己动手写CPU[M].电子工业出版社,2014.[2] 戴维 A.帕特森 (David A.Patterson),约翰 L.亨尼斯 (John L.Hennessy).计算机组成与设计(原书第5版)[M].机械工业出版社,2017.","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://aojueliuyun.github.io/categories/计算机科学/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"http://aojueliuyun.github.io/tags/CPU/"},{"name":"verilog","slug":"verilog","permalink":"http://aojueliuyun.github.io/tags/verilog/"}]},{"title":"【write a toy cpu】环境搭建","slug":"2018.4.30--write-a-toy-cpu--environment","date":"2018-04-29T16:00:00.000Z","updated":"2018-05-20T07:06:29.421Z","comments":true,"path":"2018/04/30/2018.4.30--write-a-toy-cpu--environment/","link":"","permalink":"http://aojueliuyun.github.io/2018/04/30/2018.4.30--write-a-toy-cpu--environment/","excerpt":"这篇搭建开发环境，下一篇稍微详述实现过程。这两篇来源于看《自己动手写CPU》（作者博客）时写代码顺带写的笔记。这是一本非常棒的介绍cpu工作原理并且实践性很强的入门书籍，看完之后对CPU内部构造、MIPS指令集、流水线设计、Verilog编程都有了一定的了解。这本书倾向于实践，涉及到的理论部分的内容基本上仅限于《计算机组成与设计：硬件/软件接口》的第三章。开始看这本书的起因是偶然在github上浏览到一个有趣的项目——abcdabcd987/toy-cpu，点进去看了之后，发现语言是verilog，仅十余个源文件，然后想自己也学过verilog，但都没写过电路。了解之后发现这个项目参考自《自己动手写CPU》这本书，然后知乎上逛了一圈，有人说《CPU自制入门》更好一些，然后屁颠屁颠买了之后。发现并不是很能看懂，而且全书有很大一部分是在讲如何制作印制电路板和FPGA什么的。看了100页，看不下去，仿真老是通不过，有输入，但是输出全为x，找不到原因，很受挫，于是去图书馆借了《自己动手写CPU》。看了之后觉得，比前面那一本更容易懂一些。这本书实现了MIPS指令集的MIPS32版本的所有整数指令。可以使用GNU的汇编工具将MIPS汇编翻译成机器码，就不用自己设计指令集、手动汇编或者写汇编程序（应该有一定难度）了。这里搭建开发环境、熟悉GNU工具的使用。","text":"这篇搭建开发环境，下一篇稍微详述实现过程。这两篇来源于看《自己动手写CPU》（作者博客）时写代码顺带写的笔记。这是一本非常棒的介绍cpu工作原理并且实践性很强的入门书籍，看完之后对CPU内部构造、MIPS指令集、流水线设计、Verilog编程都有了一定的了解。这本书倾向于实践，涉及到的理论部分的内容基本上仅限于《计算机组成与设计：硬件/软件接口》的第三章。开始看这本书的起因是偶然在github上浏览到一个有趣的项目——abcdabcd987/toy-cpu，点进去看了之后，发现语言是verilog，仅十余个源文件，然后想自己也学过verilog，但都没写过电路。了解之后发现这个项目参考自《自己动手写CPU》这本书，然后知乎上逛了一圈，有人说《CPU自制入门》更好一些，然后屁颠屁颠买了之后。发现并不是很能看懂，而且全书有很大一部分是在讲如何制作印制电路板和FPGA什么的。看了100页，看不下去，仿真老是通不过，有输入，但是输出全为x，找不到原因，很受挫，于是去图书馆借了《自己动手写CPU》。看了之后觉得，比前面那一本更容易懂一些。这本书实现了MIPS指令集的MIPS32版本的所有整数指令。可以使用GNU的汇编工具将MIPS汇编翻译成机器码，就不用自己设计指令集、手动汇编或者写汇编程序（应该有一定难度）了。这里搭建开发环境、熟悉GNU工具的使用。 开发环境搭建Ubuntu虚拟机这里需要用到Linux，我使用的VMware安装的Ubuntu18.04 LTS，虚拟机就不多介绍了，ubuntu直接无脑下一步就OK了。然后安装VMtools（参考），即可在虚拟机与物理机之间进行文字甚至文件拷贝，虚拟机即可以全屏。安装好之后，装一些必备软件以保证ssh连接能顺利进行。12345sudo apt-get updatesudo apt-get install net-toolssudo apt-get install ssh openssh-serversudo apt-get install vimsudo apt-get install lrzsz 先使用ifconfig命令获取ubuntu虚拟机的IP，这里虚拟机的网络连接最好用桥接，并且保证ubuntu网卡处于打开状态，如果没有则切换到root用户使用ifup [网卡名称]命令打开。然后使用XShell建立新连接：输入IP，端口号22，协议SSH，以及ubuntu的用户名和密码，进行远程连接，即可通过rz命令向虚拟机上传文件，sz [file]命令下载文件到本机。也可以通过Xftp建立ssh连接之后直接拖动文件即可完成传输。XShell and Xftp is free for home/school. 官网填写信息，即可免费下载。 GNU工具链这里使用GNU的MIPS工具链，下载文件mips-2013.05-65-mips-sde-elf-i686-pc-linux-gnu.tar.bz2（CSDN下载，我使用的这一个），cp到/opt目录下解压：1tar -xvjf ./mips-2013.05-65-mips-sde-elf-i686-pc-linux-gnu.tar.bz2 cd到/home/username，添加到当前用户的环境变量：用vim编辑隐藏文件.bashrc，在末尾添加一条语句：1export PATH=&quot;$PATH:/opt/mips-2013.05/bin&quot; 使用下列命令使其生效。1source ./.bashrc 然后终端键入mips-sde-elf-，两次TAB自动补全，则对该用户即有下列命令可用。123456mips-sde-elf-addr2line mips-sde-elf-cpp mips-sde-elf-gcc-nm mips-sde-elf-nm mips-sde-elf-readelfmips-sde-elf-ar mips-sde-elf-elfedit mips-sde-elf-gcc-ranlib mips-sde-elf-objcopy mips-sde-elf-runmips-sde-elf-as mips-sde-elf-g++ mips-sde-elf-gcov mips-sde-elf-objdump mips-sde-elf-sizemips-sde-elf-c++ mips-sde-elf-gcc mips-sde-elf-gdb mips-sde-elf-qemu-system mips-sde-elf-spritemips-sde-elf-c++filt mips-sde-elf-gcc-4.7.3 mips-sde-elf-gprof mips-sde-elf-qemu-system-el mips-sde-elf-stringsmips-sde-elf-conv mips-sde-elf-gcc-ar mips-sde-elf-ld mips-sde-elf-ranlib mips-sde-elf-strip 这里只使用其中几个，均以mips-sde-elf-开头。 as：GNU汇编器，通常称GAS(GNU Assembler)，对源程序进行编译产生目标文件。 ld：GNU链接器，将as产生的目标文件进行链接、重定位数据产生可执行文件。 objcopy：用于将一种格式的目标文件复制为另一种格式。 objdump：用于列出二进制文件的各种信息。 readelf：类似于objdump，但只能处理ELF格式文件。 开发工具编辑器：Sublime Text 3安装system verilog插件，语法高亮、关键字自动补全以及自动格式化，写起来非常舒服。并且sublime支持多行编辑以及块选择，这对于经常出现重复代码的verilog开发来说非常棒。关于使用：如何优雅地使用Sublime Text3。ps ：ubuntu下安装后使用命令subl打开。 仿真工具：Icarus Verilog &amp; GTKWave使用细节可参见：Icarus Verilog和GTKwave使用简析命令行环境使用，免费开源跨平台，windows可使用Git Bash，安装之后添加系统path环境变量之后即可使用。亲测平台不同用起来并没有半毛钱差别。Windows平台也可使用Modelsim。ububntu下安装Icarus verilog &amp; Gtkwave：12sudo apt-get install iverilogsudo apt-get install gtkwave 使用iverilog命令编译，-s参数指定顶层模块，-o指定目标文件。 使用vvp [file]对编译好的目标文件进行仿真。 使用gtkwave *.vcd查看波形，vcd文件在编写的test bench中使用verilog的系统任务$dumpfile在仿真过程中产生。 问题及解决问题1：Ubuntu下执行mips-sde-elf-as命令报错：bash: /opt/mips-2013.05/bin/mips-sde-elf-as: 没有那个文件或目录。 解决：这应该是64位的系统不支持32的程序，参考64位Linux（ubuntu）安装、运行32位程序，执行系列命令安装支持32位的程序的二进制库即可解决。123sudo dpkg --add-architecture i386sudo apt-get updatesudo apt-get install zlib1g:i386 libstdc++6:i386 libc6:i386 如果是CentOS的话，则执行1yum install glibc.i686 我也是通过CentOS7执行上述命令时的报错才知道了是这个原因，因为CentOS7的报错是这样的：bash: /opt/mips-2013.05/bin/mips-sde-elf-as: /lib/ld-linux.so.2: bad ELF interpreter: 没有那个文件或目录。然后参考了解决linux安装软件：/lib/ld-linux.so.2: bad ELF interpreter问题，才找到原因，耽误了很长时间。 问题2：执行命令时用户权限不够，不能写入目标文件。 原因：因为上面我们添加的是普通用户的环境变量，所以不能在所有权为root的目录执行操作。以下方法均可解决： 确保工作目录所有者为当前执行用户。 更改工作目录权限，改为777即可。 添加系统环境变量，使所有用户均可使用这一系列命令。 也可以添加root用户环境变量，使用root用户进行操作。但一般情况下，我建议使用普通用户进行操作。root用户一不小心手残rm -rf /*了怎么办（笑而不语）。 问题3：Windows下的脚本文件传输到Linux下运行时，很可能会出现异常/bin/sh^M: bad interpreter: No such file or directory。 原因：DOS/Windows和Linux/Unix的文件换行回车格式不同，基于 DOS/Windows 的文本文件在每一行末尾有一个 CR（回车）和 LF（换行），而 UNIX 文本只有一个换行。 解决：vim打开编辑，底行模式:set ff查看文件编码格式，结果为dos或者unix，然后:set ff=unix转换为unix编码格式即可在linux环境下执行。更详细信息参见：批量将目录下所有文件进行 dos/unix 格式转换。 GNU工具的使用首先创建一个MIPS汇编源文件inst_rom.s，因为第一条实现的指令是ori，其实这就是第一条指令实现之后的test case。12345678 .org 0x0 # 指示地址从0x0开始 .global _start # 定义一个全局符号 _start .set noat # 允许自由使用寄存器$1_start: ori $1,$0,0x1100 ori $2,$0,0x0020 ori $3,$0,0xff00 ori $4,$0,0xffff 手动人脑编译后四条指令得到16进制机器码的文本格式。后面我们使用verilog的$readmemh任务读取指令的文本文件，所以后面需要写一个程序将编译好的二进制文件转换为表示16进制机器码的字符文本文件。123434011100340200203403ff003404ffff 编译这里给出命令，细节比较复杂，但只需要执行这两条命令就行了。详解见作者博客：自己动手写CPU之第四阶段（3）——MIPS编译环境的建立1mips-sde-elf-as -mips32 inst_rom.s -o inst_rom.o 得到的inst_rom.o是一个ELF文件，需要链接才可以成为可执行文件。 链接创建链接描述脚本文件ram.ld1234567891011121314151617181920212223MEMORY&#123; ram : ORIGIN = 0x00000000, LENGTH = 0x00001000 &#125;SECTIONS &#123; .text : &#123; *(.text) &#125; &gt; ram .data : &#123; *(.data) &#125; &gt; ram .bss : &#123; *(.data) &#125; &gt; ram&#125;ENTRY (_start) 然后使用mips-sde-elf-ld进行链接1mips-sde-elf-ld -T ram.ld inst_rom.o -o inst_rom.om 得到的inst_rom.om是可执行文件，但并不能执行。因为指令集不同。 转换为二进制形式然后使用mips-sde-elf-objcopy将将其转换为二进制形式。1mips-sde-elf-objcopy -O binary inst_rom.om inst_rom.bin 用notepad++安装hex-editer插件，使用16进制格式查看，可以看到与人肉汇编出来的一模一样。 进一步完善将二进制文件转换为16进制文本文件然后我们需要将其转换为16进制文本文件，以便verilog的任务$readmemh读取。作者提供了一个工具，感觉很简单，所以我自己写了一个。 思路：将二进制按字节（使用char）顺序读入，类型转换为int，输出到目标文件。需要注意所有字节均是两位16进制数。 实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;std::ifstream fin;std::ofstream fout;string source_file_name;string target_file_name;const string default_file_name = \"a.data\";void bin_to_hex_text();void print_err_info(const string &amp; err);int main(int argc, char * argv[])&#123; if(argc == 1) return 0; if(string(argv[1]) == \"-o\") &#123; if(argc &gt; 4) print_err_info(\"arguments is more than ecpected!\"); else if(argc &lt; 4) print_err_info(\"arguments is less than expected!\"); else &#123; source_file_name = argv[3]; target_file_name = argv[2]; &#125; &#125; else &#123; if(argc &gt; 2) print_err_info(\"arguments is more than ecpected!\"); else if(argc &lt; 2) print_err_info(\"arguments is less than expected!\"); else &#123; source_file_name = argv[1]; target_file_name = default_file_name; &#125; &#125; bin_to_hex_text(); return 0;&#125;void print_err_info(const string &amp; err)&#123; cout &lt;&lt; '\\n'&lt;&lt; err &lt;&lt; \"\\nThere just two types of commands are available:\\n\\n command -o target_file_name source_file_name\\n\"; cout &lt;&lt; \" command source_file_name \\n\\nin the second case, the target file name is \" &lt;&lt; default_file_name &lt;&lt; \" which is default\\n\"; cout &lt;&lt; \"please check out and retype.\\n\"; exit(-1);&#125;void bin_to_hex_text()&#123; fin.open(source_file_name); if(!fin) &#123; cout &lt;&lt; \"failed to open source file \" &lt;&lt; source_file_name &lt;&lt; endl;; exit(-1); &#125; fout.open(target_file_name); if(!fout) &#123; cout &lt;&lt; \"failed to create target file \" &lt;&lt; source_file_name &lt;&lt; endl; exit(-1); &#125; fout &lt;&lt; hex; // 十六进制形式输出 char ch; int count = 0; while(fin.get(ch)) &#123; count ++; int value = static_cast&lt;unsigned char&gt;(ch); // cout &lt;&lt; value &lt;&lt; endl; if(value &lt; 0x10) fout &lt;&lt; '0'; fout &lt;&lt; value; if(count % 4 == 0) // 4个字节，32位，一条指令 fout &lt;&lt; '\\n'; &#125; fin.close(); fout.close();&#125; 上述程序支持一个-o选项来指定目标文件，但对文件顺序有要求，源文件一定要在命令的最后。顺便写了一些报错信息。 值得注意的是：一定要用get()读取，不然可能会忽略空白符出现错误，但是get只支持char类型而不支持unsigned char，而char默认是有符号的，所以如果直接将char类型转换为int的话会对负数进行符号扩展。也就是说将值为0xff的char转换为int后就变成了0xffffffff，那么最后就会出错。这取决于被转换的数，所以要先将其类型转换为unsigned char再转换为int。 保存上述cpp文件为bin2mem.cpp，编译并对上面得到的inst_rom.bin进行转换。12g++ -o bin2mem ./bin2mem.cpp./bin2mem -o inst_rom.data inst_rom.bin 得到inst_rom.data，cat一下：12345$ cat inst_rom.data34011100340200203403ff003404ffff 可以看到与人肉汇编的结果一致。至此工具链就闭合了。开发测试环境就算搭建好了。 Makefile编写上面的工作完成后，我们可以编写makefile来简化所有这些工作。1234567891011121314151617181920212223242526272829ifndef cross_compilecross_compile = mips-sde-elf-endifCC = $(cross_compile)asLD = $(cross_compile)ldOBJCOPY = $(cross_compile)objcopyOBJDUMP = $(cross_compile)objdumpOBJECTS = inst_rom.o## compile rulesall: inst_rom.data%.o: %.s $(CC) -mips32 $&lt; -o $@inst_rom.om: ram.ld $(OBJECTS) $(LD) -T ram.ld $(OBJECTS) -o $@inst_rom.bin: inst_rom.om $(OBJCOPY) -O binary $&lt; $@inst_rom.data: inst_rom.bin ./bin2mem -o $@ $&lt;clean: rm -f *.o *.om *.bin *.data 上述代码保存为文件Makefile,可以看到上面所有命令都囊括其中了，如果没有安装make，则需要先安装make：1sudo apt-get install make 然后执行make all则可一个命令完成上面所有操作。执行之前，我们需要将上面的bin2mem.cpp编译得到的可执行文件bin2mem，以及链接脚本文件ram.ld，以及汇编源文件inst_rom.s，以及Makefile放在同一目录下。make clean即可清理所有生成文件。 反汇编我们可以使用下列命令对可执行文件inst_rom.om进行反汇编。1mips-sde-elf-objdump -D inst_rom.om &gt; inst_rom.asm 得到asm汇编文件内容如下：123456789101112131415inst_rom.om: file format elf32-tradbigmipsDisassembly of section .text:00000000 &lt;_start&gt;: 0: 34011100 li at,0x1100 4: 34020020 li v0,0x20 8: 3403ff00 li v1,0xff00 c: 3404ffff li a0,0xffffDisassembly of section .reginfo:00000000 &lt;.reginfo&gt;: 0: 0000001e 0x1e ... 可以看到其中的指令为li其实就是ori，可以看到反汇编结果与汇编源程序inst_rom.s是一致的。 结语环境搭建是开发的基础，其中也有很多坑，第一次用ubuntu很多不熟悉，很多很简单的问题都被坑。从来没有正经的折腾过一个linux的发行版，虽然装过很多发行版，都是虚拟机装一下，装个GCC写个helloworld，体验一下GUI，然后就不知道干什么了。什么时候有空好好折腾折腾，把linux kernel好好了解一下。话说命令行真好玩，make真方便。 reference[1] 雷思磊.自己动手写CPU[M].电子工业出版社,2014.","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://aojueliuyun.github.io/categories/计算机科学/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://aojueliuyun.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://aojueliuyun.github.io/tags/Ubuntu/"},{"name":"CPU","slug":"CPU","permalink":"http://aojueliuyun.github.io/tags/CPU/"}]},{"title":"Brainfuck","slug":"2018.4.24--brainfuck","date":"2018-04-23T16:00:00.000Z","updated":"2018-05-02T00:33:43.556Z","comments":true,"path":"2018/04/24/2018.4.24--brainfuck/","link":"","permalink":"http://aojueliuyun.github.io/2018/04/24/2018.4.24--brainfuck/","excerpt":"brainfuckBrainfuck 是一门非常简单甚至可以说是最简单的编程语言，wikipedia。 它的语法由一个8个字符的字符集组成，即&gt;&lt;+=.,[]八个字符。brainfuck的模型还包括一个以字节为单位、被初始化为零的数组、一个指向该数组的指针（初始时指向数组的第一个字节）、以及用于输入输出的两个字节流。这八个字符每一个都是一条指令：12345678&gt; 指针加一&lt; 指针减一+ 指针指向的字节的值加一- 指针指向的字节的值减一. 按ASCII码输出指针指向字节内容, 按ASCII码输入内容到指针指向字节[ 如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处] 如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处","text":"brainfuckBrainfuck 是一门非常简单甚至可以说是最简单的编程语言，wikipedia。 它的语法由一个8个字符的字符集组成，即&gt;&lt;+=.,[]八个字符。brainfuck的模型还包括一个以字节为单位、被初始化为零的数组、一个指向该数组的指针（初始时指向数组的第一个字节）、以及用于输入输出的两个字节流。这八个字符每一个都是一条指令：12345678&gt; 指针加一&lt; 指针减一+ 指针指向的字节的值加一- 指针指向的字节的值减一. 按ASCII码输出指针指向字节内容, 按ASCII码输入内容到指针指向字节[ 如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处] 如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处 brainfuck 是图灵完备的，你可以用它来实现你想实现的任何功能。brainfuck的hello world程序：12++++++++[&gt;++++[&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;+&gt;+&gt;-&gt;&gt;+[&lt;]&lt;-]&gt;&gt;.&gt;---.+++++++..+++.&gt;&gt;.&lt;-.&lt;.+++.------.--------.&gt;&gt;+.&gt;++. 而从上面的语法来看，我们可以将其完全地等效为对应的C语言。 translate to C基于上述语法等效我们可以来写一个brainfuck to C的解释器。其实就是读取字符处理就OK了，一个switch...case不能更简单。再简单处理一下对齐，保持良好的可读性（然而这并不会使我们更容易理解brainfuck编译出来的c程序）。实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// brianfuck to C#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;const int max_box_size = 3000;ifstream fin;ofstream fout;void translate_to_c(const char * file_name);void retract(int n);int main(int argc, char const *argv[])&#123; for (int i = 1; i &lt; argc; ++i) &#123; translate_to_c(argv[i]); &#125; return 0;&#125;void translate_to_c(const char * file_name)&#123; fin.open(file_name); string target_file_name = file_name; target_file_name += \".c\"; fout.open(target_file_name); fout &lt;&lt; \"// file_name : \" &lt;&lt; target_file_name &lt;&lt; endl; fout &lt;&lt; \"// This file is a c soucrce file interpreted from brainfuck souce file \" &lt;&lt; file_name &lt;&lt; \".\\n\"; fout &lt;&lt; \"#include &lt;stdio.h&gt;\\n\" &lt;&lt; \"#define max_box_size \" &lt;&lt; max_box_size &lt;&lt; endl; fout &lt;&lt; \"char box[max_box_size];\\n\"; fout &lt;&lt; \"char *ptr = box;\\n\"; fout &lt;&lt; \"int main()\\n&#123;\\n\"; char ch; int retract_num = 1; while(fin.get(ch)) &#123; switch(ch) &#123; case '&gt;': retract(retract_num); fout &lt;&lt; \"++ptr;\\n\"; break; case '&lt;': retract(retract_num); fout &lt;&lt; \"--ptr;\\n\"; break; case '+': retract(retract_num); fout &lt;&lt; \"++*ptr;\\n\"; break; case '-': retract(retract_num); fout &lt;&lt; \"--*ptr;\\n\"; break; case '.': retract(retract_num); fout &lt;&lt; \"putchar(*ptr);\\n\"; break; case ',': retract(retract_num); fout &lt;&lt; \"*ptr=getchar();\\n\"; break; case '[': retract(retract_num++); fout &lt;&lt; \"while (*ptr) &#123;\\n\"; break; case ']': retract(--retract_num); fout &lt;&lt; \"&#125;\\n\"; break; &#125; &#125; fout &lt;&lt; \"\\n return 0;\" &lt;&lt; endl; fout &lt;&lt; \"&#125;\\n\"; fin.close(); fout.close();&#125;void retract(int n)&#123; for(int i=0;i&lt;n;i++) fout &lt;&lt; ' ';&#125; 编译运行上述cpp程序，得到可执行文件，命令行环境下将待解释的brainfuck文件作为参数，执行命令便可得到对应的C程序。保存上述文件为bftoc.cpp，helloworld存为hello.bf。 g++ -o bftoc bftoc.cpp ./bftoc hello.bf gcc -o hello.out hello.bf.c ./hello.out hello world! 一个在线的brainfuck可视化执行工具：brainfuck-visualizer","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://aojueliuyun.github.io/categories/计算机科学/"}],"tags":[{"name":"Programming language","slug":"Programming-language","permalink":"http://aojueliuyun.github.io/tags/Programming-language/"},{"name":"Interesting stuff","slug":"Interesting-stuff","permalink":"http://aojueliuyun.github.io/tags/Interesting-stuff/"}]},{"title":"写一个简单的C++控制台游戏——扫雷","slug":"2018.4.5--C++-console-game-MineSweeper","date":"2018-04-04T16:00:00.000Z","updated":"2018-04-17T05:05:07.433Z","comments":true,"path":"2018/04/05/2018.4.5--C++-console-game-MineSweeper/","link":"","permalink":"http://aojueliuyun.github.io/2018/04/05/2018.4.5--C++-console-game-MineSweeper/","excerpt":"扫雷 MineSweeper用过Windows XP的用户一定不会忘记那一款有趣、烧脑(maybe)的扫雷游戏。（反正我是没有怎么玩过）这里将用C++控制台程序简单实现这个挖雷游戏。下面应该是Win7的挖雷，就是这个画风：","text":"扫雷 MineSweeper用过Windows XP的用户一定不会忘记那一款有趣、烧脑(maybe)的扫雷游戏。（反正我是没有怎么玩过）这里将用C++控制台程序简单实现这个挖雷游戏。下面应该是Win7的挖雷，就是这个画风： 首先，我们分析一下这个游戏： 地图由正方形小方块组成的矩形，每个小方块内要么有雷，要么没有雷 随意点击一个方块开始，如果有雷，爆炸了，则游戏结束，没有爆炸则继续 没有爆炸的方块会显示出以它为中心的九宫格内的雷的数量，为空则表示没有 一次点击后，如果没有爆炸，且周围有雷，则不会显示出多余方块，如果周围没有雷，则会显示出周围所有没有雷的方块，并且显示出数字的方块会作为边界 为什么要这样呢？因为为空白的话，可以直接将周围剩余8个方块依次点击出来（都没有雷），所以电脑帮我们做了这一步，让我们进行接下来的分析 可以看到，上面的过程中最重要的就是：点击的块周围没有雷时，显示出整个可以确定没有雷的一块区域和边界。这很显然要用到广度优先搜索，用队列实现，并不复杂。 实现效果图： 因为是纯粹的C++控制台游戏，所以输入坐标进行挖雷。游戏逻辑就是：每一次接受输入，然后挖雷，刷新地图上所有位置的状态，清屏，输出，挖到雷就结束。雷的数量作为输入，自己设置。然后程序随机生成雷的位置。 实现IDE：VS 2017 Community 文件结构123456game-MineSweeper||----block.h //block类以及Map类的声明|----stdafx.h //VS必须有这个头文件，VS会自动生成三个，其余略|----block.cpp //Map类的方法实现|____game-MineSweeper.cpp //主函数，逻辑主体 block.h——block 和 Map 类定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 2018.4.5 In XDU // block class and Map class definition// IDE: VS 2017 Community#pragma once#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using std::cout;using std::cin;using std::endl;using std::queue;using std::pair;const int max_X = 20; //也可以将block改造为模板类，将这两个参数作为模板参数传入接口const int max_Y = 20; //如果要实现输入控制地图大小，可在堆上分配数组，作为参数传入构造函数，一维数组模拟二维数组即可const int offset_X = 5; //打印地图时相对纵轴偏移量，下为横轴const int offset_Y = 3;template&lt;typename T&gt;T max(T a, T b)&#123; return a &gt; b ? a : b;&#125;template&lt;typename T&gt;T min(T a, T b)&#123; return a &lt; b ? a : b;&#125;struct block&#123; bool has_mine; //是否有雷 int mine_around_num; //周围的雷的数量 bool digged; //是否已经被挖开，挖开有雷则直接返回，没有则显示周围的雷的数量&#125;;class Map&#123;private: block Cube[max_X][max_Y];public: //传入雷的数量，将Cube初始化 Map(int n); //应该要采用广度优先搜索，将所有位置显示出来，挖到雷返回false bool dig(int x, int y); //打印地图，若碰到有雷炸了的情况，最后由下一个函数清屏打印最终结果 void print(); //雷挖炸了之后，将所有位置情况打印出来 void print_end();&#125;; block.cpp——Map的成员函数实现 其中广搜很容易实现。print函数很多都是处理输出格式的内容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include \"stdafx.h\"#include \"block.h\"////传入雷的数量，对其进行初始化Map::Map(int n)&#123; memset(Cube, 0, sizeof(Cube)); srand(time(0)); //随机数种子 for (int i = 0; i &lt; n; i++) //随机埋上n个雷 &#123; int x = rand() % max_X; int y = rand() % max_Y; Cube[x][y].has_mine = true; //cout &lt;&lt; \"(\" &lt;&lt; x &lt;&lt; \",\" &lt;&lt; y &lt;&lt; \")\" &lt;&lt; endl; &#125; for (int i = 0; i &lt; max_X; i++) //对地图进行初始化 for (int j = 0; j &lt; max_Y; j++) for (int x = max(i - 1, 0); x &lt;= min(i + 1, max_X - 1); x++) for (int y = max(j - 1, 0); y &lt;= min(j + 1, max_Y - 1); y++) if (Cube[x][y].has_mine) Cube[i][j].mine_around_num++;&#125;//应该要采用广度优先搜索，将所有位置显示出来，挖到雷返回falsebool Map::dig(int x, int y)&#123; Cube[x][y].digged = true; if (Cube[x][y].has_mine) return false; else &#123; if (Cube[x][y].mine_around_num != 0) return true; else &#123; queue&lt;pair&lt;int, int&gt;&gt; Q; //采用队列进行广度优先搜索 Q.push(&#123; x,y &#125;); while (!Q.empty()) &#123; int curx = Q.front().first; //最初挖出来的位置入队 int cury = Q.front().second; Q.pop(); for (int i = 1; i &lt;= 4; i++) //表示方向，1~4分别为上下左右 &#123; int tmpx = curx; int tmpy = cury; switch (i) //不会出现default的情况 &#123; case 1: tmpx = max(curx - 1, 0); break; case 2: tmpx = min(curx + 1, max_X - 1); break; case 3: tmpy = max(cury - 1, 0); break; case 4: tmpy = min(cury + 1, max_Y - 1); break; &#125; if (!Cube[tmpx][tmpy].digged &amp;&amp; !Cube[tmpx][tmpy].has_mine) //没有被dig且没有雷且周围没有雷则入队 &#123; if (Cube[tmpx][tmpy].mine_around_num == 0) //挖出来的区域的中间位置，即周围没有雷的位置 &#123; Q.push(&#123; tmpx,tmpy &#125;); Cube[tmpx][tmpy].digged = true; &#125; else Cube[tmpx][tmpy].digged = true; //被挖出来区域的边界，周围有雷，置其状态但不入队 &#125; &#125; &#125; &#125; cout &lt;&lt; endl; return true; &#125;&#125;//打印地图，若碰到有雷炸了的情况，直接返回false，由下一个函数清屏打印最终结果void Map::print()&#123; for (int oy = 0; oy &lt; offset_Y; oy++) cout &lt;&lt; endl; for (int ox = 0; ox &lt; offset_X + 2 + max_X / 2; ox++) cout &lt;&lt; \" \"; cout &lt;&lt; \"Y\" &lt;&lt; endl; cout &lt;&lt; \" \"; for (int oy = 0; oy &lt; offset_X + 1; oy++) cout &lt;&lt; \" \"; for (int ox = 0; ox &lt; max_Y; ox++) &#123; cout &lt;&lt; ox; if (ox &lt; 10) cout &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //以上均为控制横向偏移 for (int i = 0; i &lt; max_X; i++) &#123; for (int ox = 0; ox &lt; offset_X; ox++) cout &lt;&lt; \" \"; if (i == (max_Y) / 2) cout &lt;&lt; \"X\"; else cout &lt;&lt; \" \"; if (i &lt; 10) cout &lt;&lt; \" \"; cout &lt;&lt; i; //以上为纵向偏移控制 for (int j = 0; j &lt; max_Y; j++) &#123; if (!Cube[i][j].digged) //没有被挖 cout &lt;&lt; \"■\"; else if (Cube[i][j].has_mine) //被挖了且有雷 cout &lt;&lt; \"×\"; else if (Cube[i][j].mine_around_num != 0) //被挖了且没有雷且周围有雷 cout &lt;&lt; \" \" &lt;&lt; Cube[i][j].mine_around_num; else cout &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125;&#125;//雷挖炸了之后，将所有位置情况打印出来，也可以选择只用print()打印出踩中的位置void Map::print_end()&#123; for (int oy = 0; oy &lt; offset_Y; oy++) cout &lt;&lt; endl; for (int ox = 0; ox &lt; offset_X + 2 + max_X / 2; ox++) cout &lt;&lt; \" \"; cout &lt;&lt; \"Y\" &lt;&lt; endl; cout &lt;&lt; \" \"; for (int oy = 0; oy &lt; offset_X + 1; oy++) cout &lt;&lt; \" \"; for (int ox = 0; ox &lt; max_Y; ox++) &#123; cout &lt;&lt; ox; if (ox &lt; 10) cout &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //以上均为控制横向偏移 for (int i = 0; i &lt; max_X; i++) &#123; for (int ox = 0; ox &lt; offset_X; ox++) cout &lt;&lt; \" \"; if (i == (max_Y) / 2) cout &lt;&lt; \"X\"; else cout &lt;&lt; \" \"; if (i &lt; 10) cout &lt;&lt; \" \"; cout &lt;&lt; i; //以上为纵向偏移控制 for (int j = 0; j &lt; max_Y; j++) &#123; if (Cube[i][j].has_mine) //有雷 cout &lt;&lt; \"×\"; else if (Cube[i][j].mine_around_num != 0) //没有雷且周围有雷 cout &lt;&lt; \" \" &lt;&lt; Cube[i][j].mine_around_num; else cout &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125;&#125; game-MIneSweeper.cpp——主函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 2018.4.5 In XDU // MineSwepper, classic game in Windows XP, a simple implementation with WIN32 console.// IDE: VS 2017 Community// author : Tiko// Github : aojueliuyun// I'm a student , happy to study annd sahre, welcome to communicate with me !#include \"stdafx.h\"#include \"block.h\"int main(void)&#123; int n; cout &lt;&lt; \"一个简单的扫雷游戏，向 Windows XP 的扫雷致敬！\" &lt;&lt; endl; cout &lt;&lt; \"核心算法：广度优先搜索 \" &lt;&lt; endl; cout &lt;&lt; \"默认地图大小：20 * 20 , 可在头文件block.h中修改。\" &lt;&lt; endl; cout &lt;&lt; \"另外横向纵向的偏移量也可在block.h中修改。\" &lt;&lt; endl; cout &lt;&lt; \"规则：\" &lt;&lt; endl &lt;&lt; \"使用■表示未挖开的位置，×表示挖开炸掉了的雷，\" &lt;&lt; endl; cout &lt;&lt; \"数字表示以该格点为中心的九宫格内的雷的数量，空白为没有雷！\" &lt;&lt; endl; cout &lt;&lt; \"玩法：\" &lt;&lt; endl &lt;&lt; \"因为是纯控制台，所以采用做标输入的方式挖雷。\" &lt;&lt; endl; cout &lt;&lt; \"请输入地雷的数量(50左右为宜)：\"; cin &gt;&gt; n; Map mymap(n); int x, y; system(\"cls\"); while (true) //挖炸了之后便不再循环，但其实并不靠这个结束循环 &#123; mymap.print(); cout &lt;&lt; \"\\t 请输入坐标(x,y)，用空格隔开! ps: x为纵，y为横\" &lt;&lt; endl; cout &lt;&lt; \"\\t\\t\\t\"; cin &gt;&gt; x &gt;&gt; y; while (cin.fail() || x&lt;0 || x &gt;= 20 || x &gt;= max_X || y &gt;= max_Y) //读取输入失败或者输入不在指定范围 &#123; system(\"cls\"); mymap.print(); cout &lt;&lt; \"\\t 请输入坐标(x,y)，用空格隔开! ps: x为纵，y为横\" &lt;&lt; endl; cout &lt;&lt; \"\\t\\t输入有误，请重新输入!\" &lt;&lt; endl; cin.clear(); //更改cin状态标示符 cin.ignore(); //清空输入缓冲区 cout &lt;&lt; \"\\t\\t\\t\"; cin &gt;&gt; x &gt;&gt; y; &#125; if (!mymap.dig(x, y)) &#123; system(\"cls\"); mymap.print(); //亦可选择print_end()函数，将所有位置打印出来 cout &lt;&lt; \"\\t\\t你踩中了(\" &lt;&lt; x &lt;&lt; \",\" &lt;&lt; y &lt;&lt; \")\" &lt;&lt; endl; cout &lt;&lt; \"\\t\\t恭喜客官中雷，慢走不送了，您吶！\" &lt;&lt; endl; break; &#125; system(\"cls\"); //清屏，很好用的感觉 &#125; cout &lt;&lt; \"\\t\\t查看所有雷的位置 y/n ? \"; char c; cin.get(); //读取回车 if (cin.get(c) &amp;&amp; c == 'y') &#123; system(\"cls\"); mymap.print_end(); &#125; cout &lt;&lt; \"\\t\\t\"; return 0;&#125; 另外VS中的stdafx.h等文件生成项目时会自行生成，不用VS可以不要应该。 源码：Github，点击直接下载源码。 结语本来想写一个控制台的RPG游戏，有等级、经验、地图、道具、材料、装备、NPC等元素的勇士屠龙然后变成龙的RPG游戏的。但是大概很多个小时之后，发现很多地方的设计有问题。所有暂时搁置，等到先把 Bjarne Stroustrup 大佬的 The C++ programming language 看完了之后再来写。所以今天先写了一个扫雷，大概写了两个小时，调Bug又花了两个小时，然后控制格式逻辑什么的又花了大概两个小时。一天就这么就过去了，其实说到底就是一个广度优先搜索而已。以后要提高效率。 PS：话说hexo博客默认里面的代码块TAB键缩进不是4个空格长度而是8个，与一般的编辑器不一致，就比较尴尬。注释就全部不规整了，难道以后要采用四个空格缩进？而且规范的代码风格是要求用4个空格缩进的，究其原因就是TAB键长度不确定。逼死强迫症系列，还好我只是轻微强迫症，但是如果碰到8个空格长度的情况，缩进层数多了代码就会老长，上面的Map::dig()函数就是这个情况。但空格输入又比较麻烦，但在所有编辑器里面都一致，而且每个空格占一个字符大小，而TAB只占一个。这是程序员圈子里面的无数圣战之一。见知乎：为什么规范的代码缩进通常用soft tab四个空格而不是tab？当然每个人都有自己的主张，各抒己见，保留自己的观点是好的。但在团队开发中，保持一致且良好的代码风格是必须的。目前我认为最好的解决方案：在编辑器中使用TAB，编辑器自动将其替换为4个空格，如果支持的话（VS用户可在Tools-&gt;Options-&gt;Text Editer对每一种语言的缩进进行控制，极端好用）。简洁的书写，严格的对齐。","categories":[{"name":"Toy Programs","slug":"Toy-Programs","permalink":"http://aojueliuyun.github.io/categories/Toy-Programs/"}],"tags":[{"name":"C++ console game","slug":"C-console-game","permalink":"http://aojueliuyun.github.io/tags/C-console-game/"}]},{"title":"高效排序算法——希尔排序、堆排序、归并排序、快速排序","slug":"2018.3.26--efficient-sort-algorithms","date":"2018-03-23T16:00:00.000Z","updated":"2018-04-09T14:12:50.013Z","comments":true,"path":"2018/03/24/2018.3.26--efficient-sort-algorithms/","link":"","permalink":"http://aojueliuyun.github.io/2018/03/24/2018.3.26--efficient-sort-algorithms/","excerpt":"如标题，这里讨论的是基于比较的排序算法中最高效的三种算法和希尔排序。堆排序、归并排序、快速排序的平均时间复杂度均为O(NlogN)。前面有介绍过O(N2)的三种简单排序算法（见三大简单排序算法——插入、选择、冒泡），其中实际表现最好的要属希尔排序。可以证明通过交换相邻元素来进行排序的任何算法都需要O(N2)的平均时间，其中插入排序虽然不是通过交换来排序，但是可以等价为交换的操作，依然是O(N2)。这里讨论的堆排序、归并排序、快速排序均是平均时间复杂度O(NlogN)的算法，实际表现最好的要属快速排序。可以证明O(NlogN)是基于比较的排序算法的时间复杂度下界。所以这三种排序算法都是渐进最优的。最后介绍一下C++的algorithm库中的sort()函数，一般我们自己写的排序算法优化不够时都是达不到这个效率的。还有会对这些算法在大规模数据下的运行时间进行一个简单的测试。","text":"如标题，这里讨论的是基于比较的排序算法中最高效的三种算法和希尔排序。堆排序、归并排序、快速排序的平均时间复杂度均为O(NlogN)。前面有介绍过O(N2)的三种简单排序算法（见三大简单排序算法——插入、选择、冒泡），其中实际表现最好的要属希尔排序。可以证明通过交换相邻元素来进行排序的任何算法都需要O(N2)的平均时间，其中插入排序虽然不是通过交换来排序，但是可以等价为交换的操作，依然是O(N2)。这里讨论的堆排序、归并排序、快速排序均是平均时间复杂度O(NlogN)的算法，实际表现最好的要属快速排序。可以证明O(NlogN)是基于比较的排序算法的时间复杂度下界。所以这三种排序算法都是渐进最优的。最后介绍一下C++的algorithm库中的sort()函数，一般我们自己写的排序算法优化不够时都是达不到这个效率的。还有会对这些算法在大规模数据下的运行时间进行一个简单的测试。 排序算法相关知识逆序：逆序是指数组中具有性质$i&gt;j$但是$A[i]&lt;A[j]$的序偶$(A[i],A[j])$。（升序排列的情况，反之亦然） 排序的过程就是消除逆序的过程。很明显逆序的最大数目为$\\sum _{i=1}^{N-1}i = \\frac{N(N-1)}{2}$，平均情况下逆序数目为最大的一半即${N(N-1)}/{4}$。 很容易看出，通过交换相邻元素一次最多只能消除一个逆序。所以通过交换相邻元素来排序的算法的平均时间复杂度一定为$O(N^2)$。 而要突破$O(N^2)$的时间屏障，就必须在一次交换/操作中消除不止一个逆序。下面的排序算法都有这个特点。 另外如果下列实现中有要交换元素的均调用如下的模板。1234567template&lt;typename T&gt;void swap(T &amp; x , T &amp; y)&#123; T tmp = x; x = y; y = tmp;&#125; 希尔排序希尔排序（Shell sort）是第一批冲破$O(N^2)$时间屏障的算法之一。也称缩小增量排序。上一篇（三大简单排序算法——插入、选择、冒泡）介绍得很详细。这里贴出代码。 123456789101112131415161718//希尔排序，效率惊人void Shell_sort(ElemType A[],int n)&#123; for(int d=n/2; d&gt;0; d/=2) &#123; for(int i=d; i&lt;n; i++) &#123; ElemType tmp = A[i]; int j = i-d; while(j &gt;= 0 &amp;&amp; tmp &lt; A[j]) &#123; A[j+d] = A[j]; j = j-d; &#125; A[j+d] = tmp; &#125; &#125;&#125; 这里的增量序列是$n/2,n/4,…,1$，为最原始的希尔序列。但这并不是高效的增量序列，一个更加高效的增量序列为Hibbard增量，形如$1,3,7,…,2^k-1$（使用时需要从合适的位置逆序），可以证明Hibbard增量的希尔排序最坏情形时间复杂度为$O(N^{3/2})$。希尔排序的算法实现很简单，但是分析却是很困难的。其实还有更好的增量序列，可以参见 Shellsort - Wikipedia - Gap sequences。动图演示（以下动图均来自Wikipedia）： 堆排序heap sort，这个介绍堆时也是介绍的很详细的。见基本数据结构——堆，优先队列 &amp; 堆。实现：12345678910111213141516171819202122232425262728//升序排列、最大堆 void sift_down(ElemType A[],int i,int n)&#123; ElemType tmp; int child; for(tmp = A[i]; 2*i &lt;= n; i = child) &#123; child = 2*i; if(child != n &amp;&amp; A[child+1] &gt; A[child]) child ++; if(tmp &lt; A[child]) A[i] = A[child]; else break; &#125; A[i] = tmp;&#125;//将数组建堆然后排序——升序 void heap_sort(ElemType A[],int n)&#123; for(int i = n/2; i&gt;0; i--) sift_down(A,i,n); for(int i=n; i&gt;1; i--) &#123; swap&lt;ElemType&gt;(A[1],A[i]); sift_down(A,1,i-1); &#125;&#125; 需要注意的是这里堆排序的实现要求给数组多分配一个内存。当然可以将其改为与其他排序一致，这很容易做到，但我个人更偏向于现在这种实现。动图演示： 归并排序归并排序（Merge sort）采用分治策略。思路也很简单：将数组分为两个等长子数组，对两个子数组递归采用归并排序来排序，然后将两个数组合并，其中递归结束条件为子数组长为1直接返回。则时间$T(N) = T(N/2) + N$，由主定理得到时间复杂度为$O(NlogN)$。 实现也很清晰很简单。12345678910111213141516171819202122232425262728293031323334353637void merge_sort(ElemType A[], int n)&#123; ElemType * TmpArr = new ElemType[n]; m_sort(A,TmpArr,0,n-1); delete [] TmpArr;&#125;void m_sort(ElemType A[], ElemType TmpArr[], int left, int right)&#123; if(left &lt; right) &#123; int center = (left + right) / 2; m_sort(A, TmpArr, left, center); m_sort(A, TmpArr, center+1, right); merge(A, TmpArr, left, center+1, right); &#125;&#125;//两个子数组的合并，lpos~rpos-1 and rpos~rightend ,临时存储在TmpArr[rpos~rightend] void merge(ElemType A[], ElemType TmpArr[], int lpos, int rpos, int rightend)&#123; int leftend = rpos - 1; int tmppos = lpos; int begin = lpos; while(lpos &lt;= leftend &amp;&amp; rpos &lt;= rightend) &#123; if(A[lpos] &lt;= A[rpos]) TmpArr[tmppos ++] = A[lpos ++]; else TmpArr[tmppos ++] = A[rpos ++]; //TmpArr[tmppos++] = A[lpos] &lt;= A[rpos] ? A[lpos ++] : A[rpos ++]; &#125; while(lpos &lt;= leftend) TmpArr[tmppos ++] = A[lpos ++]; while(rpos &lt;= rightend) TmpArr[tmppos ++] = A[rpos ++]; for(int i = begin; i &lt;= rightend; i ++) A[i] = TmpArr[i];&#125; 其中动态分配了一个与原数组等长的数组存放那些临时子数组合并之后的数组。这样实现比在每一次递归中都去申请一个数组来存放临时数据要更好。动图演示： 快速排序（Quick sort）真的无心去写。有空再优化。现在没有优化甚至都比不过希尔排序、堆排序和归并排序。当然差std::sort肯定是差远了。 给一个算法导论上的实现：123456789101112131415161718192021222324252627282930313233343536373839//划分int Partition(int A[], int p, int r)&#123; int x = A[r]; int i = p - 1; for (int j = p; j&lt;r; j++) &#123; if (A[j] &lt;= x) &#123; i++; if (i != j) swap(A[i], A[j]); &#125; &#125; swap(A[i + 1], A[r]); return i + 1;&#125;//随机化的划分函数，使主元随机化 int Randomized_Partition(int A[], int p, int r)&#123; int i = rand() % (r - p + 1) + p; //产生p到r的随机数 swap(A[i], A[r]); return Partition(A, p, r);&#125;void Quick_Sort(int A[], int p, int r)&#123; if (p &lt; r) &#123; int q = Randomized_Partition(A, p, r); Quick_Sort(A, p, q - 1); Quick_Sort(A, q + 1, r); &#125;&#125;void quick_sort2(int A[], int n)&#123; Quick_Sort(A, 0, n - 1);&#125; 动图演示： 排序算法的时间下界可以使用决策树模型证明通过比较元素大小实现排序的排序算法的复杂度下界为O(NlogN)。所以快速排序、堆排序、归并排序都是渐进最优的。希尔排序由于增量序列的改变时间界会发生改变，但实际使用效果一般都很理想。并不差前面的三个排序算法多少，某些情况下甚至可能更优一点。 C++ STL sort()函数一般我们自己实现的排序算法在优化不够的情况下都达不到C++的algorithm库中的sort()函数的效率。std::sort的实现采用了快速排序、插入排序、堆排序。并且进行了编译优化。一般是比不过的。 调用方式，可以传入两个参数，或者三个参数。第一个参数为指向初始元素的指针，第二个参数为指向最后一个待排序元素的下一个位置的指针（或者迭代器），第三个元素可选，默认进行升序排序，可以定义一个返回值为bool类型的比较函数。当对结构或者对象进行排序时，重载运算符或者传入一个函数参数都可以实现排序。12std::sort(A,A+n); //对数组A中的n个元素排序std::sort(A.begin(),A.end(),cmp); //对容器A中所有元素按照比较函数cmp()的规则进行排序 简单的时间测试我对上述实现以及以前O(N2)的排序算法进行了一个测试。结果如下： 123456789101112131415161718192021test 1: 1e5 elements，静态分配simple aort algoritms :bubble sort time : 15735msselection sort time : 10665msinsertion sort time : 1095msbinary insertion sort time : 872msefficient sort algorithms :shell sort time : 13msmerge sort time : 15msheap sort time : 8msquick sort time : 9msstl sort function time : 8ms test 2: 1e7 elements, 动态分配efficient sort algorithms :shell sort time : 1985msmerge sort time : 1858msheap sort time : 1816msquick sort time : 2010msstl sort function time : 697ms ps： 测试时请将编译器设置为release模式。不然不开优化std::sort会非常慢。可以看到开启优化之后std::sort是吊打一切的存在。愉快地使用STL吧！ 源码下载。 参考资料：数据结构与算法分析——C语言描述、算法导论","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://aojueliuyun.github.io/tags/排序/"}]},{"title":"优先队列 & 堆","slug":"2018.3.23--priority-queue-&-heap-&-leftist-heap","date":"2018-03-22T16:00:00.000Z","updated":"2018-03-26T15:02:27.948Z","comments":true,"path":"2018/03/23/2018.3.23--priority-queue-&-heap-&-leftist-heap/","link":"","permalink":"http://aojueliuyun.github.io/2018/03/23/2018.3.23--priority-queue-&-heap-&-leftist-heap/","excerpt":"这里讨论堆。通常当我们谈论堆时，我们经常谈论的是二叉堆。但这并不是堆的全部。堆（heap），可以说是树（tree）的一种。参见下图： 图中并不算十分完整，但也基本显示出的树的家族的轮廓。二叉树就不多说了。这次主要讨论二叉堆（binary heap）以及左偏树（leftist tree）。二叉堆是讨论过的（见基本数据结构—堆）。是看算法导论的时候写的（现在依然没有看完~）。那时没有实现优先队列，这里会实现一下。我们知道二叉堆的应用主要就是优先队列和堆排序。之所以称这种树为堆，是因为其满足堆的基本性质——堆序性质，即每个父节点都比它的子节点大/小。 二叉堆一般采用数组实现。而这次另外要讨论的左偏树（也称左式堆）也满足堆序性质，但其实现方式与二叉树是一样的，即采用二叉链存储结构。左式堆除了堆序性质外，注重于堆的合并操作，左偏树/左式堆可以以O(logN)的时间复杂度将两个堆合并。这是普通二叉树与二叉堆所做不到的。因为所有的合并操作均需要用到指针，而二叉树的合并需要O(N)的时间，所以这也是左式堆这种数据结构存在的意义（I guess）。后续的数据结构如斐波那契堆、二项堆等实现之后，可以就相关操作做一个对比。另外左式堆之后有一种堆——斜堆，与左式堆有着密切的关系。斜堆并不携带任何平衡信息，与左式堆的关系就像伸展树之于AVL树。但其实好像并不是特别好用。所以这里就不介绍了。","text":"这里讨论堆。通常当我们谈论堆时，我们经常谈论的是二叉堆。但这并不是堆的全部。堆（heap），可以说是树（tree）的一种。参见下图： 图中并不算十分完整，但也基本显示出的树的家族的轮廓。二叉树就不多说了。这次主要讨论二叉堆（binary heap）以及左偏树（leftist tree）。二叉堆是讨论过的（见基本数据结构—堆）。是看算法导论的时候写的（现在依然没有看完~）。那时没有实现优先队列，这里会实现一下。我们知道二叉堆的应用主要就是优先队列和堆排序。之所以称这种树为堆，是因为其满足堆的基本性质——堆序性质，即每个父节点都比它的子节点大/小。 二叉堆一般采用数组实现。而这次另外要讨论的左偏树（也称左式堆）也满足堆序性质，但其实现方式与二叉树是一样的，即采用二叉链存储结构。左式堆除了堆序性质外，注重于堆的合并操作，左偏树/左式堆可以以O(logN)的时间复杂度将两个堆合并。这是普通二叉树与二叉堆所做不到的。因为所有的合并操作均需要用到指针，而二叉树的合并需要O(N)的时间，所以这也是左式堆这种数据结构存在的意义（I guess）。后续的数据结构如斐波那契堆、二项堆等实现之后，可以就相关操作做一个对比。另外左式堆之后有一种堆——斜堆，与左式堆有着密切的关系。斜堆并不携带任何平衡信息，与左式堆的关系就像伸展树之于AVL树。但其实好像并不是特别好用。所以这里就不介绍了。 优先队列/二叉堆优先队列基本上都是用二叉堆来实现了。优先队列的基本模型如下： 可以看到其基本操作为插入和删除其中优先级最低或者最高的元素（key最小或者最大的）。二叉堆比较简单，这里直接实现。这里构建的是最小堆，即父节点比子节点小的堆。其核心操作为 DeleteMin 和 Insert。12345678910111213141516171819typedef int ElemType;class Min_Heap&#123;private: int capacity; int size; ElemType * Elements;public: Min_Heap(int _capacity); ~Min_Heap(); void Clear(); void Insert(ElemType x); ElemType FindMin(); ElemType DeleteMin(); bool IsEmpty(); bool IsFull(); int Get_Size(); void print();&#125;; 方法实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778Min_Heap::Min_Heap(int _capacity)&#123; capacity = _capacity; size = 0; Elements = new ElemType [capacity+1]; Elements[0] = -1;&#125;Min_Heap::~Min_Heap()&#123; delete Elements;&#125;void Min_Heap::Clear()&#123; size = 0;&#125;void Min_Heap::Insert(ElemType x)&#123; if(IsFull()) &#123; cout &lt;&lt; \"The heap is full, can not insert more elements !\" &lt;&lt; endl; return; &#125; int i; //如果不加i&gt;1这个条件的话，就靠Elements[0]来结束循环，所以Min_data必须小于堆中所有元素 for(i = size+1; Elements[i/2]&gt;x &amp;&amp; i&gt;1; i /= 2) Elements[i] = Elements[i/2]; Elements[i] = x; size ++;&#125;ElemType Min_Heap::FindMin()&#123; if(IsEmpty()) return Elements[0]; return Elements[1];&#125;ElemType Min_Heap::DeleteMin()&#123; if(IsEmpty()) &#123; cout &lt;&lt; \"The heap is empty ! return to Min_data !\" &lt;&lt; endl; return -1; &#125; ElemType Min_element = Elements[1]; ElemType Last_element = Elements[size--];//将最后一个元素从堆中取出来 int i,child; for(i = 1; i*2 &lt;= size; i = child) &#123; child = 2*i; //节点i存在右孩子且右孩子小于左孩子的话，就将右孩子上浮 if(child+1 &lt;= size &amp;&amp; Elements[child+1]&lt;Elements[child]) child ++; //需要判断child与最后一个元素谁填充到节点i if(Last_element &gt; Elements[child]) Elements[i] = Elements[child]; else//找到合适的位置给Last_element插入，则不再上浮 break; &#125; Elements[i] = Last_element; return Min_element;&#125; bool Min_Heap::IsEmpty()&#123; return size == 0;&#125;bool Min_Heap::IsFull()&#123; return size == capacity;&#125;int Min_Heap::Get_Size()&#123; return size;&#125;void Min_Heap::print()&#123; for(int i=1; i&lt;=size; i++) cout &lt;&lt; Elements[i] &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; 其中插入和删除操作中，使用了一个临时变量来存储该节点值，而不是每一次都进行交换，最坏复杂度均为O(logN)。插入中用到了使节点上浮的操作。删除最小值中用到了使节点下沉/下滤的操作。但是可以证明新插入的元素一般不会直接上浮到最顶层，一般会终止的比较早，平均一次插入需要2.607次比较。所以我们可以说插入操作复杂度为O(1)。则从数组建堆时对每一个元素执行插入操作，平均复杂度为O(N)。 堆排序我们知道堆的另一个应用就是堆排序。如果要就上述操作来实现堆排序，则只有依次执行DeleteMin，再将得到的最小值依次输出，则就得到了堆中元素的升序排列。显然这并不是最高效的实现。 还有一种思路，单就为了实现堆排序来说，我们可以将上浮和下沉的操作提取出来，按照如下方式实现堆排序。过程参考代码。网上太多讲解了。堆排序的实现，堆我们可以直接采用数组，而不必将其封装为ADT。实现如下。注意这里所有堆实现为了可读性以及便于操作，下标均从1开始，到n结束，则分配内存需要多分配一个。这里实现的是最大堆。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void Build_max_heap(ElemType A[],int n)&#123; for(int i = n/2; i &gt; 0; i--) sift_down(A,i,n);//建堆，复杂度O(N)&#125;//上浮，优先队列插入元素才会用到，堆排序不会用到void sift_up(ElemType A[],int i,int n)&#123; ElemType tmp; for(tmp = A[i]; i &gt;= 2 &amp;&amp; tmp &gt; A[i/2] ; i /= 2) A[i] = A[i/2]; A[i] = tmp;&#125;//下沉void sift_down(ElemType A[],int i,int n)&#123; ElemType tmp; int child; for(tmp = A[i]; 2*i &lt;= n; i = child) &#123; child = 2*i; if(child != n &amp;&amp; A[child+1] &gt; A[child]) child ++; if(tmp &lt; A[child]) A[i] = A[child]; else break; &#125; A[i] = tmp;&#125;void Heap_Sort(ElemType A[], int n)&#123; for(int i=n/2; i&gt;0; i--) sift_down(A,i,n);//对n=n/2-&gt;1执行sift_down操作即可建堆，顺序不能反过来 for(int i=n; i&gt;1; i--) &#123; swap&lt;ElemType&gt;(A[i],A[1]); sift_down(A,1,i-1);//这里一定这注意最后一个参数为目前堆的size &#125;&#125;template&lt;typename T&gt;void swap(T &amp; x , T &amp; y)&#123; T tmp = x; x = y; y = tmp;&#125; 我们甚至可以调用上述过程来实现优先队列，很容易实现。要说的是，上一篇（基本数据结构—堆）中，堆的实现是不那么高效的，其中sift_down操作采用了递归。能够轻松转化为循环（而不是模拟一个栈去转化）的递归我们应当将其写作循环的形式。尤其是递归层数较多时，写成递归形式很可能会爆栈。 左式堆左式堆（leftist heap），也称左偏树（leftist tree）。注重合并（merge）操作。实现合并操作后，其余操作（Insert、DeleteMin）均可通过合并操作实现。合并操作复杂度为O(logN)，采用递归实现，是递归的强大力量的一个例证。 前面提到过，二叉堆和二叉树的合并操作都无法在短时间实现。其中插入复杂度O(1)的二叉堆将其中一个堆所有元素插入到另一个都需要至少O(N)复杂度。 介绍之前，引入一个概念：树中一个节点X的零路径长（null path length）Npl(X)定义为X到一个没有两个儿子的节点的最短路径长。具有0个或者1个儿子的节点Npl值为0。Npl(NULL)=-1。我们需要将每个节点的Npl值标记在节点中。注意：任意节点的Npl等于其左右孩子的Npl值中最小值加1。 左式堆性质：对于堆中每一个节点X，左儿子NPL大于等于右节点。 节点以及操作定义：12345678910111213141516171819typedef int ElemType;typedef struct LHNode&#123; ElemType element; LHNode * left; LHNode * right; int npl;&#125; * LHeap ; bool IsEmpty(LHeap H);ElemType FindMin(LHeap H);LHeap Merge(LHeap H1, LHeap H2);//合并两个左式堆 LHeap Merge1(LHeap H1,LHeap H2);void Insert(LHeap &amp; H, ElemType x);void DeleteMin(LHeap &amp; H);template &lt;typename T&gt;void Swap(T &amp; x , T &amp; y); //最后两个操作太过简单，就不给了void pre_traverse(LHeap H); 左式堆的最基本最重要的操作是合并。合并操作（以小顶堆为例）： 将两颗左偏树/两个左式堆中根节点值最小的一棵树的根节点作为合并之后的树的根节点（假设为H1，另一颗H2） 将H2与H1的右子树合并（挂在右子树的合适位置），如何找到合适位置呢？递归实现，注意递归终止条件 在上述过程中每次都对节点执行左式堆性质检测，如果不满足，则将其左子树与右子树交换，则一定满足左式堆性质 合并时间复杂度O(logN)，简直可以说是完美的递归操作。后续Insert操作看做与一个节点的树的合并即可。DeleteMin操作删除根节点后，将左右子树合并即可。 操作实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960bool IsEmpty(LHeap H)&#123; return H == NULL;&#125;ElemType FindMin(LHeap H)&#123; if(H == NULL) &#123; cout &lt;&lt; \"The leftist heap is empty , has no min element ! \" &lt;&lt; endl; return 0; &#125; return H-&gt;element;&#125;//合并两个左式堆 LHeap Merge(LHeap H1, LHeap H2)&#123; if(H1 == NULL)//H2与空树合并，则返回H2 return H2; if(H2 == NULL)//H1与空树合并，则结果为H1 return H1; if(H1-&gt;element &lt; H2-&gt;element) return Merge1(H1,H2); else return Merge1(H2,H1); &#125;//递归将H2挂在H1的右子树上 LHeap Merge1(LHeap H1,LHeap H2)&#123; if(H1-&gt;left == NULL) H1-&gt;left = H2; else &#123; H1-&gt;right = Merge(H1-&gt;right , H2); if(H1-&gt;left-&gt;npl &lt; H1-&gt;right-&gt;npl) Swap(H1-&gt;left, H1-&gt;right); H1-&gt;npl = H1-&gt;right-&gt;npl + 1; //根的npl = min(left-&gt;npl,right-&gt;npl) + 1 &#125; return H1;&#125;void Insert(LHeap &amp; H, ElemType x)&#123; LHeap NewNode = new LHNode; NewNode-&gt;element = x; NewNode-&gt;left = NewNode-&gt;right = NULL; NewNode-&gt;npl = 0; H = Merge(NewNode , H);&#125;void DeleteMin(LHeap &amp; H)&#123; if(IsEmpty(H)) &#123; cout &lt;&lt; \"The leftist heap is empty , can not delete any elements !\" &lt;&lt; endl; return; &#125; LHeap leftHeap = H-&gt;left; LHeap rightHeap = H-&gt;right; delete H; H = Merge(leftHeap , rightHeap);&#125; 参考资料：数据结构与算法分析——C语言实现","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://aojueliuyun.github.io/tags/数据结构/"},{"name":"堆","slug":"堆","permalink":"http://aojueliuyun.github.io/tags/堆/"},{"name":"树","slug":"树","permalink":"http://aojueliuyun.github.io/tags/树/"}]},{"title":"哈希表","slug":"2018.3.20--hash-table","date":"2018-03-19T16:00:00.000Z","updated":"2018-06-23T15:28:44.366Z","comments":true,"path":"2018/03/20/2018.3.20--hash-table/","link":"","permalink":"http://aojueliuyun.github.io/2018/03/20/2018.3.20--hash-table/","excerpt":"哈希表是一种 以常数平均时间执行插入、删除和查找操作的数据结构，但是哈希表一般不提供任何与排序相关的操作，如FindMax，FindMin，sort。","text":"哈希表是一种 以常数平均时间执行插入、删除和查找操作的数据结构，但是哈希表一般不提供任何与排序相关的操作，如FindMax，FindMin，sort。 哈希表散列表（Hash table，也叫哈希表），是根据关键字的值(Key value)而直接进行访问的数据结构。这里的关键字可能是数或者字符串。也就是说，通过将关键字的值映射到表中一个位置来查找。这个映射叫做哈希函数，即有 Hash(key)=address （存储结构一般是数组，所以address一般就是数组下标）。知道key之后，通过哈希函数计算出地址，即可在O(1)的时间内完成查找，插入，删除等操作，可以看到这是非常高效的。这与数组链表等都不同，数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易，而哈希表则集中了他们的优点。但同样也有缺点，一种数据结构不可能没有缺点，不同的数据结构都有不同的应用场合，这也是它们的特点决定的。哈希表对排序相关的操作并不提供支持。 哈希函数一个好的哈希函数所具有的的特点：计算简单+分布均匀（计算得到的散列地址分布均匀）常用的哈希函数的构造方法：直接寻址：H(key)=key 或 H(key) = a·key + b数字分析法：在多组关键字中取重复较少的来作为key除留取余法：Hash(key) = key % p，p一般取一个小于等于表长的素数。另外还有：平方取中法、折叠法、随机数法、斐波那契散列法等。可参见Perfect hash function。 哈希冲突我们通过哈希函数来求得地址，但是由于内存等限制，我们不可能将地址范围取得非常非常大，这样如果只存储少量元素则是非常低效的。而关键字值key通常会具有某些相似性。这样就有可能使得两个不同关键字通过哈希函数计算出的哈希值产生相同的情况。这被称为哈希冲突。比如，我们常用的一个最简单的哈希函数——除留取余法，即 Hash(key) = key % p，p一般取一个素数。这样很容易就会得到一样的地址。所以我们需要处理哈希冲突。 虽然哈希冲突基本上是不可避免的，但是首先必须得选择一个好的哈希函数。 为了保证查找效率，存储一般都选择数组。这里介绍两种处理哈希冲突的方法：分离链接法（拉链法）：将地址相同的元素链在前一个元素后面，使用链表，一个地址存放多个元素。如下图： 开放定址法：依然采用数组存储，但是在遇到冲突时，哈希函数调整为 Hi(key) = (Hash(key) + F(i)) % TableSize，其中函数F是冲突解决方法，F(0)=0，这样我们就可以依次尝试选择H0(key),H1(key),H2(key)等作为哈希函数。并将该元素放入第一个被选中的没有被占据的位置。对于不同的F可以将其称作不同的方法，比如F(i)=i，线性探测法；F(i)=i2，平方探测法；F(i)=i·Hash2(key)，双散列法。 这样做有一个问题，当删除其中的一些元素后，那些原来因为这个位置被填充而存储到其他位置的元素，就会面临查找时找不到的情况。所以我们一般使用懒惰删除，只是将其状态置为删除。并不真正从数组中删除（尽管在数组中并没有真正意义的删除）。所以我们需要将数组的类型定义为结构，并将元素状态封装在其中（可使用枚举变量）。 填充因子 λ = 已填充元素个数/表长，对于分离链接法，达到1左右最佳。对于开放定址法，不应使其超过0.5，否则性能可能会急剧下降。对于开放定址法，当 λ 达到0.5后，可以将其复制到一个更大的表中，这将花费O(n)的操作时间。称其为再哈希（rehash）。下面的第二个实现中实现了rehash。 实现这里简要实现以下，哈希函数采用最简单的取余法，并且没有取素数，这里只是一个demo。 分离链接法实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//2018.3.20//哈希表-分离链接法//这次带头结点了，一点点空间而已，没必要增大编写难度 #include&lt;iostream&gt;using namespace std;typedef int ElemType;class HashTable&#123;private: typedef int Index; typedef class ListNode &#123; public: ElemType element; ListNode * next; &#125; * Position, * List; int Table_Size; List * Lists;private: Index Hash(ElemType key) &#123; return key % Table_Size; &#125; Position Find(ElemType key);public: HashTable(int table_size); ~HashTable(); void Insert(ElemType key); void Delete(ElemType key); void Print();&#125;;int main(void)&#123; HashTable H(20); for(int i=0; i&lt;100; i++) &#123; H.Insert(i); &#125; H.Print(); for(int i=0; i&lt;50; i++) H.Delete(i); H.Print(); return 0;&#125;HashTable::HashTable(int table_size)&#123; Table_Size = table_size; Lists = new Position[table_size];//Lists存放指向ListNode的指针 for(int i=0; i&lt;table_size; i++) &#123; Lists[i] = new ListNode;//we need a header ndoe Lists[i]-&gt;element = 0; Lists[i]-&gt;next = NULL; &#125;// cout &lt;&lt; \"HashTable()\" &lt;&lt; endl;&#125;HashTable::~HashTable()&#123; for(int i=0; i&lt;Table_Size; i++) &#123; Position p = Lists[i]; while(p != NULL) &#123; Position tmp = p; p = p-&gt;next; delete tmp; &#125; &#125; delete [] Lists;&#125;HashTable::Position HashTable::Find(ElemType key)&#123; Position p = Lists[Hash(key)]-&gt;next; while(p != NULL &amp;&amp; p-&gt;element != key)//判断顺序一定不能变 p = p-&gt;next; return p;&#125;void HashTable::Insert(ElemType key)&#123; Position pos = Find(key); if(pos == NULL)//key不存在则在表头插入 &#123; List L = Lists[Hash(key)]; Position p = new ListNode; p-&gt;element = key; p-&gt;next = L-&gt;next; L-&gt;next = p; &#125; //存在则do nothing&#125;void HashTable::Delete(ElemType key)&#123; Position pos = Find(key); if(pos != NULL)//存在则删除 &#123; Position pre = Lists[Hash(key)]; while(pre-&gt;next != pos) pre = pre-&gt;next; pre-&gt;next = pos-&gt;next; delete pos; &#125;&#125;//按照一定的规则将哈希表中元素分布打印出来 void HashTable::Print()&#123; for(int i=0; i&lt;Table_Size; i++) &#123; Position p = Lists[i]-&gt;next; if(p == NULL) cout &lt;&lt; \"index:\" &lt;&lt; i &lt;&lt; \" No elements\" &lt;&lt; endl; else &#123; cout &lt;&lt; \"index:\" &lt;&lt; i &lt;&lt; \" elements: \"; while(p != NULL) &#123; cout &lt;&lt; p-&gt;element &lt;&lt; \" \"; p = p-&gt;next; &#125; cout &lt;&lt; endl; &#125; &#125;&#125; 开放定址法实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149//2018.3.20//hash table --开放定址法//线性探测法，平方探测法，双散列法 #include&lt;iostream&gt;using namespace std;typedef int ElemType;const int Min_cell_num = 20;class HashTable&#123;private: enum Cell_State &#123; legitimate, empty, deleted &#125;;//legitimate合法的 typedef unsigned int Index; typedef Index Position; class Cell &#123; public: ElemType element; enum Cell_State info; &#125;; int Table_Size; Cell * Cells; int Elements_num;//已填充的元素个数，包括已删除的 public: HashTable(const int table_size); ~HashTable(); void Insert(const ElemType key); void Delete(const ElemType key); void Print() const; int Get_elements_num() const; private: Position Find(const ElemType key); inline Index Hash(const ElemType key) &#123; return key % Table_Size; &#125; void ReHash();&#125;;int main(void)&#123; HashTable H(19); for(int i=0; i&lt;100; i++) &#123; H.Insert(i); &#125; H.Print(); int A[10] = &#123;3,7,32,34,47,25,13,9,28,22&#125;; for(int i=0; i&lt;10; i++) H.Insert(A[i]); H.Print(); cout &lt;&lt; H.Get_elements_num() &lt;&lt; endl; return 0;&#125;HashTable::HashTable(const int table_size)&#123; if(table_size &gt;= Min_cell_num) Table_Size = table_size; else &#123; cout &lt;&lt; \"The table size is too small , already set Table_Size = \" &lt;&lt; Min_cell_num &lt;&lt; endl; Table_Size = Min_cell_num; &#125; Cells = new Cell[Table_Size]; for(int i=0; i&lt;Table_Size; i++)//初始化必不可少 Cells[i].info = empty; Elements_num = 0;&#125;HashTable::~HashTable()&#123; delete Cells;&#125;HashTable::Position HashTable::Find(const ElemType key)&#123; Position current_pos = Hash(key); int offset = 0; while(Cells[current_pos].info != empty &amp;&amp; Cells[current_pos].element != key) &#123; //线性探测法 //current_pos ++; //平方探测法 current_pos += 2 * ++offset -1; //此处采用递推关系f(i) = f(i-1)+2*i-1,f(0)=0 //双散列法 //current_pos += (R-R%key);//需要事先定义一个素数R if(current_pos &gt;= Table_Size) current_pos -= Table_Size;//取模 &#125; return current_pos; &#125;void HashTable::Insert(const ElemType key)&#123; Position pos = Find(key); //这里可能存在关键字为key的元素，不存在或者存在且被删除就插入，存在合法就跳过 if(Cells[pos].info != legitimate) &#123; if(Cells[pos].info == empty) Elements_num ++; Cells[pos].info = legitimate; Cells[pos].element = key; &#125; if(Elements_num &gt;= Table_Size/2)//填充因子达到0.5就再哈希 ReHash();&#125;void HashTable::Delete(const ElemType key)&#123; Position pos = Find(key); if(Cells[pos].info == legitimate) Cells[pos].info == deleted;//存在且合法则将其置为删除状态 &#125;void HashTable::Print() const&#123; for(int i=0; i&lt;Table_Size; i++) &#123; if(Cells[i].info == legitimate) cout &lt;&lt; \"Index: \" &lt;&lt; i &lt;&lt; \" element: \" &lt;&lt; Cells[i].element &lt;&lt; endl; else cout &lt;&lt; \"Index: \" &lt;&lt; i &lt;&lt; \" no elements !\" &lt;&lt; endl; &#125;&#125;int HashTable::Get_elements_num() const&#123; return Elements_num;&#125;//再哈希，当填充因子达到0.5时则将其复制到一个两倍大的表中void HashTable::ReHash()&#123; Cell * Old_cells = Cells; int Old_size = Table_Size; Cells = new Cell [2*Table_Size+1] ; Table_Size = 2*Table_Size+1; Elements_num = 0; for(int i=0; i&lt;Table_Size; i++)//初始化是很重要的，不初始化是会crash的 &#123; Cells[i].info = empty; &#125; for(int i=0; i&lt;Old_size; i++) &#123; if(Old_cells[i].info == legitimate) Insert(Old_cells[i].element); &#125; delete Old_cells; cout &lt;&lt; \"The hash table has been rehashed , now the table size is \" &lt;&lt; Table_Size &lt;&lt; endl; &#125;","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://aojueliuyun.github.io/tags/数据结构/"},{"name":"hash","slug":"hash","permalink":"http://aojueliuyun.github.io/tags/hash/"}]},{"title":"AVL树","slug":"2018.3.17--avl-tree","date":"2018-03-16T16:00:00.000Z","updated":"2018-06-23T15:28:09.984Z","comments":true,"path":"2018/03/17/2018.3.17--avl-tree/","link":"","permalink":"http://aojueliuyun.github.io/2018/03/17/2018.3.17--avl-tree/","excerpt":"AVL树是一种带有自平衡性质的的二叉查找树，也就是说，在多次插入删除或者极端数据情况下依然可以保证O(logn)的操作复杂度。","text":"AVL树是一种带有自平衡性质的的二叉查找树，也就是说，在多次插入删除或者极端数据情况下依然可以保证O(logn)的操作复杂度。 自平衡的二叉查找树上一篇中的二叉查找树在多次插入删除后，树的节点会向其中一边下沉，操作（插入/删除/查找）的复杂度会从O(logn)渐渐增大。在数据量很大时，操作时间可能变得不可接受。而且当建树的一组数据是已经排好序的极端情况时，普通的二叉查找树就会退化为代价高昂的链表，而时间复杂度将会退化为线性的O(n)。 而要避免以上问题，我们需要为二叉查找树建立一个平衡的附加结构条件。条件不同，实现不同。当附加平衡条件后，二叉树便可以实现自平衡，即当大量插入删除时仍然可以保持O(logn)的最坏操作时间复杂度，我们将其称作平衡二叉搜索树（Self-balancing binary search tree）。平衡二叉树常见的实现有AVL树、红黑树（Red Black Tree）、伸展树（Splay tree）等。工程中大量使用红黑树，以后有机会讨论。这里简要实现AVL树。 AVL TreeAVL树是以它的发明者（G.M. Adelson-Velsky 和 E.M. Landis）来命名的，也是最先发明的自平衡二叉查找树，于1962年发明。AVL树的平衡条件是：每个节点的左子树与右子树高度相差不超过1。其中只有一个根节点的高度定义为0，空树高度定义为-1。 这里需要区分两个概念，节点的深度与高度，深度是从根节点到该节点的唯一路径的长度，高度是从该节点到其后代的树叶的最长路径。则根节点深度为0，对一棵树来说，树的高等于根节点的高，也等于该树最深的树叶的深度，即树的深度。 因为插入和删除可能会破坏AVL树的平衡条件，所以插入和删除后如果失衡则必须对其进行修正/平衡化。我们称其为旋转。首先考虑插入，我们把必须要重新平衡的节点就做a，因此高度不平衡时，a的左子树与右子树高度相差2。这可以分为以下4种情况： 对a的左儿子的左子树进行了一次插入。 对a的左儿子的右子树进行了一次插入。 对a的右儿子的左子树进行了一次插入。 对a的右儿子的右子树进行了一次插入。 情形1和4是对称的，2和3也是对称的。因为需要通过节点的高度来判断是否平衡，所以我们在节点中增加一个域height来表示该节点的高度。所以节点定义如下。123456789#define Max(a,b) (a&gt;b?a:b)typedef int ElemType;typedef struct TreeNode&#123; ElemType element; TreeNode * left; TreeNode * right; int height;&#125; * pNode, * AvlTree; 操作声明：12345678int Height(pNode p);void Insert(AvlTree &amp; T,ElemType x);void Delete(AvlTree &amp; T,ElemType x);pNode Single_rotate_left(pNode p); //从左向右单旋pNode Single_rotate_right(pNode p);//从右向左单旋pNode Double_rotate_left(pNode p);pNode Double_rotate_right(pNode p);AvlTree CreateTree(ElemType A[],int n);//从数组建树 由于需要通过计算高度来判断平衡，所以必须定义一个计算节点高度的函数：1234567int Height(pNode p)&#123; if(p == NULL) return -1; else return p-&gt;height;&#125; 从数组建树：1234567AvlTree CreateTree(ElemType A[],int n)&#123; AvlTree T = NULL; for(int i = 0; i &lt; n; i++) Insert(T,A[i]); return T;&#125; 单旋转考虑情形1，如果对a的左儿子的左子树进行了一次插入，导致a的左子树比右子树高度大2的话，那么我们可以通过如下的单旋转来使其重新平衡。 旋转后，返回tmp，很容易看出旋转后，依然满足二叉查找树的性质，而且重新达到了平衡。这一过程的实现：123456789pNode Single_rotate_left(pNode p) &#123; pNode tmp = p-&gt;left; p-&gt;left = tmp-&gt;right; tmp-&gt;right = p; p-&gt;height = Max(Height(p-&gt;left),Height(p-&gt;right)) + 1; tmp-&gt;height = Max(Height(tmp-&gt;left),p-&gt;height) + 1; return tmp;&#125; 类似的情形4，则如图所示。 实现（与情形1镜像对称）：123456789pNode Single_rotate_right(pNode p)&#123; pNode tmp = p-&gt;right; p-&gt;right = tmp-&gt;left; tmp-&gt;left = p; p-&gt;height = Max(Height(p-&gt;left),Height(p-&gt;right)) + 1; tmp-&gt;height = Max(Height(tmp-&gt;right),p-&gt;height) + 1; return tmp; &#125; 上面的实现中，Single_rotate_left表示的是从左向右单旋，Single_rotate_right是从右向左单旋。 双旋转情形2和3则无法通过单旋转实现平衡，但可以通过一次双旋转来完成。就情形2来说，对a的左儿子的右子树进行了一次插入导致a的左子树比右子树高度大了2。则可以通过如下的旋转使得再次达到平衡。 可以很明显的看出双旋转可以通过两次单旋转来完成，上图中，首先对子树k1进行可一次从右向左的单旋，然后对k3进行了一次从左向右的单旋。所以实现时调用上述函数即可。12345pNode Double_rotate_left(pNode p)&#123; p-&gt;left = Single_rotate_right(p-&gt;left); return Single_rotate_left(p);&#125; 类似，情形3，如下。 实现：12345pNode Double_rotate_right(pNode p)&#123; p-&gt;right = Single_rotate_left(p-&gt;right); return Single_rotate_right(p);&#125; 上面的1,2,3,4四种情形也经常因为插入位置被称为LL,LR,RL,RR。一个描述了这几种旋转的动图： 插入旋转实现了，则插入就可以实现了，注意旋转中必须对节点高度进行必要的更新。AVL树插入节点的实现：1234567891011121314151617181920212223242526272829303132333435void Insert(AvlTree &amp; T,ElemType x)&#123; if(T == NULL) &#123; T = new TreeNode; T-&gt;element = x; T-&gt;height = 0; T-&gt;left = T-&gt;right = NULL; &#125; else if(x &lt; T-&gt;element) &#123; Insert(T-&gt;left,x);//在T的左子树插入 if(Height(T-&gt;left) - Height(T-&gt;right) == 2) //左子树失衡，需要平衡 &#123; if(x &lt; T-&gt;left-&gt;element)//插入在T的左孩子的左子树，单旋转，情形1 T = Single_rotate_left(T); else //插入在T的左孩子的右子树，双旋转，情形2 T = Double_rotate_left(T); &#125; &#125; else if(x &gt; T-&gt;element) &#123; Insert(T-&gt;right,x);//在T的右子树插入 if(Height(T-&gt;right) - Height(T-&gt;left) == 2) //右子树失衡，需要平衡 &#123; if(x &gt; T-&gt;right-&gt;element)//插入在T的右孩子的右子树，单旋转，情形4 T = Single_rotate_right(T); else //插入在T的右孩子的左子树，双旋转，情形3 T = Double_rotate_right(T); &#125; &#125; //else x is aleardy exist in the tree, we'll do nothing. //Don't forget to update the height of root T-&gt;height = Max(Height(T-&gt;left),Height(T-&gt;right)) + 1;&#125; 删除比较复杂，暂时未实现。待补。 参考资料：数据结构与算法分析——C语言描述","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://aojueliuyun.github.io/tags/数据结构/"},{"name":"树","slug":"树","permalink":"http://aojueliuyun.github.io/tags/树/"}]},{"title":"二叉查找树","slug":"2018.3.15--binary-search-tree","date":"2018-03-14T16:00:00.000Z","updated":"2018-03-18T02:18:04.551Z","comments":true,"path":"2018/03/15/2018.3.15--binary-search-tree/","link":"","permalink":"http://aojueliuyun.github.io/2018/03/15/2018.3.15--binary-search-tree/","excerpt":"简单介绍树，基础说多了也没什么意思，这里主要实现二叉查找树。","text":"简单介绍树，基础说多了也没什么意思，这里主要实现二叉查找树。 树树，是一种非线性的数据结构，是一种特殊的（没有回路的）图，主要用在涉及到一个问题具有分支情况下的建模。树的若干定义都很简单，像父亲，儿子，根，兄弟，祖先，树叶，树枝，深度，高度等。一般操作系统的文件结构就是采用的树形结构。也就是B树/B+树等。Linux系统的文件结构一角：12345678910111213141516171819202122├── udisks2│ └── mounted-fs├── user│ ├── 0│ └── 1000│ ├── dconf│ │ └── user│ ├── gnome-shell│ │ └── runtime-state-LE.:0│ │ └── screenShield.locked│ ├── keyring│ │ ├── control│ │ ├── pkcs11│ │ └── ssh│ └── pulse│ ├── native│ └── pid├── utmp├── vmware│ └── guestServicePipe└── xtables.lock//使用tree命令打印 在很多情况下，我们主要讨论二叉树（Binary Tree），也就是每一个节点最多只有两个子节点的情况。有一些比较特殊的二叉树值得讨论，比如：满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。完全二叉树有时采用线性存储（即堆），但其余的二叉树一般采用二叉链存储结构。 另外，对于一般的树，我们也通常采用孩子兄弟链存储结构，节点一般如下定义：123456struct treeNode&#123; ElemType element; treeNode * FirstChild; //第一个孩子 treeNode * NextSibling; //下一个兄弟节点&#125;; 而对于二叉树，因为最多只有两个孩子，所以一般采用如下节点定义：123456typedef struct treeNode&#123; ElemType element; treeNode * left; //左孩子 treeNode * right; //右孩子&#125; * BiTree, * pNode; 树的遍历在二叉树的一系列操作之中，我们比较关心插入、删除、求高度、遍历等操作。这里对于所有的二叉树，给出求高度与遍历的方法。遍历一般采用递归，当然也可以不用递归，直接创建栈来模拟递归调用用户栈的过程。所以有递归遍历与非递归遍历的实现，在实际编写程序我们更倾向于使用递归遍历。这里给出实现。 求任意节点的高度：1234567int Height(pNode p)&#123; if(p == NULL) return -1; else return max(Height(p-&gt;left), Height(p-&gt;right)) + 1;&#125;//这里max为求两者之中最大值得函数，使用宏定义#define max(a,b) (a&gt;b?a:b)即可 二叉树的先序、中序、后序递归遍历：123456789101112131415161718192021222324void pre_traverse(BiTree T) //先序，根左右&#123; if(T == NULL) return ; cout &lt;&lt; T-&gt;element &lt;&lt; \" \"; pre_traverse(T-&gt;left); pre_traverse(T-&gt;right);&#125;void in_traverse(BiTree T) //中序，左根右&#123; if(T == NULL) return; in_traverse(T-&gt;left); cout &lt;&lt; T-&gt;element &lt;&lt; \" \"; in_traverse(T-&gt;right); &#125;void post_traverse(BiTree T) //后序，左右根&#123; if(T == NULL) return; post_traverse(T-&gt;left); post_traverse(T-&gt;right); cout &lt;&lt; T-&gt;element &lt;&lt; \" \";&#125; 非递归先序遍历：1234567891011121314151617void pre_traverse_nonrecursive(BiTree T)&#123; if(T == NULL) return; stack&lt;pNode&gt; S; S.push(T); while(! S.empty()) &#123; pNode tmp = S.top(); cout &lt;&lt; tmp-&gt;element &lt;&lt; \" \"; S.pop(); if(tmp-&gt;right) S.push(tmp-&gt;right); if(tmp-&gt;left) S.push(tmp-&gt;left); &#125;&#125; 中序及后序改造一下即可，不做实现，这里非递归遍历并没有节省多少空间，只是自定义的栈代替了用户栈。空间复杂度依然为O(n)，时间复杂度同为O(n)。其实还存在空间复杂度为O(1)的遍历方法，实现过程稍微复杂一点点，远不如递归遍历来得那么简洁，等到有必要这样实现的时候再实现一下。很多情况下我们也可以构造线索二叉树，使得遍历不用栈和队列的辅助，优化时间。有的时候需要层序遍历，层序遍历即是二叉树层数从上到下从左到右，依次输出节点，使用队列辅助进行。 二叉查找树二叉查找树（Binary serach tree）亦称二叉搜索树，二叉排序树，特点是其中序遍历序列是单调的（一般实现时选择递增）。也就是说，它是用来存储、查找与排序用的。当我们使用线性结构数组时，查找很方便，但插入和删除却要O(n)的平均复杂度。使用链表时，插入删除很方便，查找的平均复杂度却是O(n)。所以引入了非线性结构二叉查找树，弥补数组和链表的缺点，使得查找、插入、删除操作的平均时间复杂度均是O(logn)。 二叉查找树的递归定义： 对于任意一个节点，如果左子树不空，则左子树的所有节点值均小于根节点值 对于任意一个节点，如果右子树不空，则右子树的所有节点值均大于根节点值 左子树、右子树也是二叉查找树 实现首先，采用二叉链存储结构，节点定义，同一般二叉树。1234567typedef int ElemType;typedef struct treeNode&#123; ElemType element; treeNode * left; treeNode * right;&#125;* pNode, * BSTree; 函数声明：1234567891011void Clear(BSTree &amp;T); //清空一颗树pNode Find(BSTree T,ElemType x); //查找元素xpNode FindMax(BSTree T); //查找最大值pNode FindMin(BSTree T); //查找最小值void Insert(BSTree &amp;T,ElemType x);//Insert理论情况不会出错，返回值void bool Delete(BSTree &amp;T,ElemType x);//删除失败时返回 false ElemType Retrieve(pNode p); //取节点值//先序、中序、后序遍历，见上面void pre_traverse(BSTree T);void in_traverse(BSTree T);void post_traverse(BSTree T); 清空二叉树：这里一定要确保传入的是一棵树，就算是空树，而不是一个未初始化为NULL的指针，否则的话程序很有可能会崩溃，发生SIGSEGV错误，也就是递归得不到终止，则栈空间将被用尽，俗称爆栈。注：windows下用户栈大概是1MB，Linux下一般是8MB，可通过编译指令更改，所以一定要注意不能爆栈，递归一定要能终止且层数不能过多，这里二叉查找树的递归层数最大为树深度即O(logn)，复杂度低，一般情况不会爆栈。1234567891011//Please ensure the parameter is a tree void Clear(BSTree &amp;T)&#123; if(T != NULL) &#123; Clear(T-&gt;left); Clear(T-&gt;right); delete T; T = NULL; &#125;&#125; 查找元素x：1234567891011pNode Find(BSTree T,ElemType x)&#123; if(T == NULL) return NULL; if(x &lt; T-&gt;element) return Find(T-&gt;left,x); else if(x &gt; T-&gt;element) return Find(T-&gt;right,x); else return T;&#125; 查找最大值与最小值：123456789101112pNode FindMax(BSTree T)&#123; while(T-&gt;right != NULL) T = T-&gt;right; return T;&#125;pNode FindMin(BSTree T)&#123; while(T-&gt;left != NULL) T = T-&gt;left; return T;&#125; 取节点值：123456789ElemType Retrieve(pNode p)&#123; if(p == NULL) &#123; cout &lt;&lt; \"This node doesn't exist !\" &lt;&lt; endl; return 0; &#125; return p-&gt;element;&#125; 插入一个值为x的节点：这里插入时，如果存在元素x，则什么也不做，否则总是插入在路径的最后一个节点上。插入时，如果关键字x存在，则根据需要做该做的事，有的时候关键字仅仅是结构的一个域，则需要将该节点插入。某些情况下，关键字存在则不需要做任何事。我们甚至可以采用懒惰删除，即之只标记被删除的节点，表明它不属于这棵树，而不实际地将其从树中移走。在需要的时候，比如关键字相同的节点很多的时候，我们可以在树节点定义中加上一各域，表示该节点出现的频率，删除时将该域减1，插入时加1。上面的方法可以省去很多内存操作，提高效率，根据需求实现。123456789101112131415void Insert(BSTree &amp;T,ElemType x)&#123; if(T == NULL) &#123; T = new treeNode; T-&gt;element = x; T-&gt;left = T-&gt;right = NULL; &#125; else if(x &gt; T-&gt;element) Insert(T-&gt;right,x); else if(x &lt; T-&gt;element) Insert(T-&gt;left,x); //else x is aleardy exist , we'll do nothing //and you can do the things you want&#125; 删除一个节点值为x的元素：若节点不存在，则不进行任何操作。关键字为x的节点存在的三种情况： 该节点为树叶，即没有左右孩子，则直接删除，并将其父节点对应域更改为NULL即可。 该节点有一个孩子，则直接使其父节点的对应域指向其孩子节点，并释放其空间即可。 该节点有来左右两个孩子，则用其右子树的最小值的来替换该节点（替换相应域即可），并删除这个用来替换的节点，显然这个节点一定只有0个或者一个孩子节点，则直接递归调用上述过程即可。 1234567891011121314151617181920212223242526bool Delete(BSTree &amp;T,ElemType x)&#123; if(T == NULL) &#123; cout &lt;&lt; \"The element you want to delete is not in this tree !\" &lt;&lt; endl; return false; &#125; else if(x &gt; T-&gt;element) return Delete(T-&gt;right,x); else if(x &lt; T-&gt;element) return Delete(T-&gt;left,x); else if(T-&gt;left &amp;&amp; T-&gt;right)//the node has two children &#123; pNode tmp = FindMin(T-&gt;right); T-&gt;element = tmp-&gt;element; Delete(T-&gt;right,T-&gt;element); //删除已经替换上来的节点 return true; &#125; else //the node has one or zero children &#123; pNode tmp = T; T = T-&gt;left == NULL ? T-&gt;right : T-&gt;left; //改变T指针的指向为T的唯一的孩子节点或者NULL delete tmp; return true; &#125;&#125; 二叉查找树的查找、删除、插入的最坏时间复杂度均为O(logn)，因为二叉查找树的平均深度为O(logn)。 但二叉查找树依然存在一些缺陷，如： 如果原来就是排好序的，那么按照顺序插入，则二叉树就变成了链表一样的形状，效率急剧降低。 在进行了很多次的插入和删除之后，删除中的一个步骤（总是用待删除节点右子树的最小值的来替换该节点）就会导致树枝呈现出向左边倾斜的趋势，在多次Insert和Delete后，平均操作复杂度会逐渐上升。 要解决以上问题，可以通过平衡二叉树，或者以后将介绍的近乎平衡的AVL树等数据结构来解决。","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://aojueliuyun.github.io/tags/数据结构/"},{"name":"树","slug":"树","permalink":"http://aojueliuyun.github.io/tags/树/"}]},{"title":"Algorithms started","slug":"2018.3.14--algorithms-started","date":"2018-03-13T16:00:00.000Z","updated":"2018-03-17T12:23:23.035Z","comments":true,"path":"2018/03/14/2018.3.14--algorithms-started/","link":"","permalink":"http://aojueliuyun.github.io/2018/03/14/2018.3.14--algorithms-started/","excerpt":"Algorithm入门，随便写一写，算法复杂度分析，和几个简单的问题——最大子序列之和、最大公约数、二分查找。","text":"Algorithm入门，随便写一写，算法复杂度分析，和几个简单的问题——最大子序列之和、最大公约数、二分查找。 复杂度分析常用记号$O(f(n))$，表示上界，$\\Omega (f(n))$表示下界，$\\Theta(f(n))$表示渐进。一般情况下进行上界分析，也就是大O分析，有的情况下会进行复杂度的下界分析。 下面看几个简单问题。 最大子序列之和问题描述，给出$A_0,A_1,…,A_{n-1}$，n个数的序列，找出其最大的子序列之和。其中序列中的项均为正整数或者负整数。如果所有的项都是负数，那么最大子序列之和为0，即空序列的和。 首先，直接遍历求出所有和，比较得到最大者，时间复杂度$O(n^3)$。123456789101112131415161718int Max_subsequence_sum(const int A[],int n)&#123; int Max_sum = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; int This_sum = 0; for(int k = i; k &lt;= j; k++) &#123; This_sum += A[k]; &#125; if(This_sum &gt; Max_sum) Max_sum = This_sum; &#125; &#125; return Max_sum;&#125; 很容易看出，可以进行优化，于是有$O(n^2)$的下列算法。123456789101112131415int Max_subsequence_sum(const int A[],int n)&#123; int Max_sum = 0; for(int i = 0; i &lt; n; i++) &#123; int This_sum = 0; for(int j = i; j &lt; n; j++) &#123; This_sum += A[j]; if(This_sum &gt; Max_sum) Max_sum = This_sum; &#125; &#125; return Max_sum;&#125; 我们也可以利用分治策略解决这个问题，将序列平均分为左右两个子序列，那么和最大的子序列可能完全位于左边的子序列，也可能位于右边的子序列，也可能是左边子序列中一项到其最右边与右边第一项到某一项合起来的子序列。时间$T(n) = 2T(n/2)+O(n)$，由主定理很容易得到，时间复杂度为$O(n\\log n)$。实现如下。12345678910111213141516171819202122232425262728293031323334353637383940414243int Max_sub_sum(int A[],int left,int right)&#123; if(left == right) &#123; if(A[left] &gt; 0) return A[left]; else return 0; &#125; int mid = (left + right) / 2; int max_left_sum = Max_sub_sum(A,left,mid); int max_right_sum = Max_sub_sum(A,mid+1,right); int left_border_sum = 0; int max_left_border_sum = 0; for(int i = mid; i &gt;= left; i--) &#123; left_border_sum += A[i]; if(left_border_sum &gt; max_left_border_sum) max_left_border_sum = left_border_sum; &#125; int right_border_sum = 0; int max_right_border_sum = 0; for(int i = mid+1; i &lt;= right; i++) &#123; right_border_sum += A[i]; if(right_border_sum &gt; max_right_border_sum) max_right_border_sum = right_border_sum; &#125; int max_cross_sum = max_left_border_sum + max_right_border_sum; //reurn the max of three summation if(max_left_sum &gt;= max_cross_sum &amp;&amp; max_left_sum &gt;= max_right_sum) return max_left_sum; else if(max_right_sum &gt;= max_left_sum &amp;&amp; max_right_sum &gt;= max_cross_sum) return max_right_sum; else return max_cross_sum; &#125;int Max_subsequence_sum(int A[],int n)&#123; return Max_sub_sum(A,0,n-1);&#125; 上述分治算法看起来非常的冗长。但是还要一个更好更简单的时间复杂度为$O(n)$的算法。如下。1234567891011121314int Max_subsequence_sum(const int A[],int n)&#123; int This_sum = 0; int Max_sum = 0; for(int i = 0; i &lt; n; i++) &#123; This_sum += A[i]; if(This_sum &gt; Max_sum) Max_sum = This_sum; if(This_sum &lt; 0) This_sum = 0; &#125; return Max_sum;&#125; 最后这个算法很容易理解。这也是求解这个问题最好的算法。 求最大公约数最佳方法当然是辗转相除法/欧几里得算法了。123456789101112//Greatest common divisorint gcd(int m,int n)&#123; int tmp; while(n &gt; 0) &#123; tmp = m % n; m = n; n = tmp; &#125; return m;&#125; 递归写法:1234int gcd(int m,int n)&#123; return n == 0 ? m : gcd(n,m%n);&#125; 最小公倍数（Lowest Common Multiple）则直接根据最大公约数来求。1234int lcm(int n,int m)&#123; return n*m/gcd(n,m);&#125; 二分查找问题：在排好序的n个数中查找等于x的元素，未找到返回-1。假定这里是升序排列的。1234567891011121314151617int Binary_search(int A[],int x,int n)&#123; int low = 0; int high = n-1; int mid; while(low &lt;= high) &#123; mid = (low + high) / 2; if(A[mid] &gt; x) high = mid-1; else if (A[mid] &lt; x) low = mid+1; else return mid; &#125; return -1;&#125; 很明显时间复杂度$O(\\log n)$。 这一篇就是无聊水一水，水一水就好。","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"basic algorithms","slug":"basic-algorithms","permalink":"http://aojueliuyun.github.io/tags/basic-algorithms/"}]},{"title":"矩阵快速幂","slug":"2018.3.10--matrix-power-mod","date":"2018-03-09T16:00:00.000Z","updated":"2018-06-24T10:50:40.879Z","comments":true,"path":"2018/03/10/2018.3.10--matrix-power-mod/","link":"","permalink":"http://aojueliuyun.github.io/2018/03/10/2018.3.10--matrix-power-mod/","excerpt":"快速幂快速幂算法很熟悉很容易理解，原理 $n^m = \\begin{cases} (n^2)^{m/2} &amp; m为偶数 \\\\(n^2)^{m/2}\\cdot n &amp; m为奇数\\end{cases}$二分可以将时间复杂度由$O(n)$降到$O(\\log n)$。通常m的范围非常大，常常到$10^9$，所以一般给出的题中会要求取模。视情况使用32位或者64位整型。","text":"快速幂快速幂算法很熟悉很容易理解，原理 $n^m = \\begin{cases} (n^2)^{m/2} &amp; m为偶数 \\\\(n^2)^{m/2}\\cdot n &amp; m为奇数\\end{cases}$二分可以将时间复杂度由$O(n)$降到$O(\\log n)$。通常m的范围非常大，常常到$10^9$，所以一般给出的题中会要求取模。视情况使用32位或者64位整型。 $n^m\\%d$ 的实现(见快速幂取模)：123456789101112131415int Quick_Power_Mod(int n,int m,int d)&#123; int ans = 1; n = n%d; while(m &gt; 0) &#123; if(m%2 == 1) &#123; ans = (ans * n) % d; &#125; m = m/2; n = (n*n)%d; &#125; return ans;&#125; 矩阵快速幂如果将其中的n换为矩阵的话，则为矩阵快速幂。例题：XDOJ-1027: Feibonaqi数列1.f(0)=0,f(1)=12.f(n)=2f(n-1)+f(n-2),n&gt;1如果直接递归的话时间会爆，设数组保存的话空间会爆。只能快速幂。求出递推公式也不可行，因为特征根是无理数。所以需要找出矩阵形式的递推关系，从而求出矩阵形式的显示公式：$ \\left[ \\begin{matrix} f(n) \\\\f(n-1) \\end{matrix} \\right] =$ $\\left[\\begin{matrix}2 &amp; 1 \\\\1 &amp; 0\\end{matrix}\\right ]$ $\\times \\left[ \\begin{matrix} f(n-1) \\\\f(n-2) \\end{matrix} \\right]$ 递推得到：$ \\left[ \\begin{matrix} f(n) \\\\f(n-1) \\end{matrix} \\right] = $ $\\left[\\begin{matrix}2 &amp; 1 \\\\1 &amp; 0\\end{matrix}\\right ]^{n-1}$ $\\times \\left[ \\begin{matrix} f(1) \\\\f(0) \\end{matrix} \\right]$ 则使用快速幂即可解决：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//XDOJ-1027----201.3.9//矩阵快速幂 #include&lt;iostream&gt;#include&lt;cstdlib&gt;typedef long long LL;const long long Max=1000000007;using namespace std;void Matrix_mul(LL A[2][2],LL B[2][2]); //矩阵相乘 LL Matrix_pow_mod(int n); int main(void)&#123; int n; while(cin &gt;&gt; n) &#123; if(n == 0 || n == 1) &#123; cout &lt;&lt; n &lt;&lt; \"\\n\"; &#125; else &#123; cout &lt;&lt; Matrix_pow_mod(n-1) &lt;&lt; \"\\n\"; &#125; &#125; return 0;&#125;//2*2矩阵想乘 void Matrix_mul(LL A[2][2],LL B[2][2])&#123; LL ans[2][2] = &#123;&#123;0,0&#125;,&#123;0,0&#125;&#125;; for(int i = 0; i &lt; 2 ; i++) &#123; for(int j= 0; j &lt; 2; j++) &#123; for(int k=0; k &lt; 2; k++) &#123; ans[i][j] += A[i][k] * B[k][j]; &#125; if(ans[i][j] &gt; Max) //大于时才取模 &#123; ans[i][j] %= Max; &#125; &#125; &#125; for(int i=0; i &lt; 2; i++) &#123; for(int j=0; j &lt; 2; j++) &#123; B[i][j] = ans[i][j]; &#125; &#125; &#125;//矩阵快速幂 LL Matrix_pow_mod(int n)&#123; LL A[2][2] = &#123;&#123;2,1&#125;,&#123;1,0&#125;&#125;; LL Ans[2][2] = &#123;&#123;1,0&#125;,&#123;0,1&#125;&#125;; //二阶单位阵 while(n &gt; 0) &#123; if(n%2 == 1) // n &amp; 1 &#123; Matrix_mul(A,Ans); &#125; Matrix_mul(A,A); n = n/2; //n &gt;&gt;= 1; &#125; return Ans[0][0]; &#125; 类似题：poj-3070-Fibonacci 构造矩阵递推关系上面的递推关系很简单，这类问题的难点就是构造矩阵递推关系。 如：POJ 3233 Matrix Power Series 考虑到$S_k = \\sum_{i=1}^kA^i = E\\cdot S_{k-1}+A^k$ 或者 $S_k = A\\cdot S_{k-1}+A$可以构造出：$ \\left[ \\begin{matrix} S_k \\\\A^k \\end{matrix} \\right] =$ $\\left[\\begin{matrix}E &amp; A \\\\0 &amp; A\\end{matrix}\\right ]$ $\\times \\left[ \\begin{matrix} S_{k-1} \\\\A^{k-1} \\end{matrix} \\right]$或者$ \\left[ \\begin{matrix} S_k \\\\E \\end{matrix} \\right] =$ $\\left[\\begin{matrix}A &amp; A \\\\0 &amp; E\\end{matrix}\\right ]$ $\\times \\left[ \\begin{matrix} S_{k-1} \\\\E \\end{matrix} \\right]$ 方法不一。其中A是n阶方阵，E是n阶单位阵，0是n阶零矩阵。 比如由前者就可以得出：$ \\left[ \\begin{matrix} S_k \\\\A^k \\end{matrix} \\right] =$ $\\left[\\begin{matrix}E &amp; A \\\\0 &amp; A\\end{matrix}\\right ]^{n-1}$ $\\times \\left[ \\begin{matrix} A \\\\A \\end{matrix} \\right]$或者$\\left[\\begin{matrix}E &amp; A \\\\0 &amp; A\\end{matrix}\\right ]^n$$=\\left[\\begin{matrix}E &amp; S_k \\\\0 &amp; A^k\\end{matrix}\\right ]$ 实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//poj-3233----矩阵快速幂//2018,3,10#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 65;void Matrix_mul(int A[N][N],int B[N][N],int n,int m);void Matrix_pow_mod(int n,int k,int m,int A[N][N]);void print_matrix(int A[N][N],int n);void input_matrix(int A[N][N],int n);int main(void)&#123; int n,k,m; int A[N][N]; while(cin &gt;&gt; n &gt;&gt; k &gt;&gt; m) &#123; input_matrix(A,n); Matrix_pow_mod(n,k,m,A); &#125; return 0;&#125;void Matrix_mul(int A[N][N],int B[N][N],int n,int m)&#123; int res[N][N]; memset(res,0,sizeof(res)); for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= n; j ++) &#123; for(int k = 1; k &lt;= n; k ++) &#123; if(A[i][k] || B[k][j]) &#123; res[i][j] += A[i][k] * B[k][j]; res[i][j] %= m; &#125; &#125; &#125; &#125; for(int i = 0; i &lt;= n; i ++) &#123; for(int j = 0; j &lt;= n; j ++) &#123; B[i][j] = res[i][j]; &#125; &#125;&#125;void Matrix_pow_mod(int n,int k,int m,int A[N][N])&#123; int B[N][N]; int ans[N][N]; int C[N][N]; //矩阵初始化 memset(B,0,sizeof(B)); memset(ans,0,sizeof(ans)); memset(C,0,sizeof(C)); for(int i = 1; i &lt;= n; i ++) &#123; B[i][i] = 1; &#125; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= n; j ++) &#123; B[i][n+j] = A[i][j]; B[n+i][n+j] = A[i][j]; &#125; &#125; for(int i=0; i &lt;= 2*n; i++) &#123; ans[i][i] = 1; &#125; //求k次幂 while(k &gt; 0) &#123; if(k &amp; 1) &#123; Matrix_mul(B,ans,2*n,m); &#125; k &gt;&gt;= 1; Matrix_mul(B,B,2*n,m); &#125; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= n; j ++) &#123; C[i][j] = ans[i][n+j]; &#125; &#125; //print the result print_matrix(C,n);&#125;void print_matrix(int A[N][N],int n)&#123; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt; n; j ++) &#123; cout &lt;&lt; A[i][j] &lt;&lt; \" \"; &#125; cout &lt;&lt; A[i][n] &lt;&lt; endl; &#125;&#125;void input_matrix(int A[N][N],int n)&#123; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= n; j ++) &#123; cin &gt;&gt; A[i][j]; &#125; &#125;&#125; 优化：很明显可以看到，2n阶方阵中左半部分在乘幂中是没有变化的，所以可以优化掉大概一半的时间（这里没有实现）。一般情况下对于其中0较多的矩阵，可以先判断是否为0再乘。 注意这里的矩阵乘法采用的是一般的算法，复杂度$O(n^3)$，矩阵乘法有一个$O(n^{log7})$的算法: Strassen算法。采用分治策略，比较复杂暂时不会不做实现。 综上：矩阵快速幂思路与快速幂完全一致，重点是找到递推关系。 对于一些简单的递推式： 1.$f(n) = af(n-1) +bf(n-2)+c$ $ \\left( \\begin{matrix} f(n) \\\\f(n-1) \\\\c \\end{matrix} \\right) =$ $\\left(\\begin{matrix}a &amp; b &amp; 1\\\\1 &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; 1\\end{matrix}\\right)$ $\\times \\left( \\begin{matrix} f(n-1) \\\\f(n-2) \\\\c\\end{matrix} \\right)$ 2.$f(n) = ac^n + bf(n-1) + d$ $ \\left( \\begin{matrix} f(n) \\\\c^n \\\\d \\end{matrix} \\right) =$ $\\left(\\begin{matrix}b &amp; ac &amp; 1\\\\0 &amp; c &amp; 0 \\\\0 &amp; 0 &amp; 1\\end{matrix}\\right)$ $\\times \\left( \\begin{matrix} f(n-1) \\\\c^{n-1} \\\\d\\end{matrix} \\right)$ 类似简单矩阵题目：HOJ 1757（序列递推——矩阵快速幂模板）、HOJ 1575（矩阵快速幂模板）、 例不算那么简单的递推+矩阵快速幂：HOJ 3483 - A Very Simple Problem 题意：求(\\sum_{k=1}^Nk^x\\cdot x^k)\\ mod\\ M数据范围：$1 ≤ N, M ≤ 2*10^9, and 1 ≤ x ≤ 50$ 建立递推关系：$S_{n+1} = S_{n} + (n+1)^x\\cdot x^{n+1}$将$(n+1)^x$ 二项式展开为$\\sum_{k=0}^{x}C(x,k)n^k$，则可以构造出如下矩阵递推式，然后使用矩阵快速幂。12345678|1 xC(x,0) xC(x,1) xC(x,2) ... xC(x,x)| |Sn | |S(n+1) | |0 xC(0,0) 0 0 ... 0 | |x^n * n^0| |x^(n+1) * (n+1)^0| |0 xC(1,0) xC(1,1) 0 ... 0 | *|x^n * n^1|=|x^(n+1) * (n+1)^1| |0 xC(2,0) xC(2,1) xC(2,2) ... 0 | |x^n * n^2| |x^(n+1) * (n+1)^2| |... | |... | |... | |0 xC(x,0) xC(x,1) xC(x,2) ... xC(x,x)| |x^n * n^x| |x^(n+1) * (n+1)^x|//还能这样构造，我是真的佩服，只能说我太菜吧！//出处：http://blog.csdn.net/winycg/article/details/52982723 实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//hoj--3483--矩阵快速幂 + 二项式定理 //2018.3.12#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long LL;const int N = 55;struct Matrix&#123; LL mat[N][N]; &#125;;Matrix Matrix_mul(Matrix A,Matrix B, int n,int m); Matrix Matrix_pow_mod(Matrix A,int n,int k,int m);LL C[N][N];void Combination_num();//use Pascal identity to canculate Combination numberint main(void)&#123; Combination_num(); int n,x,m; while(cin &gt;&gt; n &gt;&gt; x &gt;&gt; m &amp;&amp; n != -1) &#123; Matrix S; memset(S.mat,0,sizeof(S.mat)); S.mat[1][1] = 1; for(int i = 2; i &lt;= x+2; i ++) &#123; S.mat[1][i] = (x * C[x][i-2]) % m; &#125; for(int i = 2; i &lt;= x+2; i ++) &#123; for(int j = 2; j &lt;= i; j ++) &#123; S.mat[i][j] = (x * C[i-2][j-2]) % m; &#125; &#125; LL sum = 0; Matrix ans = Matrix_pow_mod(S,x+2,n-1,m); for(int i = 1; i &lt;= x+2; i ++) &#123; sum = (sum + x * ans.mat[1][i]) % m; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125;Matrix Matrix_mul(Matrix A,Matrix B, int n,int m)&#123; Matrix res; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= n; j ++) &#123; res.mat[i][j] = 0;//init the matrix for(int k = 1; k &lt;= n; k ++) &#123; res.mat[i][j] = (res.mat[i][j] + A.mat[i][k] * B.mat[k][j]) % m; &#125; &#125; &#125; return res;&#125;Matrix Matrix_pow_mod(Matrix A,int n,int k,int m)&#123; Matrix res; //initialization for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= n; j ++) &#123; res.mat[i][j] = 0; &#125; res.mat[i][i] = 1; &#125; while(k &gt; 0) &#123; if(k &amp; 1) &#123; res = Matrix_mul(A,res,n,m); &#125; k &gt;&gt;= 1; A = Matrix_mul(A,A,n,m); &#125; return res;&#125;void Combination_num()&#123; C[0][0] = C[1][0] = C[1][1] = 1; for(int i = 2; i &lt; N; i ++) &#123; C[i][0] = C[i][i] = 1; for(int j = 1; j &lt; i; j ++) C[i][j] = C[i-1][j] + C[i-1][j-1];//of course it's Pascal identity &#125;&#125; 其中组合数使用帕斯卡恒等式（终于用上了）进行递推，运算次数很少。矩阵用结构体封装，写起来很舒服，Matrix_mul和Matrix_pow_mod两个函数返回结构，效率不高，可以用引用参数代替。 看起来很难的递推（其实也很坑）：HOJ 2855 $S_n = \\sum_{k=0}^nF(n)C(n,k)$，其中$F(n)$是Fibonacci数列。 求解：则运用矩阵快速幂即可以很轻松解决。实现略。 类似题：HOJ 3658、HOJ 4565。 参考链接：http://blog.csdn.net/wust_zzwh/article/details/52058209","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"basic algorithms","slug":"basic-algorithms","permalink":"http://aojueliuyun.github.io/tags/basic-algorithms/"},{"name":"矩阵","slug":"矩阵","permalink":"http://aojueliuyun.github.io/tags/矩阵/"}]},{"title":"【离散数学】高级计数技术","slug":"2018.3.6--advanced-counting-technology","date":"2018-03-05T16:00:00.000Z","updated":"2018-06-24T10:01:06.902Z","comments":true,"path":"2018/03/06/2018.3.6--advanced-counting-technology/","link":"","permalink":"http://aojueliuyun.github.io/2018/03/06/2018.3.6--advanced-counting-technology/","excerpt":"这是离散数学的第四篇，讨论高级计数技术。上一篇（【离散数学】计数/排列组合）讨论了计数以及排列组合，二项式定理等。但是仅凭排列组合等手段依然无法解决许多计数问题。这里首先讨论通过递推关系来求解计数问题，并介绍有递推关系引出的两个算法范式：动态规划和分治。这两种算法均是通过将问题分割为一系列的子问题来求解的，区别就是前者分割出来的子问题互相重叠，后者的子问题不重叠。这是两种很重要的算法，加上贪心、回溯、分支定界为五种很常用的算法。这里仅仅简单讨论思路，并分析其复杂度。关于具体的算法分析以及算法设计以后应该会讨论。而后介绍了求解一类很常见的特定递推关系——常系数线性齐次与非齐次递推关系的形式解法。并且还介绍了一种求解计数问题的很重要的手段——生成函数，这是幂级数的应用。最后介绍容斥原理，对，就是集合的容斥原理。以上内容以前均有涉及，这里再次探讨。","text":"这是离散数学的第四篇，讨论高级计数技术。上一篇（【离散数学】计数/排列组合）讨论了计数以及排列组合，二项式定理等。但是仅凭排列组合等手段依然无法解决许多计数问题。这里首先讨论通过递推关系来求解计数问题，并介绍有递推关系引出的两个算法范式：动态规划和分治。这两种算法均是通过将问题分割为一系列的子问题来求解的，区别就是前者分割出来的子问题互相重叠，后者的子问题不重叠。这是两种很重要的算法，加上贪心、回溯、分支定界为五种很常用的算法。这里仅仅简单讨论思路，并分析其复杂度。关于具体的算法分析以及算法设计以后应该会讨论。而后介绍了求解一类很常见的特定递推关系——常系数线性齐次与非齐次递推关系的形式解法。并且还介绍了一种求解计数问题的很重要的手段——生成函数，这是幂级数的应用。最后介绍容斥原理，对，就是集合的容斥原理。以上内容以前均有涉及，这里再次探讨。 递推关系的应用经典问题——汉诺塔这是一个及其经典的问题，见汉诺塔（Tower of Hanoi），三根柱子，n个盘子，从上到下盘子从小到大。将所有n个盘子从一根柱子移动到另一根柱子，移动过程中小的盘子不能放在大的盘子下面。可以求解出所需要的最小步数，还可以编写算法打印出所有步数。n=3的汉诺塔移动方法： 令移动n个盘子到另一个柱子所需最少次数为 $ H_n $ ，考虑最下面一个最大的盘子，由于小的盘子不能放在大的盘子下面，所以必须首先将上面n-1个移动到另一个柱子，再将最下面的最大的一个移动到另一根柱子，再将n-1个移到其上，则完成了n个盘子的移动。则得到递推关系 $H_n = 2H_{n-1}+1$。初始条件很容易知道：$H_0 = 0$ ，$H_1=1$。 求解递推关系：容易看出 $H_n+1 = 2(H_{n-1}+1)$，可以得到 $H_n= 2^n-1$。可以证明这便是移动n个盘子所需的最少次数。 卡特兰数考虑一个在n+1个数 $x_0\\cdot x_1 \\cdot x_2 \\cdots x_n $ 的乘积中插入括号来规定乘法次序的方式数，令其为 $C_n$。这里注意到一定会有一个乘法是在括号外面的（不需要加括号），假设其在$x_k$和$x_{k+1}$之间，则存在$C_kC_{n-k-1}$种方式，考虑最后一个乘号可能取n个位置，则有C_n = \\sum_{k=0}^{n-1}C_kC_{n-k-1} 初始条件则为$C_0 = 1$，$C_1 = 1$。利用生成函数的方法可以证明：$C_n = \\dfrac{C(2n,n)}{n+1}$，被称作第n个卡特兰（Catalan）数，序列$\\{C_n\\}$ 被称为卡特兰数的序列。参见 OEIS A000108，Catalan number - Wikipedia。 动态规划与递推关系动态规划（Dynamic programming，DP）是一种算法范式，遵循动态规划范式的算法是将原问题分解为更简单的重叠的子问题，通过子问题的求解来求解原问题。常用于求解最短路线、库存管理、资源分配、设备更新、排序、装载等问题。此类问题若用分治法来解，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。所以DP通过保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，从而降低复杂度。以后单独讨论，这里推荐阅读：动态规划解决01背包问题，什么是动态规划？动态规划的意义是什么？。 求解线性递推关系这部分给人的感觉相当熟悉，在高等数学中有线性微分方程的求解，线性代数中有线性方程组的求解，与这里的线性递推关系的求解十分类似，可以说是如出一辙。 求解常系数线性齐次递推关系一个常系数的$k$阶线性齐次递推关系指的是形如 $a_n = c_1a_{n-1}+c_2a_{n-2}+\\cdots + c_ka_{n-k}$，的递推关系，其中$c_i$为实数，$c_k \\neq 0$。 为了求解$k$阶常系数线性齐次递推关系，这里的基本方法是寻找形如$a_n = r^n$的解，其中r是常数。递推关系要有形如$a_n = r^n$的解，则当且仅当$r$是方程r^k-c_1r^{k-1}-c_2r^{k-2}-\\cdots -c_{k-1}r-c_k=0的解。将上述方程称为该递推关系的特征方程。方程的解称为特征根。（与求解常系数线性微分方程如出一辙）。特征根有可能是复数，但这里仅考虑特征根为实数的情况。 定理：假设特征方程r^k-c_1r^{k-1}-\\cdots -c_k=0有k个不相等的根$r_1,r_2,…,r_k$。那么递推关系$a_n = c_1a_{n-1}+c_2a_{n-2}+\\cdots + c_ka_{n-k}$的解为a_n = \\alpha_1r_1^n+\\alpha_2r_2^n+\\cdots+\\alpha_kr_k^n $n\\in N,\\alpha_1,\\alpha_2,…,\\alpha_k$是常数。另外，对其中的每一个特征根$r_i$，如果并非一重而是$m_i$重时，则用 $(\\alpha_{i,0}+\\alpha_{i,1}n+\\cdots+\\alpha_{i,m_i-1}n^{m_i-1})r_i^n$ 替代 上述解中的$\\alpha_ir_i^n$即可。 例：斐波那契数列（OEIS A000045）递推关系$f_n = f_{n-1}+f_{n-2}$，初始条件$f_0 = 0,f_1=1$。特征方程$r^2-r-1=0$ 根为 $r_1 = (1+\\sqrt{5})/2$，$r_2 = (1-\\sqrt{5})/2$。则f_n = \\alpha_1\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n + \\alpha_2\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n代入$f_0,f_1$解出$\\alpha _1 = \\dfrac1{\\sqrt5}$，$\\alpha _2 = -\\dfrac1{\\sqrt5}$则得到斐波那契数列的显式公式为f_n = \\dfrac1{\\sqrt5}\\left(\\dfrac{1+\\sqrt5}{2}\\right)^n-\\dfrac1{\\sqrt5}\\left(\\dfrac{1-\\sqrt5}{2}\\right)^n 求解常系数线性非齐次递推关系常系数线性非齐次递推关系：形如 $a_n = c_1a_{n-1}+c_2a_{n-2}+\\cdots + c_ka_{n-k} +F(n)$，与其相伴的齐次递推关系为 $a_n = c_1a_{n-1}+c_2a_{n-2}+\\cdots + c_ka_{n-k}$，很显然 通解 = 特解+齐次解。 齐次解即对应的常系数线性齐次递推关系的解，记作$a_n^{(h)}$，特解记作$a_n^{(p)}$。 不同形式的F(n)具有不同形式的特解 $F(n)$ 特解形式 $an+b$ $cn+d$ $\\alpha\\cdot c^n$ $\\beta\\cdot c^n$ 若 $F(n)$ 形如 $(b_tn^t+b_{t-1}n^{t-1}+\\cdots+b_1n+b_0)s^n$.则当 $s$ 不是特征根时，特解形如 $(p_tn^t+p_{t-1}n^{t-1}+\\cdots+p_1n+p_0)s^n$.当 $s$ 是$m$重特征根时，特解形如 $n^m(p_tn^t+p_{t-1}n^{t-1}+\\cdots+p_1n+p_0)s^n$. 分治算法与递推关系与动态规划相似，分治算法（Divide and conquer algorithm）范式也会将问题划分为一个或者多个小问题，不过这些小问题是不重叠的。连续使用这种划分直到可以快速找到这些小问题的解，然后将小问题的解合并为原问题的解。即三个步骤：分割原问题，解决子问题，合并得到最终解。常见简单分治算法：归并排序、二分查找。这里将说明怎样用递关系来分析分治算法的复杂度。 分治递推关系假设一个递归算法将规模为n的问题划分为a个子问题，每个子问题规模为n/b，并且需要g(n)的额外运算来合并这些子问题。用f(n)表示求解问题规模为n的问题所需运算数，则f(n)= af(n/b)+g(n) 令$n = b^k$，多次迭代后可以得到： f(n)= a^kf(1)+\\sum_{j=0}^{k-1}a^jg(n/b^j)很容易知道，二分查找的分治递推关系：$f(n)=f(n/2)+2$归并排序的分治递推关系：$M(n)=2M(n/2)+n$ 分治算法的复杂度分析定理1：设$f(n)$是满足$f(n)=af(n/b)+c$ 的增函数，$n$被$b$整除，$a\\geqslant 1$，$b$是大于1的整数，$c$是正实数。那么 f(n) = \\begin{cases} O(n^{log_ba})&a>1\\\\O(\\log n)&a=1\\end{cases}$$证明：令$n=b^k$即可证得，当$n\\neq b^k$时，依然成立。 很容易得出二分查找复杂度为$O(\\log n)$。 **主定理**：若$f(n)=af(n/b)+cn^d$，则$$f(n) = \\begin{cases} O(n^d)&a0 \\\\1&k=0\\end{cases}当u为负整数时，展开即可有下列式子成立\\Big(^{-n}_k\\Big) = (-1)^rC(n+r-1,r) 广义二项式定理：$x$是实数，$|x|&lt;1$，$u$ 是实数，那么(1+x)^u=\\sum_{k=0}^{\\infty}\\Big(^u_k\\Big)x^k 其实这就是$(1+x)^u$的幂级数展开，使用麦克劳林级数（即在x=0处泰勒展开）即可证明。 常用生成函数这里给出一些最常用生成函数，以及其对应的序列一般项。 (1). $(1+ax)^n=\\sum_{k=0}^nC(n,k)a^kx^k$，$a_k=C(n,k)a^k$，二项式定理得到(2). $\\dfrac{1-x^{r+1}}{1-x}=\\sum_{k=0}^nx^k$，$a^k=1,k\\leqslant n$；否则为0，几何级数求和得到(3). $\\dfrac1{1-ax}=\\sum_{k=0}^{\\infty}a^kx^k$，$a_k=a^k$，对$|x|&lt;1$的几何级数求和取极限得到(4). $\\dfrac 1{(1-x)^2}=\\sum_{k=0}^{\\infty}(k+1)x^k$，$a_k=k+1$，对$\\dfrac1{1-x}$求导得到(5). $\\dfrac1{(1-x)^n}=\\sum_{k=0}^{\\infty}C(n+k-1,k)x^k$，$a_k=C(n+k-1,k)=C(n+k-1,n-1)$，由广义二项式定理得到(6). $e^x=\\sum_{k=0}^{\\infty}\\dfrac{x^k}{k!}$，$a_k=1/k!$，泰勒展开即可得到(7). $\\ln(1+x)=\\sum_{k=0}^{\\infty}\\dfrac{(-1)^{k+1}}{k}x^k$，$a_k={(-1)^{k+1}}/{k}$，同上泰勒展开得到 生成函数可以用来求解计数问题，还可以用来求解递推关系和证明组合恒等式。这里不想写了，略过吧！（笑） 容斥原理及其应用两个集合的容斥原理是很熟悉的，$|A\\cup B|=|A|+|B|-|A\\cap B|$，那么对于多个几个呢？很容易想到，但可能并不容易写出来。Inclusion–exclusion principle。 容斥原理设$A_1,A_2….,A_n$是有穷集，则|A_1\\cup A_2 \\cup \\cdots \\cup A_n|=\\sum_{1\\leqslant i \\leqslant n}|A_i|-\\sum_{1\\leqslant i< j \\leqslant n}|A_i\\cap A_j|\\\\ +\\sum_{1\\leqslant i","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://aojueliuyun.github.io/tags/离散数学/"},{"name":"组合数学","slug":"组合数学","permalink":"http://aojueliuyun.github.io/tags/组合数学/"},{"name":"计数","slug":"计数","permalink":"http://aojueliuyun.github.io/tags/计数/"},{"name":"分治","slug":"分治","permalink":"http://aojueliuyun.github.io/tags/分治/"},{"name":"生成函数","slug":"生成函数","permalink":"http://aojueliuyun.github.io/tags/生成函数/"},{"name":"容斥原理","slug":"容斥原理","permalink":"http://aojueliuyun.github.io/tags/容斥原理/"}]},{"title":"《三体》浮想","slug":"2018.2.27--three-body-book-review","date":"2018-02-26T16:00:00.000Z","updated":"2018-03-25T13:05:02.044Z","comments":true,"path":"2018/02/27/2018.2.27--three-body-book-review/","link":"","permalink":"http://aojueliuyun.github.io/2018/02/27/2018.2.27--three-body-book-review/","excerpt":"假期重刷了三体，体会到了很多第一次看时没有体会到的东西。无论是科幻小说还是电影，最触动我内心的两个情节就是：人类在宇宙尺度下显得多么地渺小、在巨大的时间尺度下的深深的无力感。与宇宙百亿年的历史相比，人类的文明史只不过是宇宙这片森林上的一棵小树上的一片叶子上的一颗小小的露珠，转瞬即逝。而相对论效应无疑可以称得上是无形的“上帝之手”，拨弄着时间的琴弦。当物体接近光速时，质量的无穷的放大是多么地有趣，不同参考系中感受到的时间流逝速度是那么地迥异。《星际穿越》中，在冬眠与狭义相对论的作用下，分隔多年之后，父亲还是那副容貌，而女儿却已从懵懂无知的小女孩变成了垂垂老矣躺在病床上的老人。对于我来说，这是极其震撼的。","text":"假期重刷了三体，体会到了很多第一次看时没有体会到的东西。无论是科幻小说还是电影，最触动我内心的两个情节就是：人类在宇宙尺度下显得多么地渺小、在巨大的时间尺度下的深深的无力感。与宇宙百亿年的历史相比，人类的文明史只不过是宇宙这片森林上的一棵小树上的一片叶子上的一颗小小的露珠，转瞬即逝。而相对论效应无疑可以称得上是无形的“上帝之手”，拨弄着时间的琴弦。当物体接近光速时，质量的无穷的放大是多么地有趣，不同参考系中感受到的时间流逝速度是那么地迥异。《星际穿越》中，在冬眠与狭义相对论的作用下，分隔多年之后，父亲还是那副容貌，而女儿却已从懵懂无知的小女孩变成了垂垂老矣躺在病床上的老人。对于我来说，这是极其震撼的。 细细想想，人类多少年来一直都在对世界一无所知的情况下生活着，这是极其可怕的。但无知者者无畏，也许正是对宏观的宇宙法则和微观的物理世界的不知甚解，使人类作为地球上唯一的智慧物种而变得自大、傲慢。所以大刘才说出了那句经典的话：弱小和无知不是生存的障碍，傲慢才是。所以太阳系毁灭了。 要说其中我最欣赏或者崇敬的人，一是章北海，二是托马斯维德。因为他们的理智，极端的理智，而极端的理智带来的就是极端的冷酷与疯狂。但最后他们都没有落得一个好下场，前者或许被充当了蛋白质来源，后者在万分之一秒内被气化。这当然是作者的意愿，但他们的下场并不是由于理智或者冷酷所造成的，相反是因为极端的冷酷中或许还保存了一丝人性（到底有没有就只有自己猜了），这丝人性使他们犹豫了。在小说的背景下，正如大刘借维德之口所说：失去人性，失去很多，失去兽性，失去一切。毫无疑问，在这个末世的背景下，决策者的一丝丝的仁慈最后都是在为人类掘墓，参考程心。当然程心既然是全人类的选择，这里该批判的就应该是所有人类。 《三体》的格局无疑是巨大的，第一次看时，有太多太多的情节、概念令人惊呼巧妙。无论是对费米悖论和暗物质的解释还是空间维度、透明思维的三体文明的描写，太多太多了，对读者的想象力也是一个挑战。这是一个跨越400年的人类文明史诗，展现了人类在末日来临时的挣扎与努力，更展现了人性的卑劣。 小说中，科学总是受到政治的影响，这两者是绝对不会独立存在的。末日即将来临，人类渴望得到科学的救赎时，政治是极力促进科学发展的。当科学的发展触动了人类文明最根源的道德底线时，科学是只能被打压的，尽管这种打压最终也许会葬送人类的未来。这也许在现实中也是有一些相似的，不了解便不妄加揣测了。 科幻文学毕竟并非真实，是用来启迪思考，为科技引路的。现实中也不是每一个人都适合去研究理论物理，都适合心系宇宙。闭上眼睛幻想一下，对宇宙、对灿烂的银河、对接触事物本质的科学、对一切未知保有一种敬畏就好了。","categories":[{"name":"文学与世界","slug":"文学与世界","permalink":"http://aojueliuyun.github.io/categories/文学与世界/"}],"tags":[{"name":"三体","slug":"三体","permalink":"http://aojueliuyun.github.io/tags/三体/"}]},{"title":"【离散数学】计数/排列组合","slug":"2018.2.10--counting-arrangement-&-combination","date":"2018-02-09T16:00:00.000Z","updated":"2018-06-24T10:54:32.016Z","comments":true,"path":"2018/02/10/2018.2.10--counting-arrangement-&-combination/","link":"","permalink":"http://aojueliuyun.github.io/2018/02/10/2018.2.10--counting-arrangement-&-combination/","excerpt":"离散数学第三篇，讨论基本的计数技术——排列组合及其推广。组合数学是离散数学的重要组成部分，这里比较简略，待到有时间详细学习组合数学后再讨论一些复杂一点的问题。那何为组合数学呢？组合数学（Combinatorics）是研究一定条件的组态的存在、计数以及构造的科学。直白说就是研究物体如何安排的科学。这里的组合数学是狭义的组合数学，广义的组合数学就是离散数学。因计算机科学的核心就是使用算法研究离散数据，所以组合数学在算法科学中具有重要地位。本文主要内容：基本计数原则、鸽巢原理、排列组合及其推广、二项式定理与恒等式以及生成排列组合的算法。","text":"离散数学第三篇，讨论基本的计数技术——排列组合及其推广。组合数学是离散数学的重要组成部分，这里比较简略，待到有时间详细学习组合数学后再讨论一些复杂一点的问题。那何为组合数学呢？组合数学（Combinatorics）是研究一定条件的组态的存在、计数以及构造的科学。直白说就是研究物体如何安排的科学。这里的组合数学是狭义的组合数学，广义的组合数学就是离散数学。因计算机科学的核心就是使用算法研究离散数据，所以组合数学在算法科学中具有重要地位。本文主要内容：基本计数原则、鸽巢原理、排列组合及其推广、二项式定理与恒等式以及生成排列组合的算法。 基本计数原则乘法原则如果一个任务被分解为相互独立的两个步骤，完成第一个步骤有 $n_1$ 种方法，第二个步骤有 $n_2$ 种方法，则完成整个过程方法数为$n_1\\cdot n_2$。推广到多个步骤就是$n_1\\cdot n_2\\cdot \\dots \\cdot n_k$，共k个步骤，$n_i$是第$i$个步骤的方法数。 用集合语言描述如下：$|A_1\\times A_2\\times \\dots \\times A_k|= |A_1|\\cdot |A_2|\\cdot\\dots \\cdot |A_k|$ 求和原则如果有两种独立的途径完成一项任务，第一种有 $n_1$ 种方法，第二种有 $n_2$ 种方法，则完成该任务共有$n_1+n_2$种方法。推广到多种途径就是 $n_1+ n_2+ \\dots + n_k$ 种方法。 也称为加法原则。用集合语言描述：$|A_1\\cup A_2\\cup \\dots \\cup A_k|= |A_1|+ |A_2|+\\dots + |A_k|$，其中$A_i\\cap A_j=\\varnothing$，对所有 $i$，$j$. 减法原则如果一个任务可以有两种途径完成，第一种有 $n_1$ 种方法，第二种有 $n_2$ 种方法，两种途径中有 $n_3$ 种方法是相同的。则完成该任务共有 $n_1+n_2-n_3$ 种方法。 集合语言描述：即是两个集合的容斥原理 $|A_1\\cup A_2| = |A_1|+|A_2|-|A_1\\cap A_2|$ 除法原则如果一个任务可以由 $n$ 种方法完成，而在这 $n$ 中方法中每一种完成的方式在 $n$ 种中正好有 $d$ 种与之对应（即在该问题的研究中可以看做一种方法），则完成该任务的方法数为 $n/d$。 这几个原则乃是计数最基础的原则，很好理解。 鸽巢原理鸽巢原理的通俗描述：如果鸽子比笼子多，那么一定有一个笼子里面至少有两只鸽子。 鸽巢原理描述：把 $k+1$ 个甚至更多物体放入 $k$ 个盒子，那么至少有一个盒子里面有两只甚至更多个物体。 推论：从 $k+1$ 个甚至更多个元素的集合到 $k$ 个元素的集合的函数 $f$ 一定不是一对一函数。 广义鸽巢原理描述：将 $N$ 个物体放入 $k$ 个盒子，那么至少有一个盒子里面有 $\\lceil N/k \\rceil$ 个物体。 应用定理：每个由 $n^2+1$ 个不同实数构成的序列都包含一个长度为 $n$ 的严格递增子序列或严格递减子序列。 上述定理可以使用广义鸽巢原理证明。 拉姆齐数（Ramsey number）：$R(m,n)$（其中$m,n\\geq 2$） 是这样一个数 $N$，使得在 $N$ 个人中有 $m$ 个人互相认识或 $n$ 个人互相不认识需要的最小人数 $N$。其中两个人要么互相认识，要么互相不认识。 拉姆齐定理（Ramsey theory）是组合学的一个重要组成部分，用来处理集合元素的子集分配问题。拉姆齐数也是图论中的重要函数之一。已知的拉姆齐数非常少，这包括 $R(2,n)=n$ (其中$n\\geq 2)$，$R(3,3)=6$，$R(4,4)=18$ 等。有一个关于拉姆齐数的笑话 想像有队外星人军队在地球降落，要求取得R(5,5)的值，否则便会毁灭地球。在这个情况，我们应该集中所有电脑和数学家尝试去找这个数值。若它们要求的是R(6,6)的值，我们要尝试毁灭这班外星人了。 形象的描述了寻找拉姆齐数的难度。我们只能知道很多拉姆齐数的上下界，包括著名的 $43\\leq R(5,5) \\leq 49$ 。 排列组合解决某些计数问题时，我们会发现可以通过找到特定大小集合中不用元素的排列的方法数来解决问题，其中元素的次序收到限制，即是排列问题（Arrangement）。而另一些问题可以通过找到从特定大小元素集合中选出特定数量元素的方法数来解决，即是组合问题（Combination）。这里详细阐述这两类问题。 排列从$n$个不同元素组成的集合中选出$r$个元素排成一列，即需要考虑排列的次序。这种有序安排称为$n$元素集合的r排列。排列的方法数记作$P(n,r)$（也记作 $A_n^r$ 或者 $P_n^r$），读作$n$元素集合的$r$排列数。 显然，$P(n,r)$ $\\;=n(n-1)(n-2)\\cdots(n-r+1)$ $=\\dfrac {n!}{(n-r)!}$则$n$元素集合的全排列为$P(n,n)=n!$ 组合从$n$个不同元素组成的集合中无序选出$r$个元素，即不需要考虑排列的次序。这些无序选取的元素构成该集合的子集，称为$n$元素的一个$r$组合。组合的方法数记作$C(n,r)$（或者$C_n^r$），读作$n$元素集合的$r$组合数。也记作$\\big(_r^n\\big )$，并且称为二项式系数。 显然，$C(n,r)$ $\\;=\\dfrac{n!}{r!\\ (n-r)!}$ $\\;=\\dfrac{P(n,r)}{P(r,r)}$ $\\;=\\dfrac{n(n-1)(n-2)\\cdots(n-r+1)}{r!}$ 显然有 C(n,r)=C(n,n-r) 和 P(n,r)=C(n,r)\\cdot P(r,r)基础不过多解释。 二项式定理与恒等式$n$ 元素集合的 $r$ 排列数常记作$\\big( ^n_r\\big)$，由于这些数出现在二项式幂$(a+b)^n$的展开式中作为系数，所以也称二项式系数。 二项式定理设$x$，$y$是变量，$n$是非负整数，那么(x+y)^n=\\sum_{j=0}^{n}\\Big(^n_j\\Big)x^{n-j}y^j这很容易理解，由二项式定理可以得到任何一个$(x+y)^n$的展开式。 一些推论： $\\sum_{k=0}^{n}\\Big(^n_k\\Big) = 2^n$，令$x=y=1$得到。 $\\sum_{k=0}^{n}(-1)^k\\Big(^n_k\\Big) = 0$，令$x=1$，$y=-1$得到。 $\\sum_{k=0}^{n}2^k\\Big(^n_k\\Big) = 3^n$，令$x=1$，$y=2$得到。 帕斯卡恒等式设 $n$ 和 $k$ 是满足 $n\\geq k$ 的正整数，则有$\\Big(^{n+1}_{k}\\Big )=\\Big(^{n}_{k-1}\\Big )+\\Big(^{n}_{k}\\Big )$. 证明：现从n+1个元素中取k个元素组成一个集合，将n+1个元素集合分为两部分，一个包含n个元素，一个包含1个元素。现要从n+1个集合中取出k个元素，则将有两种选择——包含这单独的一个元素与否，若包含，则只需要从n个元素中取出另外的k-1个，若不包含，则需从n个中取出全部k个，由加法原则有$\\big(^{n+1}_{k}\\big )=\\big(^{n}_{k-1}\\big )+\\big(^{n}_{k}\\big )$。 我们可以使用帕斯卡恒等式递归定义二项式系数。 帕斯卡三角形帕斯卡三角形的基础是帕斯卡恒等式，亦是著名的杨辉三角。如下: (^0_0)\\\\ (^1_0)\\quad(^1_1)\\\\ (^2_0)\\quad(^2_1)\\quad(^2_2)\\\\ (^3_0)\\quad(^3_1)\\quad(^3_2)\\quad(^3_2)\\\\ (^4_0)\\quad(^4_1)\\quad(^4_2)\\quad(^4_3)\\quad(^4_4)\\\\ (^5_0)\\quad(^5_1)\\quad(^5_2)\\quad(^5_3)\\quad(^5_4)\\quad(^5_5)\\\\ (^6_0)\\quad(^6_1)\\quad(^6_2)\\quad(^6_3)\\quad(^6_4)\\quad(^6_5)\\quad(^6_6)\\\\ \\dots计算出数值： 1\\\\1\\quad1\\\\1\\quad2\\quad1\\\\1\\quad3\\quad3\\quad1\\\\1\\quad4\\quad6\\quad4\\quad1\\\\1\\quad5\\quad10\\quad10\\quad5\\quad1\\\\1\\quad6\\quad15\\quad20\\quad15\\quad6\\quad1\\\\\\cdots在上述三角形中，用帕斯卡恒等式可以证明，每个二项式系数均等于该数其上一行左右两系数之和（左边或者右边没有数的可以看做是0），即每一行相邻两个系数相加就产生了下一行的这两个系数中间的二项式系数。 其他二项式系数恒等式范德蒙德恒等式：\\Big(^{m+n}_r\\Big)=\\sum_{k=0}^{r}\\Big( ^m_{r-k}\\Big)\\Big( ^n_{k}\\Big)证明方法：将m+n个元素的集合分为m个和n个元素的两个集合，从这两个集合中合取r个元素的方法数与从原来m+n个元素集合中取r个元素的方法数相等。 推论：令 $m=n$ 即可得到：$\\big( ^{2n}_{n}\\big) = \\sum_{k=0}^r\\big(^n_k\\big)^2$ 定理：$r$，$n$为非负整数，$r\\leq n$，那么\\Big(^{n+1}_{r+1}\\Big)=\\sum_{j=r}^n\\Big(^j_n\\Big) 证明：考虑包含r+1个1的n+1位01位串，最后一个1出现的位置可能是r+1，r+2，…，n+1位上，则其余的1则出现在前面。若最后一位在第j+1位上，则前面j位出现的r个1的位串数为$(^j_r)$，由加法法则即可证明上述恒等式。 多项式定理类比二项式定理，由排列组合与计数原则可以得到：多项式定理：如果n是正整数，则(x_1+x_2+\\cdots+x_m)^n=\\sum_{x_1+x_2+\\cdots+x_m=n}C(n;n_1,n_2,...,n_m)x_1^{n_1}x_2^{n_2}\\cdots x_n^{n_m}其中多项式系数$C(n;n_1,n_2,…,n_m)=\\dfrac{n!}{n_1!n_2!\\cdots n_m!}$ 证明：从$n$次幂中选出$n_1$次给$x_1$，$n_2$次给$x_2$，…，$n_m$给$x_m$即可，系数$C(n;n_1,n_2,…,n_m)=$$C(n,n_1)\\cdot C(n-n_1,n_2)\\dots C(n_m,n_m)$ 化简即可得到上述式子。 排列组合的推广单纯的排列与组合能解决的问题十分有限。因为排列与组合要求所有元素不同，而且不能重复选择一个元素。而某些问题中涉及重复选择与具有不可区分的元素的排列组合。这时需要对排列组合进行推广。我们还可以通过模拟把物体放入盒子的过程来解决许多问题，其中的物体可以是可分辨的与不可分辨的，盒子也可以是可分辨的与不可分辨的。 有重复的排列当元素允许重复时，由乘法法则很容易得到排列数。 定理：$n$ 个元素集合的允许重复的 $r$ 排列数是 $n^r$。 有重复的组合$n$ 个元素集合的允许重复的 $r$ 组合有$C(n+r-1,r)$$=C(n+r-1,n-1)$个。 证明：因为n个元素可以重复，我们可以将其等效为n个盒子，放入其中的元素不区分，并用n-1条隔板将其分隔。则n元素集合的允许重复的r组合数即是将选出r个元素放入n个盒子中，即用n-1个隔板将其隔开。则从n个元素中可重复地选r个即可等价为从隔板和物体构成的n+r-1个物体或者隔板的排列中选出r个物体或者选出n-1个隔板的位置。即是$C(n+r-1,r)$$=C(n+r-1,n-1)$。 允许重复与不允许的排列组合数： 类型 允许重复 公式 r 排列 否 $\\frac {n!}{(n-r)!}$ r 组合 否 $\\frac {n!}{r!\\,(n-r)!}$ r 排列 是 $n^r$ r 组合 是 $\\frac{(n+r-1)!}{r!\\,(n-1)!}$ 具有不可区分物体的排列设类型 $j$ 有 $n_j$ 个物体，$1\\leq j \\leq k$，$n_1+n_2+\\dots+n_k=n$，则 $n$ 个物体的不同排列数为\\dfrac {n!}{n_1!\\,n_2!\\,\\dots n_k!}即是从$n$个位置中选 $n_j$个来放类型$j$ 的物体，有：$C(n,n_1)\\cdot C(n-n_1,n_2)\\dots C(n_k,n_k)$$ = \\dfrac {n!}{n_1!\\,n_2!\\,\\dots n_k!}$ 把物体放入盒子的问题许多问题都可以等效为把物体放入盒子的问题。其中的物体可以是可分辨的与不可分辨的，盒子也可以是可分辨的与不可分辨的。其中如果盒子是可分辨的，则可以转化为前面的问题。如果盒子是不可分辨的，不管物体可不可分辨，都将没有闭公式，可以通过列举或者编程求解来解决此类为题。 可分辨的物体与可分辨的盒子把 $n$ 个可分辨的物体放入 $k$ 个可分辨的盒子使得 $n_i$个物体放入盒子 $i$ ($i=1,2,…,k$)的方法数为：\\dfrac {n!}{n_1!\\,n_2!\\,\\dots n_k!} 不可分辨的物体与可分辨的盒子把 $n$ 个不可分辨的物体放入 $k$ 个可分辨的盒子使得 $n_i$个物体放入盒子 $i$ ($i=1,2,…,k$)的方法数为：$C(n+k-1,n)$ 可以看到这即是 $k$ 个元素集合的可重复的 $n$排列数。 可分辨的物体与不可分辨的盒子这类问题求出公式比较复杂，列举可解决。这里略过。 不可分辨的物体与不可分辨的盒子列举同样可以解决，这里通过一个例子来说明。例：将6个物体放入4个盒子，有以下方式：65，14，23，34，1，13，2，12，2，23，1，1，12，2，1，1共9种方式。 将 $n$ 个不可分辨的物体放入 $k$ 个不可分辨的盒子等价于将 $n$ 写成 $k$ 个非递增正整数之和。其中的每一种方法，我们将其称作将正整数$n$划分成$k$个正整数的一个划分，用 $p_k(n)$ 来表示。则将 $n$ 个不可分辨的物体放入 $k$ 个不可分辨的盒子的方法数为 $p_k(n)$。对此，没有简单的公式来表示，略。 生成排列及组合的算法开学后补上。 参考资料：《离散数学及其应用》（本科教学版，Kenneth H.Rosen著，原书第七版）","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://aojueliuyun.github.io/tags/离散数学/"},{"name":"集合论","slug":"集合论","permalink":"http://aojueliuyun.github.io/tags/集合论/"},{"name":"组合数学","slug":"组合数学","permalink":"http://aojueliuyun.github.io/tags/组合数学/"},{"name":"计数","slug":"计数","permalink":"http://aojueliuyun.github.io/tags/计数/"},{"name":"排列组合","slug":"排列组合","permalink":"http://aojueliuyun.github.io/tags/排列组合/"}]},{"title":"【离散数学】基本结构——集合、函数、序列、矩阵","slug":"2018.2.4--set-funcion-sequence-matrix","date":"2018-02-03T16:00:00.000Z","updated":"2018-06-24T10:56:47.925Z","comments":true,"path":"2018/02/04/2018.2.4--set-funcion-sequence-matrix/","link":"","permalink":"http://aojueliuyun.github.io/2018/02/04/2018.2.4--set-funcion-sequence-matrix/","excerpt":"离散数学第二篇，首先讨论常用工具——集合，并讨论在集合基础之上的一系列结构：函数、序列、矩阵、关系等。所有内容在以前的知识体系中均有涉猎，此处是从集合的角度去考虑这些内容。我认为其中要数集合的基数这一小节中可数集和不可数集的部分最为抽象。这里仅仅涉及一些常用定义性质和精彩的证明。","text":"离散数学第二篇，首先讨论常用工具——集合，并讨论在集合基础之上的一系列结构：函数、序列、矩阵、关系等。所有内容在以前的知识体系中均有涉猎，此处是从集合的角度去考虑这些内容。我认为其中要数集合的基数这一小节中可数集和不可数集的部分最为抽象。这里仅仅涉及一些常用定义性质和精彩的证明。 首先，常用符号一览： 符号 含义 $LaTeX$(仅符号) $x\\in A$ x属于集合A \\in $x \\notin A$ x不属于集合A \\notin $ \\{a_1,a_2,a_3,\\dots,a_n\\}$ 集合的元素列表（列举法） - $ \\{x\\vert P(x)\\}$ 集合构造器记法（描述法） - $\\varnothing$ 空集 \\varnothing $A\\cap B$ A与B的交集 \\cap $A\\cup B$ A与B的交集 \\cup $\\overline C$ C的补集 \\overline $A-B$ A与B的差集 - $A\\oplus B$ A与B的对称差 \\oplus $P(S)$ 集合S的幂集 - $\\vert S\\vert$ 集合S的基数 - $S\\subseteq T$ S是T的子集 \\subseteq $S\\subset T$ S是T的真子集 \\subset $[a,b],(a,b)$ 区间 - $(a_1,a_2,a_3,\\dots,a_n)$ 有序n元组 - $A\\times B$ A和B的笛卡尔积 \\times $\\aleph_0$ 可数无限集的基数（阿里夫零） \\aleph $c$ 实数集的基数 - $f:A\\to B$ f是从A到B的函数 \\to $f^{-1}(x)$ 函数f的逆 - $f\\circ g$ 函数f和g的合成 \\circ $\\lfloor x\\rfloor$ 向下取整函数 \\lfloor \\rfloor $\\lceil x \\rceil$ 向上取整函数 \\lceil \\rceil $\\sum$ 累加 \\sum $\\prod$ 累乘 \\prod $A+B$ 矩阵A与B的和 - $AB$ 矩阵A与B的积 - $A^{-1}$ 可逆矩阵A的逆 - $A^T$ A的转置矩阵 - $I_n$ n阶单位阵 $A\\land B$ 0-1矩阵A与B的交 - $A\\lor B$ 0-1矩阵A与B的并 - $A\\odot B$ 0-1矩阵A与B的布尔积 - $A^{[n]}$ 0-1矩阵A的n次布尔幂 - 集合定义集合(set)是对象/元素的一个无序的聚集。 通过列举出集合的所有元素的方式来表示集合的方法称为花名册方法(或列举法)。如$\\{a,b,c,d\\}$。 描述集合的另一种方式是集合构造器方法(或描述法)，形如$A= \\{x| P(x)\\}$。其中$P(x)$是集合$A$中元素 $x$ 共有的特征。 常用集合$N$：自然数集$Z$：整数集$Z^+$：正整数集$Q$：有理数集$R$：实数集$R^+$：正实数集$C$：复数集 区间实数集的子集。$[a,b] = \\{x|a\\leqslant x \\leqslant b\\}$ ——闭区间$(a,b) = \\{x|a&lt; x &lt;b\\}$ ——开区间$(a,b] = \\{x|a&lt;x \\leqslant b\\}$$[a,b) = \\{x|a\\leqslant x &lt; b\\}$ 空集用$\\varnothing$符号表示，代表不含任何元素的集合。 朴素集合论这里主要讨论由德国数学家康托尔建立的朴素集合论。但朴素集合论是有缺陷的。 罗素悖论：将集合分为两类，一类以自身为元素，另一类不以自身为元素。令第一类所有集合为元素构成的集合为$P$，第二类所有集合为元素构成的集合为$Q$。那么问题来了，$Q\\in P$还是$Q\\notin P$ $?$若$Q\\in P$，则由第一类集合定义，必有$Q\\in Q$，而由第二类集合定义，如果$Q\\in Q$，则一定有$Q\\notin Q$，故矛盾。若$Q\\notin P$，则必定有$Q\\in Q$，则满足第一类集合定义，所以$Q\\in P$，故矛盾。 罗素悖论的一种通俗表示：只给不给自己刮脸的人刮脸的理发师究竟给不给自己刮脸呢？ 罗素悖论的提出动摇了数学的基础，这被称为第三次数学危机。后来公理集合论的出现成功化解了危机，通过提出几条公理避免了一系列的悖论。由于这里并不会涉及到如此抽象的讨论，所以使用朴素集合论并不会有影响。 集合关系子集：$A$是$B$的子集，记作$A\\subseteq B$ 当且仅当$\\forall x(x\\in A \\to x \\in B)$。真子集：$A$是$B$的真子集，记作$A\\subset B$ 当且仅当$\\forall x(x\\in A \\to x \\in B) \\land \\exists x(x\\in A \\land x\\notin B)$。 显然，$\\varnothing \\subseteq A$。$\\varnothing \\subset A$，其中$A\\neq \\varnothing$。 集合的大小集合 $S$ 中元素个数称为集合 $S$ 的基数（cardinality）,记作$|S|$。 注：这里的基数（cardinality）与计数中进制的基数（radix）明显不是一个概念。 无限集：一个集合的元素个数不是有限的则称为无限集。 幂集幂集（power set）：集合 $S$ 的所有子集作为元素构成的集合，记作 $P(S)$。幂集的基数$|P(S)| = 2^{|S|}$（根据二项式定理得出，二项式定理下一篇介绍）。 如：$P(\\{\\varnothing\\}) = \\{ \\varnothing ,\\{\\varnothing\\}\\}$。 集合运算交集：$A\\cap B = \\{x|x\\in A\\land x\\in B\\}$，可扩展到多个集合。并集：$A\\cup B = \\{x|x\\in A\\lor x\\in B\\}$，同样可扩展到多个集合。差集：$A-B = \\{x|x\\in A \\land x\\notin B\\}$。补集：$\\overline A = \\{ x|x\\in U \\land x\\notin A\\} = U-A$ ，其中$U$是全集，$\\overline A$称为$A$相对全集$U$的补集。则A与B差集$A-B = A\\cap \\overline B$。对称差：$A\\oplus B = \\{x|(x\\in A \\cup B)\\land (x\\notin A\\cap B)\\}$ $= (A\\cup B)-(A\\cap B)$ $= (A-B)\\cup (B-A)$，$A$与$B$的对称差，即只属于$A$、$B$其中一个集合的元素构成的集合。 笛卡尔积有序$n$元组：$n$个元素的有序聚集，记作$(a_1,a_2,a_3,\\dots,a_n)$。如二维的坐标$(x,y)$就是一个有序二元组。有序二元组亦称序偶。 集合的笛卡尔积：用$A\\times B$表示，$A\\times B = \\{(a,b)|a\\in A \\land b\\in B\\}$。 推广到多个集合：$A_1\\times A_2\\times \\dots \\times A_n $ $ = \\{(a_1,a_2,a_3,\\dots,a_n)|a_i\\in A_i, $$\\,i=1,2,\\dots,n\\}$。 笛卡尔积的一个子集$R$ 称为从集合$A$到集合$B$的关系（relation）。将在后面的文章中单独讨论。 集合恒等式集合的恒等律、支配律、幂等律等简单的略过。下面是三个重要的恒等式。分配律：$A\\cup (B\\cap C) = (A\\cap B) \\cup (A\\cap C)$$A\\cap (B\\cup C) = (A\\cup B) \\cap (A\\cup C)$ 德摩根律：$\\overline {A\\cap B} = \\overline A \\cup \\overline B$$\\overline {A\\cup B} = \\overline A \\cap \\overline B$同样可拓展到多个集合。 吸收律：$A\\cup (A\\cap B) = A$$A\\cap (A\\cup B) = A$ 可以看出集合恒等式与复合命题的逻辑等价式式是一一对应的，每个集合恒等式均可以由对应的逻辑等价式证明。 还可以看出集合的交并补运算，与数理逻辑的且或非运算，与布尔代数的与或非运算，与概率论中的和事件积事件互斥事件都有相似之处。其中数理逻辑的运算与布尔代数的逻辑运算是一一对应的，仅仅是表示不同而已（1和真，0和假）。而概率论中事件是可以按照集合的关系来理解的。这里可以看出数学的美妙之处（私以为）。 容斥原理 $|A\\cup B| = |A|+|B|-|A\\cap B|$，无须解释。 真值集给定谓词$P$与论域$D$，在$D$中使$P(x)$为真的$x$的集合定义为$P$的真值集。例如：谓词$P(x)$为“$x^2 = 2$”，则$P$的真值集为$\\{\\sqrt2,-\\sqrt2\\}$. 特殊集合多重集:一般情况下讨论的集合中所有元素均是互斥（不同）的。在多重集中同一个元素可以出现多次。相应的有交集、并集、差集、和集等运算。 模糊集合:在人工智能中经常使用模糊集合。全集中的元素在模糊集合中有一个隶属度（0~1之间），表示一个元素属于集合的程度。 函数定义$A$和$B$均为非空集合，为$A$中的每一个元素$a$都在$B$中由函数$f$指派一个唯一的元素$b$，使得$f(a)=b$。则称$f$是从A到B的函数（function），记作$f:A\\to B$。 函数也称映射（mapping）或者变换（transformation）。 其中：$f$的定义域（domain）：$A$$f$的陪域（codomain）：$B$$f$的值域（range）：$\\{b|b=f(a)\\}$，即$A$中元素所有像的集合。如果$f(a)=b$，则称 $b$ 是 $a$ 的像（image）， $a$ 为 $b$ 的原像（pre-image），我们说 $f$ 把 $A$ 映射到 $B$。 一般，将变量为实数的函数称为实变函数，自变量为复数则称复变函数。中学中多讨论实变函数，大学阶段有讨论复变函数。定义域为正整数集的子集的特殊函数也称为数列（中学阶段）。集合$A$可以是多个集合的笛卡尔积，则函数具有多个自变量。 函数三要素：定义域$A$，陪域$B$，关系$f$。当两个函数定义域、值域、关系均相同时，我们称两个函数相等。 陪域为实数集合的函数称实值函数，为整数集合称整数值函数。 一对一函数函数称为一对一函数（one-to-one）或者单射函数（injection），当且仅当 $\\forall a\\in A \\forall b\\in A(f(a)=f(b)\\to a=b)$。即是对定义域内所有不同的$a$，在$B$中一定对应不同的像。 函数增减性：对定义域$A$内所有$x$，$y$单调递增：$\\forall x \\forall y(x","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://aojueliuyun.github.io/tags/离散数学/"},{"name":"集合论","slug":"集合论","permalink":"http://aojueliuyun.github.io/tags/集合论/"},{"name":"函数","slug":"函数","permalink":"http://aojueliuyun.github.io/tags/函数/"},{"name":"序列","slug":"序列","permalink":"http://aojueliuyun.github.io/tags/序列/"},{"name":"矩阵","slug":"矩阵","permalink":"http://aojueliuyun.github.io/tags/矩阵/"}]},{"title":"【离散数学】逻辑与证明","slug":"2018.1.26--mathematical-logic","date":"2018-01-25T16:00:00.000Z","updated":"2018-03-02T05:00:16.762Z","comments":true,"path":"2018/01/26/2018.1.26--mathematical-logic/","link":"","permalink":"http://aojueliuyun.github.io/2018/01/26/2018.1.26--mathematical-logic/","excerpt":"离散数学是计算机专业很重要的基础课程，是后续数据结构，算法的基础。在学习数据结构的时候，接触到图论算法的时候，遇到了困难。于是决定回来学习离散数学。离散数学（课本）包括了数理逻辑、集合论、计数技术、关系、树、图和布尔代数等。每个章节都是数学与算法的基础，都接触过，但都没有太过深入。唯一一节算是深入了一点的应该就是布尔代数了，这在学习数字电路时是详细学习过的。所以我计划花费大概半个月时间看完《离散数学及其应用》（本科教学版，Kenneth H.Rosen著，原书第七版）。同时囫囵记上几篇笔记。 这是离散数学系列的第一篇，讨论命题逻辑与推理证明，其是数学中推理与证明的理论基础。理解数理逻辑（mathematical logic），领会并构造数学论证是学习目的。早在高中时便对数理逻辑有了简单的讨论，这里相较来说更为深入一点。包含命题逻辑、谓词与量词逻辑、推理和证明。对于比较简单的定义推理是省略的，详细资料请参考相关书籍。","text":"离散数学是计算机专业很重要的基础课程，是后续数据结构，算法的基础。在学习数据结构的时候，接触到图论算法的时候，遇到了困难。于是决定回来学习离散数学。离散数学（课本）包括了数理逻辑、集合论、计数技术、关系、树、图和布尔代数等。每个章节都是数学与算法的基础，都接触过，但都没有太过深入。唯一一节算是深入了一点的应该就是布尔代数了，这在学习数字电路时是详细学习过的。所以我计划花费大概半个月时间看完《离散数学及其应用》（本科教学版，Kenneth H.Rosen著，原书第七版）。同时囫囵记上几篇笔记。 这是离散数学系列的第一篇，讨论命题逻辑与推理证明，其是数学中推理与证明的理论基础。理解数理逻辑（mathematical logic），领会并构造数学论证是学习目的。早在高中时便对数理逻辑有了简单的讨论，这里相较来说更为深入一点。包含命题逻辑、谓词与量词逻辑、推理和证明。对于比较简单的定义推理是省略的，详细资料请参考相关书籍。 命题逻辑何为命题定义：命题是一个能判断真假的陈述句。 既然能判断真假，就意味着一个命题或者为真，或者为假，不能既真又假。例如：“地球是圆的”，“太阳系有八大行星”，“时间是静止的”，都是命题，其中前两个命题为真，后一个为假。 我们一般使用命题变元来表示命题，如$p$，$q$，$r$，$s$，$t$… 如果命题为真命题，则称其真值为真，记作$T$（即True）。反之，假记作$F$（即False）。 逻辑运算符写法、读法及真值如下表： 逻辑运算符 符号 意义 读法 真值 $LaTeX$语法 合取 $p\\land q$ $p$ 和 $q$ 的合取 $p$ 且 $q$ $p$、$q$ 同为真时为真，有一个为假则为假 \\land 析取 $p\\lor q$ $p$ 和 $q$ 的析取 $q$ 或 $q$ $p$、$q$ 同为假时为假，有一个为真则为真 \\lor 否定 $\\lnot p$ $p$ 的否定 非 $p$ $\\lnot q$ 与 $q$ 真值相反 \\lnot 异或 $p\\oplus q$ $p$ 和 $q$ 的异或 $p$ 异或 $q$ $p$、$q$ 真值相同为假，相异为真 \\oplus 条件命题 逻辑连接词 命题 含义（表达） 真值 $LaTeX$语法 $\\to$ $p\\to q$ $p$ 蕴含 $q$、如果 $p$，则 $q$ 、等 $p$ 真 $q$ 假时为假，其余情况为真 \\to 或 \\rightarrow $\\leftrightarrow$ $p\\leftrightarrow q$ $p$ 双向蕴含 $q$、$p$ 当且仅当 $q$、等 $p$、$q$ 真值相同为真，相异为假 \\leftrightarrow 命题语言是一种人工语言，并不以自然语言的用法为基础。数学中命题语言较自然语言范围更加宽泛。数学中的条件语句是一个数学概念，并不依赖于假设与结论之间的因果关系。 $p \\to q$ 表达的是 $p $ 能推出 $q$ 的含义，即是：$p$是$q$的充分条件。这是一个命题，真假待判断。同理，$p \\leftrightarrow q$ 表示 $p $ 是 $q$ 的充要条件。 由条件命题（$ p \\to q$）可以构造出一些新的条件命题，如它的逆命题（$q \\to p$），否命题（$\\lnot p \\to \\lnot q$），逆否命题（$\\lnot q \\to \\lnot p$）。 复合命题由逻辑连接词 $\\lnot$, $\\land$, $\\lor$, $\\to$ ,$\\leftrightarrow $ 连接的命题称为复合命题。符合命题的真值由复合命题中各命题变元所确定。 一个真值永远为真的复合命题称为永真式或重言式，恒为假则称为矛盾式。 逻辑连接词具有优先级 $\\lnot$, $\\land$, $\\lor$, $\\to$ ,$\\leftrightarrow $ 从左到右依次降低。 命题等价在所有情况下都有相同真值（真值表完全相同）的两个命题称为是逻辑等价的。 学习了双条件语句后，也可以如此定义：如果 $p\\leftrightarrow q$ 为永真式，则 $p$ 和 $q$ 称为逻辑等价的。记作 $p \\equiv q$ 或者 $p\\iff q$ 。 注意：其中 $\\equiv$ 并不是逻辑连接词，$p \\equiv q$ 不再是一个复合命题，而是表示 “$p\\leftrightarrow q$ 为永真式”。 以下为很多很重要的逻辑等价式，在化简证明中可以直接使用，其正确性都可以通过真值表来证明。并未完全列出。 逻辑运算符连接的逻辑等价式德摩根律$\\lnot (p \\land q) \\equiv \\lnot q \\lor \\lnot q$$\\lnot (p \\lor q) \\equiv \\lnot q \\land \\lnot q$德摩根律可以拓展到多个命题变元。 分配律$p \\lor (q \\land r) \\equiv (p \\lor q) \\land (p \\lor r)$$p \\land (q \\lor r) \\equiv (p \\land q) \\lor (p \\land r)$ 吸收律$p \\lor (p \\land q) \\equiv p$$p \\land (p \\lor q) \\equiv p$ 条件命题逻辑等价式$p \\to q \\equiv \\lnot p \\lor q$$p \\to q \\equiv \\lnot q \\to \\lnot q$（条件命题等价于其逆否命题） 双条件命题逻辑等价式$ p\\leftrightarrow q \\equiv (p \\to q )\\land (q \\to p)$ 量词逻辑谓词谓词：句子中代表主语属性的那一部分。 例如：可以用命题函数P(x)表示命题“x&gt;3”，其中x是变量，P则表示谓词“大于3”。 一般地，涉及n个变量的命题可以表示为 $P(x_1,x_2,…,x_n)$。$P$称为命题函数，或n元谓词。 量词一览 量化 全称量化 存在量化 量词 全称量词 $\\forall$ 存在量词 $\\exists $ 表示 $\\forall x P(x)$ $\\exists xP(x)$ 读作 对所有x，P(x) 存在x，P(x) 否定 $\\exists x \\lnot P(x)$ $\\forall x \\lnot P(x)$ 还有其他的量化，比如存在一个（恰有一个，唯一性量词$\\exists ! xP(x)$），存在几个等，这里主要考虑全称量化和存在量化。对应的命题称为全称命题和存在命题。 其中$x$的考虑范围称为论域。 优先级量词的优先级高于前面的所有逻辑运算符。 涉及量词的逻辑等价式$\\forall x(P(x) \\land Q(x)) \\equiv \\forall xP(x) \\land \\forall x Q(x)$$\\exists x(P(x) \\lor Q(x)) \\equiv \\exists xP(x) \\lor \\exists x Q(x)$这很容易理解，反之，全称量词对析取不可分配，存在量词对合取也是不可分配的。 量词的德摩根律：$\\lnot \\forall x P(x) \\equiv \\exists x \\lnot P(x)$$\\lnot \\exists xP(x) \\equiv \\forall x \\lnot P(x)$为什么这也叫德摩根律呢？当变量x的论域是离散数据的集合时，上述命题便可化为多个命题变元的德摩根律。 嵌套量词量词的嵌套量词可以嵌套。例如语句：“两个正整数之和一定是正数”。便可以表示为 $\\forall x&gt;0 \\forall y&gt;0(x+y&gt;0)$，或者$\\forall x \\forall y((x&gt;0)\\land(y&gt;0)\\to (x+y&gt;0))$，其中论域为整数。或者$\\forall x \\forall y(x+y&gt;0)$，其中论域为正整数。 可以看到，论域不同，表示也可以不同。 多重量化中，量词的顺序很重要，不同的顺序将表示不同的含义，除非全部是全称量词或者存在量词。 例子让我们回顾极限\\lim_{x\\to a}f(x) = L 的定义是：对任意实数 $\\epsilon &gt; 0 $，存在一个实数 $\\delta &gt; 0$，使得对任意的 $x$ ，只要有 $0&lt;|x-a|&lt;\\delta$，就有$0&lt;|f(x)-L|&lt;\\epsilon$.则使用嵌套量词可表示为：\\forall \\epsilon >0 \\ \\exists \\delta >0 \\forall x(0","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"数理逻辑","slug":"数理逻辑","permalink":"http://aojueliuyun.github.io/tags/数理逻辑/"},{"name":"离散数学","slug":"离散数学","permalink":"http://aojueliuyun.github.io/tags/离散数学/"}]},{"title":"2017，恍恍惚惚","slug":"2017.12.31--the-end-summary-of-2017","date":"2017-12-30T16:00:00.000Z","updated":"2018-01-18T09:41:13.269Z","comments":true,"path":"2017/12/31/2017.12.31--the-end-summary-of-2017/","link":"","permalink":"http://aojueliuyun.github.io/2017/12/31/2017.12.31--the-end-summary-of-2017/","excerpt":"我的2017，用“恍恍惚惚”四个字形容再贴切不过了，恍恍惚惚过完了一年，恍恍惚惚混到了大三，恍恍惚惚临近毕业。生命啊，恍恍惚惚就过去了，不是吗？ 说起2017上半年，实在是比较惭愧的，上半年开学之初就意识到了大二下应该是非常重要的一学期，几门重要的专业基础课数电、模电、信号都在这学期。开学时心里还想着这学期是打基础和厚积薄发的一学期，所以一定好好学。然而却荒废了一个学期，完全算得上是上大学以来最颓废的一学期了。最后以四门课60+水过，一门模电33分挂掉的成绩从此烙印在了我的悔恨簿上。甚至成为了我完全不想去回忆的一学期。","text":"我的2017，用“恍恍惚惚”四个字形容再贴切不过了，恍恍惚惚过完了一年，恍恍惚惚混到了大三，恍恍惚惚临近毕业。生命啊，恍恍惚惚就过去了，不是吗？ 说起2017上半年，实在是比较惭愧的，上半年开学之初就意识到了大二下应该是非常重要的一学期，几门重要的专业基础课数电、模电、信号都在这学期。开学时心里还想着这学期是打基础和厚积薄发的一学期，所以一定好好学。然而却荒废了一个学期，完全算得上是上大学以来最颓废的一学期了。最后以四门课60+水过，一门模电33分挂掉的成绩从此烙印在了我的悔恨簿上。甚至成为了我完全不想去回忆的一学期。LOL，DNF，王者荣耀，终究是太年少，心性不够成熟，没能抵挡住这些精神鸦片的侵蚀。现在装逼地觉得这些游戏辣鸡，嗤之以鼻，不屑去玩了。 对于我来说玩这些游戏最大的收获就是杀人时的快感、碾压时的喜悦，最后秀战绩的时候别人还能来点个赞的话就更有成就感了。带队友飞的时候可以潇洒的装一个B，被队友坑的时候可以愉快地骂上一波，坑队友的时候可以愉快地挂机，或者继续坑然后心想：你个辣鸡也不看看自己战绩，要不是我没有用拿手的英雄，早就带你们飞了。这种意淫还是比较舒服的。几个人开黑的时候想着我们几个也是一个集体/团队了，满足一下现实中融入不了集体，没有知心朋友的孤独。 玩游戏这件事每个人都有自己的看法，生活劳累之余消遣娱乐倒也无可厚非，问题是我从来就没有所谓地劳累过啊。拿着娱乐一下当借口，心性太幼稚，对游戏没有抵抗力才是事实的真相。快到期末的时候还被学工处两次晚上查到在玩游戏，被记了两次名字。最后被导员叫到办公室苦口婆心教育时心里还在想：反正我以后又不在这行找工作（不知道哪儿来的自信），这些课以后小爷分分钟补起来。然后电脑交给导员保管了两周，那时好像还想着这么长时间复习复习考试肯定能过（甚至还意淫着说不定能考个七八十什么的）。考完模电被虐得体无完肤的时候才知道什么叫做深深的绝望。 真不知道哪儿来的自信能以为没有学好的课程以后随便努力一下都能补起来。然后光明正大的翘课，自己给自己喂迷魂药，整天自我催眠，拖延症晚期无药可救。这就是大二下赤裸裸的事实真相。现在甚至都自我逃避不太愿意去回忆，想起来整个人都会打寒战。那时候活到那个地步，真的与咸鱼/死猪无异了。 那时天真地还自以为自己是有一定天赋的，不然怎么能考到这个学校？读了两年之后发现现实与想象的巨大落差，不知不觉产生了一种“辣鸡学校，辣鸡211不过如此”的想法，其实就是自己太渣、太懒、太怠惰，还有什么好说的。时常在心里调侃着自己就读于西北某不知名211，学校名字都不太愿意说出来，大概心底里脑补着像柳传志一样辍学然后创业成功变得老牛逼了之后，某一天回到学校校长亲自去迎接的场景。 大二下简直可以称作是失败的模板，纯粹的人生低潮了（而且还不自觉）。期间考驾照同时挂掉了科目二和科目三，可以说是非常怠惰了。买了六级的复习资料，以做完第一篇听力的水平参加了六级考试，结局可以很明显地预知到：当然没有过。那时还天真地抱着侥幸心理，万一就过了呢？那么多美剧不会白看是吧？甚至于大三上也没有好好复习六级，现在依然抱着侥幸心理，可以说真的是死猪不怕滚水烫了。 一方面痛恨着整天懒惰无所事事的自己，一方面有又不断自我催眠不想走出舒适区。在每天晚上上床之前带着悔恨与对自己的失望，觉得白天已经被自己浪费了，晚上一定要学一点什么才好，然后在床上刷上两个小时的知乎，看了两个小时的段子，又开始重复那个过程了，调上一个7点的闹钟，然而十点才醒来，十二点起床宣告着这一天生活的破灭，无限循环，陷入这日渐腐败的泥淖。慢慢地正在变成自己曾经无比鄙夷的形象，这就是真相吧。最可悲也莫过于此了吧。写到这里，我自己都忍不住唏嘘了，在激素水平变化的影响下开始变得情绪化，产生一种不想写下去的冲动。总之，悔恨，占据了我的身体和大脑。我开始只是想写一篇2017的总结和自我剖析罢了，没有必要把这些写出来吧。甚至在两个小时前我是不想这么写的，不想发到空间里去的，只是想潦草塞责一下，给2017一个交代罢了。可是一年的时光是两句话就能交代得了的吗？人的惰性和逃避还真是无处不在啊。这难道就是人类的本质吗？还是只是我的本质。大概只是我吧！ 人真的是一种很容易情绪化的动物啊。冷静了十分钟后，删掉了原先写的一部分关于2017中的人和事的东西。 以前高中的时候，学霸这个词还没有像现在这么被滥用，我也从来不敢称自己为学霸，因为我知道自己几斤几两，是个什么样子的水平，和那些真正的学霸的差距还有多大。那时偶尔会有一些同学会来问一些很基础的问题，然后我就会想：这些人上课不听讲的吗？都不看书的吗？理解能力有问题吗？这么简单的问题！他们到底想不想考大学了？ 现在我似乎明白了，作为一个学渣，对成绩好的同学总是有嫉妒的，自己不愿付出那么多努力，而且还总觉得我要是努力一下肯定也能达到这个程度，因为入学时我们都差不多啊！学霸读不懂学渣的世界，学渣也读不懂学霸的世界。而现在做了这么久的学渣，我似乎明白了一些，傲慢，自大，无知，对自己的无知不自觉，懒惰，拖延，浮躁，急功近利，做事得过且过、浅尝辄止，总是抱着侥幸心理…这些都是我活生生赤裸裸体验过的。我很理解这样混日子是一种什么样的感受——就像是一边正在被生活用小刀一片一片地削下自己的肉，一边不停地给自己打上麻醉药，让自己体会不到。 仔细想一想，上面的内容大多是极度情绪化的。冷静下来回想一下，自己现在的模样是许多年前的自己想成为的那个样子吗？不过当我尝试在大脑中搜索有关的内容时，大脑并没有给出答复，我也不记得自己当初到底有没有想过自己未来会是一个什么样子。毕竟年少时视野不够开阔，想象力不够丰富，也不会仔细地去想未来的事情。高中只是想大学一定要比高中更努力，至于怎么个努力法就无从谈起了。要真的有，那就是小时候人人都做过的当科学家的梦了吧，虽然不切实际，但在儿时也是一种激励啊。 最开始其实我只是想塞责一下发个朋友圈装装逼的，但发现写不下去自己不想说的话，就想着不发朋友圈了，写给自己吧！然而现在我想还是发个朋友圈共勉吧。 2017的下半年过得也并不如意，并没有达到自己期望中的要求，没有完成自己安排的任务。然而已经临近2018了。经历了大二下的颓废，马上到大三的暑假考完试后，我感到了极度的恐慌，一种即将挂科的恐慌，一种马上大三的恐慌，一种马上面临毕业、考研、找工作的恐慌，一种自己什么东西都不会却马上要踏入社会的恐慌。就像完全没有经过训练的新兵在大战将来前的心理（用烂了的比喻）。 于是我开始谋划着一次彻底的逃避。逃离这个专业，逃离这个学校。于是我决定考研，决定学编程，学数学，学算法，总之逃离这个领域就对了，搭了一个博客，胡乱抄写了几篇文章以慰藉自己的心灵。而一学期下来之后，兴趣倒是培养了一点点，但实际学习的效率堪忧。每周最大的事貌似变成了追番？对待事情浅尝辄止，目标完全不够清晰。一个学期了！买的书一本都没有看完！这是五个月前你想看到的自己吗？我想不是的。所以2018没有花哨的flag，没有一切不清晰的逻辑，也不能有浮躁的急功近利与浅尝辄止。安静读书就好。 过了今天，90后就集体成年了，我不知道时代将在什么时候赋予我们什么样的责任。我只知道在那之前，我必须变成我想成为的样子。 以上，写给自己，逻辑并不清晰，随便看看就好，祭奠2017，诸君共勉。","categories":[{"name":"流年浮事","slug":"流年浮事","permalink":"http://aojueliuyun.github.io/categories/流年浮事/"}],"tags":[]},{"title":"C++语法入门【3】C++函数特性","slug":"2017.12.23--C++started-feature-of-function","date":"2017-12-22T16:00:00.000Z","updated":"2018-01-30T12:51:34.484Z","comments":true,"path":"2017/12/23/2017.12.23--C++started-feature-of-function/","link":"","permalink":"http://aojueliuyun.github.io/2017/12/23/2017.12.23--C++started-feature-of-function/","excerpt":"C++函数具有一些C语言不具有的特性，内联函数、引用参数、const参数、const与引用返回值、默认参数、函数重载、函数模板等特性。承接上一篇C++语法入门【2】函数，这里介绍C++的函数特性。","text":"C++函数具有一些C语言不具有的特性，内联函数、引用参数、const参数、const与引用返回值、默认参数、函数重载、函数模板等特性。承接上一篇C++语法入门【2】函数，这里介绍C++的函数特性。 C++内联函数使用关键字inline定义，添加在函数声明或者定义前即可将函数声明为内联函数。 内联函数与常规函数的区别在于，常规函数在调用时程序会跳转到另一个地址（即函数的地址）执行指令，此过程中涉及到参数的传递、堆栈的使用、指令指针的跳转、寄存器状态的保存与恢复等。 而内联函数调用时编译器会用函数的代码替换函数调用。中间不会执行堆栈的压入与弹出等操作。提高了效率。 使用inline关键字使函数称为内联函数，但编译器不一定会满足这种要求。如果编译器认为函数过大或者函数调用了自身（内联函数不能递归调用），则不会将其作为内联函数。这因编译器而异。 内联定义：1inline double square(double x)&#123; return x *x;&#125; 在类中定义的成员函数将会自动成为内联函数。 引用类型C++增加了一种复合类型——引用变量。引用（reference）是已定义的变量的一个别名。顾名思义，别名只是换了一个名称而已，但数据是同一份数据。例如Hebe是田馥甄的别名一样，如果定义了Hebe是田馥甄的别名，那么这两个变量仍然表示同一个人。 引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用实参的原始数据，而不是其副本（拷贝）。 创建引用变量引用变量采用运算符 &amp; 来定义。例如：12int b = 2;int &amp; a = b; 则称a是b的引用（或者 a 是指向 b 的引用），a和b具有相同的值，相同的地址。改变a，b也将发生改变。称 a 的类型为int &amp;，即指向int变量的引用。 这里的&amp;不是以往的取地址运算符，这是一种运算符重载（以后介绍）。 C++语法规定引用变量在定义时必须被初始化。只定义不赋值的行为将会被编译器严厉驳回。 可以理解为给一个人取一个小名必须要有这个人，且在取这个小名的时候必须要声明是给谁取的，不能先取好了名字再叫一个人来说我给你取了一个小名，现在我要用你的小名叫你，这显然也是不会被同意的，That’s not how it works！这显然是很容易理解的。所以下列代码是错误的：1234int b;int &amp; a; //invalida = b; //invalidint &amp; c = 2; //also invalid 引用的内部实现引用的实现是采用指针实现的，例如：12int b = 1;int *a = b; 则可以知道变量 b 和变量 *a 具有相同的值，相同的地址（&amp;b 和 a 相同），改变无论哪一个另一个都会随之改变。这里就可以说 *a 是 b 的别名。 C++中引用是编译器通过指针实现的，但这个实现在语言层面对程序员做了透明化处理。 C++11中将引用分为左值引用和右值引用，貌似还分顶层引用和底层引用，暂时不是很理解，以后探讨。 再谈const前面有谈到过const变量，只能在定义时初始化，后面便不可再更改。这经常用在函数参数传递上，在按值传递中，形参并不影响实参。但在指针传递和引用传递中，如果我们不希望函数修改参数的值，则可以使用const参数，保证参数不被更改。而const与指针和引用会有一些微妙的关系。 const与指针const 与指针（pointer）可以有两种关系。一种是使指针指向常量数据，这样便不能通过指针来修改指向数据的值。如：1234int age = 20;const int *p = &amp;age; //const修饰*p，p指向常量，不能通过*p来改变age的值*p = 19; //invalid，将会报错age = 21; //但可以通过age来改变age的值 C++中，const变量的地址只能赋给指向const的指针。因为如果非const指针可以指向const变量，而又无意中通过该指针修改了const变量的值，无疑会将const置于无比尴尬的地位。12const int age = 19;int *p = &amp;age; //invalid,不能将const变量的地址赋给指向非const的指针 另一种是将指针本身声明为常量，即指针变量的值不可改变，即不能改变指针的指向。1234int age = 22;int * const p = &amp; age; //const修饰p，p的指向不可变int age2 = 30;p = &amp;age2; //invalid const与引用引用变量必须在定义时被初始化，且不可更改指向。所以如果将引用声明为const，则将不能通过该引用改变引用指向的变量的值。与指针类似，同样不能将const赋给非const引用。 引用最主要的作用是用作函数的形参。 函数的const与引用参数const参数在不需要修改形参的函数中，使用const形参将使函数不能在内部修改该形参的值。这可以防止无意间修改了参数值的编程错误。 在需要修改形参值的函数中，不能使用const。 引用参数前面提到，按值传递参数将会把实参复制给形参。形参的改变并不会影响到实参。 而按引用传递则不同，在引用传递中，形参将成为实参的引用，通过更改形参便可以更改实参的值。例如最经典的引用参数示例（交换两个变量的值）：123456void swap(int &amp;a,int &amp;b)&#123; int temp = a; a = b; b = temp;&#125; 使用引用传参的好处： 通过形参可以修改实参的值 形参和实参使用同一份数据，而不是实参的拷贝，提高了效率，节省了时间（这尽管在内置类型上体现不明显，但对于比较大的对象则可以显著提高效率） const引用参数使用引用传递时更改形参的值会改变实参。如果我们不希望这样做，则可以采用 const &amp; 参数，既可以提高效率，又不会使我们忽视无意间更改了参数的错误。 在对象参数的传递中，经常使用const &amp;参数。 例如（这里是结构）：123456789struct name&#123; string first_name; string last_name;&#125;;void show_name(const name &amp; n)&#123; cout &lt;&lt; n.first_name &lt;&lt; \" \" &lt;&lt; n.last_name &lt;&lt; endl;&#125; 在show_name()函数中使用 const &amp; 参数使得函数使用的是形参的数据，而又不能更改它。且提高了效率。 传参的一些指导性规则如果传递不做修改的参数： 如果参数很小，为内置类型或者小型结构，使用按值传递 传递数组，通过数组名，即是指针传递，并将指针声明为指向const的指针 传递大型结构，使用const指针或者const引用，以提高效率 传递类对象，通常要求使用const &amp; 对于传递需要更改带参数： 内置类型，使用指针或者引用 传递数组，只能使用指针 传递结构，使用指针或者引用 传递类对象，使用引用 这只是一般原则，亦可做出其他选择，根据需要传递合适的参数即可。 const与引用返回值与参数类似，返回值也可以由const修饰，也可以返回引用。 返回引用在C++中可以返回引用，但只能返回传递给函数的引用参数的引用。不能返回函数中的临时变量与局部变量的引用。因为局部变量在函数执行完后将会被释放，而指向已经释放的内存的引用将会产生错误。而传递给函数的引用参数不会被释放，所以只能返回传递给函数的引用参数。例如：12345int &amp; add(int a,int b,int &amp; sum)&#123; sum = a+b; return sum;&#125; 使用引用返回值有两个好处： 其一，与使用引用参数的目的相同，返回引用效率高于按值返回，这常用于类对象。但并不是返回对向就必须返回引用，在某些情况下也只能按值返回。这将在后面介绍。 其二，返回非const引用，将可以让我们对函数表达式执行操作。例如：1234567int a = 1;int b = 2;int sum = 0;add(a,b,sum) = 5; //等同于下面的两条语句，因为返回传入的引用参数sum的非`const`引用//add(a,b,sum)；//sum = 5;cout &lt;&lt; sum &lt;&lt; endl; //结果为5 返回引用在类的运算符重载中很常用。例如下面类中重载&lt;&lt;运算符的函数：1234567891011121314class name&#123; friend ostream &amp; operator&lt;&lt;(ostream &amp; out,const name &amp; _name) &#123; out &lt;&lt; _name.first_name &lt;&lt; \" \" &lt;&lt; _name.last_name ; return out; &#125;public: name(const string &amp; fn,const string &amp; ln): first_name(fn) ,last_name(ln)&#123; &#125; //类内实现，内联定义 ~name()&#123; &#125;private: string first_name; string last_name;&#125;; 上面友元函数返回 ostream &amp;使得可以进行下面的操作。12name Kim(\"Kim\",\"Possible\");cout &lt;&lt; Kim &lt;&lt; endl; 代码中cout &lt;&lt; Kim调用了ostream &amp; operator&lt;&lt;(ostream &amp; out,const name &amp; _name)函数，返回了cout对象，所以可以在后面接上&lt;&lt; endl继续调用 ostream 类中的重载运算符&lt;&lt;的函数。 返回const引用当希望返回引用而传入的参数为const &amp;时，则必须返回const &amp;，因为不能将常量（const修饰的变量）赋给非const引用。这时调用时将不能对函数表达式进行改变其值的操作。 某些情况下只希望提高效率，而禁止对传入的对象进行操作时（例如只打印出传入对象的成员而又希望返回对象使其能够一条语句调用多个打印函数），应该使用const &amp;参数与const &amp;返回值。例如：1234567891011121314151617181920class name&#123;public: name(const string &amp; fn,const string &amp; ln): first_name(fn) ,last_name(ln)&#123; &#125; //类内实现，内联定义 ~name()&#123; &#125; const name &amp; show_first_name() const &#123; cout &lt;&lt; first_name &lt;&lt; \" \"; return *this; &#125; const name &amp; show_last_name() const &#123; cout &lt;&lt; last_name &lt;&lt; endl; return *this; &#125; private: string first_name; string last_name;&#125;; 上面的成员函数const name &amp; show_first_name() const中返回了const name &amp;，末尾的const表示这是一个常成员函数，修饰*this。所以函数返回了传入了const &amp;。这里仅仅是一个示例，现实中我们可能并不会像上面这样使用。则我们可以向下面这样调用：12name Kim(\"Kim\",\"Possible\");Kim.show_first_name().show_last_name(); 将会打印出结果Kim Possible。 按值返回const并没有意义。与返回非const并没有区别。 默认参数C++函数允许函数有默认参数（default parameters）。即参数具有默认值。调用时就可以省略传入改参数，而使用默认参数。在函数原型中给参数赋值即可实现。 例如：1234void fun(int a=0) //此处函数定义在main()函数前，不需要原型，则直接将默认参数写在定义中&#123; cout &lt;&lt; a &lt;&lt; endl;&#125; 则可以不传入参数直接调用fun()，结果将打印出 0 。也可以传入参数如调用fun(2)，则将打印出结果 2 。传入的参数将覆盖默认参数。 默认参数必须从右向左添加。即是，如果某个参数有默认值，那么它右边的所有参数都必须有默认值。因为实参是按照从左往右的顺序依次赋给形参的。1void fun(double a,int b = 2,bool c = true); 则下列调用都是合法的：123fun(2.1);fun(2.0,1);fun(1.0,2,false); 默认参数在类中定义构造函数与析构函数时经常使用。某些时候，通过使用默认参数，可以减少定义构造函数、析构函数与重载方法的数量。 函数重载上面的默认参数使得我们可以使用不同数目的参数调用同一个函数。而函数重载也可以做到这一点，只不过函数重载后调用的不是同一个函数，而是不同的同名函数。 什么是函数重载C++还允许我们对函数进行重载（function overloading）。函数重载指的是我们能够定义多个同名的函数，对函数名称进行了重载。但是他们的参数列表不同。 这样我们可以设计一系列函数，他们的函数名相同，但是可以传入不同的参数。这样可以简化程序的设计，不同的参数、不同的函数，只要重载好了相应的函数，便可以使用同一个函数名调用。 函数重载的关键时函数的参数列表——也称函数特征标。C++通过函数参数列表来区分调用哪一个函数。例如：12345void print(int c); //#1void print(char ch); //#2void print(double d); //#3void print(int a,int b); //#4void print(const char * str); //#5 上述五个函数原型的特征表各不相同（必须参数类型、顺序和个数完全相同，特征标才相同）。使用函数print()时，函数将通过实参类型判断将要执行哪一个函数。12345print(1,2); //use #4print('q'); //use #2print(2.4); //use #3print(5); //use #1print(\"hello,world!\"); //use #5 函数匹配上面的调用都找到了参数与之匹配的函数原型，所以可以顺利执行。但如果所有函数原型都不与调用参数匹配，则编译器会尝试对参数进行标准强制类型转换。如果有多个函数都可以在转换后与之匹配，则将会调用最匹配的版本，如果编译器不能判断哪一个最匹配，则将会报错。例如：1print(1.2,3.0); //use #4 上面的调用并没有一个void print(double,double)原型与之匹配，但C++会将其进行强制类型转换，比如将double转换为int，char转换为int，int转换为double等。 一些看起来不同的参数类型会被认为是一样的。比如，编译器在检查函数特征表时，会将类型引用和类型本身视为同一特征标。例如有如下两个函数原型：12double square(double x);double square(double &amp; x); 则调用时会发生错误，将不能通过编译：1square(2.1); //编译器将不能分辨调用哪个函数 何时使用函数重载函数重载看起来非常好用，但也不应滥用，应当仅仅在函数执行相同任务，但使用不同类型的数据时才使用函数重载。 在类的设计中将经常使用运算符重载（一种特殊的函数重载）。 名称修饰我们不禁要问，C++如何区分这都些同名的函数呢？ 答案是，在编译时，C++编译器将会对这些同名但是特征标不同的函数进行一些操作——名称修饰或名称矫正，它会根据函数原型中的形参列表对每个函数名进行加密/编码。这样在编译得到的程序内部将会得到不一样的函数名，这样便可以区分这些函数。编码方法因编译器而异。 函数模板空时再补。 参考资料：C++ Primer Plus","categories":[{"name":"C++","slug":"C","permalink":"http://aojueliuyun.github.io/categories/C/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://aojueliuyun.github.io/tags/编程语言/"},{"name":"C++","slug":"C","permalink":"http://aojueliuyun.github.io/tags/C/"}]},{"title":"C++语法入门【2】函数","slug":"2017.12.8--C++started-function","date":"2017-12-07T16:00:00.000Z","updated":"2018-03-07T13:20:38.430Z","comments":true,"path":"2017/12/08/2017.12.8--C++started-function/","link":"","permalink":"http://aojueliuyun.github.io/2017/12/08/2017.12.8--C++started-function/","excerpt":"C++函数具有一些C语言不具有的特性，例如内联函数、引用参数、const参数、默认参数、函数重载、函数模板等特性。这些特性将在下一篇介绍。这里先介绍函数的基本知识。","text":"C++函数具有一些C语言不具有的特性，例如内联函数、引用参数、const参数、默认参数、函数重载、函数模板等特性。这些特性将在下一篇介绍。这里先介绍函数的基本知识。 函数 In C/C++函数何为函数，编程语言中的函数类似于数学的函数，但又不同于数学中的函数，Wikipedia（function）解释为根据某些规则将一个输入和一个唯一的输出联系起来的关系（a relation that associates an input to a single output according to some rules）。 而在编程语言中，函数毫无疑问是要为程序服务的。而程序的特点就是对特定的输入，能够给出我们想要的输出、完成我们想让它做到的事情。 我对函数的解释是：完成我们想让它做到的特定事件的代码块。 函数的特点在C/C++中，我们可以通过在定义函数来让它实现我们需要的功能。之后通过调用它来完成我们期望的工作。 函数的使用可以让程序的编写模块化，通过编写特定的程序模块，来简化程序的设计。 使用函数需要提供： 函数定义（实现） 函数原型（声明） 函数调用 函数声明（原型）：1type function(parameter_list); //单文件下通常放在main函数前，若将函数定义放在main函数前则无需声明 函数定义的一般格式：12345type function(parameter_list) //函数定义&#123; do something; return xxx;&#125; 函数调用时：1a = function(arguement_list); //a为type类型 例如一个求两个整数中较大的一个数的函数：1234int max(int a,int b)&#123; return a &gt; b ? a : b;&#125; 函数返回值可以为void，即无返回值。可以使用return不加返回值返回，也可不返回。有返回值的函数，函数提供一个返回值，使用return后加返回值实现。返回值可以为任何类型，内置类型或者结构与对象。 parameter_list为给函数提供的参数列表。包括参数类型和变量名。 函数原型在定义函数后必须在main函数前提供函数原型（亦称函数声明），也可以直接在mian函数前直接定义，则不需要函数声明。函数声明：1type function(parameter_list); //函数声明 函数原型可以只提供参数类型，而不必写出参数名。 函数调用函数调用时执行函数内部的操作。执行函数的操作之前。会进行参数传递和指令指针（IP）的跳转。通过堆栈实现。 调用函数的表达式的值为返回值。可以将其赋给一个同类型变量。 参数传递参数传递有多种方式，C++中有按值传递、指针传递、引用传递。 接受参数的变量称为形参（形式参数），传递给函数的参数为实参（实际参数）。 按值传递函数中的变量是私有的，持续时间仅在整个函数运行期间，作用域为变量定义之处到函数结束。函数调用时分配，函数调用结束后释放内存。称为局部变量。 如果参数为普通变量（不是指针、数组或者引用），则参数传递方式为按值传递。 如果是内置类型则按值传递时程序将实参的值复制给形参。如果是程序员自己定义的结构或者类对象按值传递时默认则是每个数据成员逐项复制。其中对象的传递将会调用类的复制构造函数，在没有显示重载构造函数的情况下，将会调用默认复制构造函数，即会逐项复制。关于类和对象的内容会在以后讨论。 函数调用后形参被释放，形参的改变不会影响到原来的实参。所以下面的函数不能实现两个值的交换：123456void swap(int a,int b)&#123; int temp = a; a = b; b = temp;&#125; 因为调用时实参复制给形参。调用完成后参数a,b所占的内存空间将被释放。并不会影响到实参。要实现上述功能，可以采用指针传递：123456void swap1(int *a,int *b) //传递的参数必须为指向变量的指针（变量的地址）&#123; int temp = *a; *a = *b; *b = *temp;&#125; 或者引用传递：123456void swap2(int &amp;a,int &amp;b) //后面介绍&#123; int temp = a; a = b; b = temp;&#125; 指针传递指针传递原理上来说也是按值传递，即将一个指针变量传递给形参，然后通过指针实现对指针指向变量的操作。 数组名也是地址，所以可以通过传递数组名改变数组元素的值。 函数返回值函数通过return 返回值；返回，其中返回值类型必须与函数定义中返回值类型相同，不同时将进行自动类型转换。不能转换时将会报错。 返回值亦可分为按值返回，返回指针与返回引用。 函数与不同类型的参数普通类型作为函数参数普通类型（内置类型）作为函数参数时，默认传递方式为按值传递。不能通过函数调用改变参数的值。 结构和对象作为参数结构和对象，如果是按值传递，则和普通类型一样。复制时结构和对象内部的数据成员每一项都被复制。 在C++中，结构和对象多用引用传递，引用传递效率更高，可以通过改变形参来改变实参。在不希望参数被改变时，可以使用const修饰，使其变为常引用，则不可通过函数内部改变变量的值。若此时在函数内部进行了改变函数参数的操作，编译器将会报错。 数组作为参数传递数组时，使用数组名。而数组名是地址，所以数组做为参数是指针传递。所以可以改变数组元素的值。例如冒泡排序：1234567891011121314151617void Bubble_Sort(int A[],int n)&#123; for(int i=0;i&lt;n;i++) &#123; for(int j=n-1;j&gt;i;j--) &#123; if(A[j]&lt;A[j-1]) swap(A[j],A[j-1]); &#125; &#125;&#125;void swap(int &amp;x,int &amp;y)&#123; int temp = x; x = y; y = temp;&#125; C风格字符串使用数组存储，所以传递方式同数组。 数组作为参数时形参也可以写作指针，例如将int A[]替换为int *A。因为数组名就是一个特殊的指针。 递归函数C和C++允许函数调用本身，这种功能称为递归。递归调用通过栈实现。 递归函数必须有结束递归的条件，设计递归函数时必须使其能够结束。否则调用链得不到终止会无限循环下去。 递归函数例：求n的阶乘：1234567int f(int n)&#123; if(n == 0) return 1; else return n*f(n-1);&#125; 其中递归结束条件为n为0时，返回1，则递归函数将逐级返回，最后返回调用的f(n) = n!。 函数指针函数在编译后就是一系列的指令，所以函数也有存放的地址，其地址就是存储其机器代码的内存的开始地址。既然这样，就可以用一个指针变量指向它。从而通过该指针来调用该函数。顾名思义称其为函数指针。 通过函数指针这种技术，通过将一个函数指针作为参数，就可以实现将一个函数传递给另一个函数。这在很多方面有应用，比如类的虚方法的实现等，属于比较深奥的东西。这里简单叙述，待到以后有机会有需求深入接触与学习之后，再详述。 参考资料：C++ Primer Plus","categories":[{"name":"C++","slug":"C","permalink":"http://aojueliuyun.github.io/categories/C/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://aojueliuyun.github.io/tags/编程语言/"},{"name":"C++","slug":"C","permalink":"http://aojueliuyun.github.io/tags/C/"}]},{"title":"C++语法入门【1】命名空间、数据类型","slug":"2017.11.9--C++started-namespace-datatype","date":"2017-11-08T16:00:00.000Z","updated":"2018-01-23T06:34:27.230Z","comments":true,"path":"2017/11/09/2017.11.9--C++started-namespace-datatype/","link":"","permalink":"http://aojueliuyun.github.io/2017/11/09/2017.11.9--C++started-namespace-datatype/","excerpt":"初始时学习C++总是觉得C++既然是C的超集，就应该是和C差不多，只是多了一个class而已，接触之后才发现还是too young too naive啊。就目前感受而言，C++和C是完全不同的东西，不仅仅是多了一个OOP而已。这一篇主要关于我最近在看C++时的一些感想和一些入门语法。只是自己学习时的一些理解，并不详细也并不完整。详细语法细节请参考相关书籍。 C++进阶之路（图片来自知乎）：","text":"初始时学习C++总是觉得C++既然是C的超集，就应该是和C差不多，只是多了一个class而已，接触之后才发现还是too young too naive啊。就目前感受而言，C++和C是完全不同的东西，不仅仅是多了一个OOP而已。这一篇主要关于我最近在看C++时的一些感想和一些入门语法。只是自己学习时的一些理解，并不详细也并不完整。详细语法细节请参考相关书籍。 C++进阶之路（图片来自知乎）： C++ Started目前仍然算是开始阶段，C++ Primer Plus 是还没有看完的。在写下了hello,world:1234567#include&lt;iostream&gt;using namespace std;int main(void)&#123; cout &lt;&lt; \"Hello,world!\" &lt;&lt; endl; return 0;&#125; 之后，又粗略了解的C++的class之后，我感觉自己掌握了世界。C++不过如此嘛，自信是有的。然而学习C++的 self-confidence 曲线早已预知了一切。（渺小的凡人！） 而我一直以来都是把C++当做 C with classes 来用的，不对，应该是 C with cin and cout，输入输出用cin和cout，简洁明了，再加上一个看起来无比牛B的iostream头文件，瞬间感觉自己也是懂C++的男人了。（滑稽） 而知乎上一位答主给出的C++学习阶段的等级，虽然我对C++并没有十分清醒的认识，但这个应该还是有一定参考性的。我认为自己是可以在第0级前徘徊的。而且会不会成为死在门前的小白鼠呢。 以上是对自己的吐槽以及学习方向的参考。以下是学习C++时自己的理解，特别基础的东西是略过的，写下来也没有多大价值，还是要以书籍为本。其中会包含一些C和C++的比较。 命名空间 namespaceC++标准库中的函数或者对象都是在命名空间std中定义的，所以我们要使用标准函数库中的函数或对象都要使用std来限定。1using namespace std; 也可以将要使用的函数或对象提前使用using声明，比如要使用cin和cout的话：12using std::cin;using std::cout; 也可以在使用时加上std::前缀，std::cin或者std::cout。 命名空间的细节下一次详述。 基本数据类型C++中基本数据类型和C一致。C++为了保持和C语言具有良好的兼容性，保留了很多C语言的特性（Zao Po）。 整型长度上来说有short、int、long (int)、long long (int)四种。长度分别为16bit,16或32bit,32bit,64bit。 从符号上来说有 unsigned 和 signed（缺省），即无符号和有符号。 浮点型float(32bit),double(64bit),long double(128)bit。同样有unsigned。 字符型char（8bit），unsigned char，宽字符型wchar_t。C++11新增 char16_t（16bit） 和 char32_t（32bit）。 bool类型true 和 false 两个取值。隐式转换：一切非0值转换为true，0转换为false。 const 常量const限定符修饰，不可变，不可赋值。用来取代C语言中的宏定义（定义符号常量时）。宏定义#define的本质是替换，在某些不严谨的编码中会产生问题，const则不会。然而宏定义在某些情况下（比如在头文件中）依然很常用。 在C++中，应该用以下代码来替代宏定义。1const Max_Size = 100; 取代：1#define Max_Size 100 运算符运算符的优先级关系需注意，不赘述。 初始化C++中将使用{ }来初始化叫做初始化列表（list-initialization）。初始化列表比直接赋值更加严格。 格式：1int a &#123;1&#125;; //a = 1 或者1int a = &#123;1&#125;； 如果在使用初始化列表时将double·类型赋给int型，在GCC编译器，ISOC++11标准下会报warning。 类型转换在表达式中会将低优先级的类型转换为高优先级的。大体上 long double &gt; double &gt; double &gt; long long &gt; long &gt; int &gt; short &gt; char , signed &gt; unsigned。（并不十分严谨，请查阅C++编译器校验表） 传递参数时形参实参类型不同也会自动转换。 强制类型转换C语言写法：1(typename) value C++标准写法：1typename (value) C++还引入了强制类型转换运算符，使用要求更为严格，更安全。如static_cast&lt;typename&gt; (value) auto声明C++11的auto关键字可以让你不用定义数据类型。如：123auto a = 1; //intauto b = 1.0; //duobleauto x = 1.3e14L; //long double 但实际上auto并不是这样来使用的。真正用法，例如C++98下的下列代码：12std::vector&lt;double&gt; scores;std::vector&lt;double&gt;::iterator itor = scores.begin(); 在C++11中完全可以写作：12std::vector&lt;double&gt; scores;auto itor = scores.begin(); 复合数据类型更新于2017.12.4。时间过得真快啊。 数组C中的数组数组声明格式1typename arrayname[arraysize]; 数组在内存中的存储是连续的，数组名被解释为指向数组第一个元素的指针，每个单元的大小就是typename的字节。不同于一般的指针变量，数组名不可被赋值。&amp;arrayname表示指向整个数组的指针，单元大小是整个数组大小。（arrayname和&amp;arrayname表示的地址相同但含义不同）。12345int A[4] = &#123;1,2,3,4&#125;;cout &lt;&lt; A &lt;&lt; endl;cout &lt;&lt; &amp;A &lt;&lt; endl; //A和&amp;A地址一致cout &lt;&lt; A+1 &lt;&lt; endl; //A+1地址比A大4个字节（64位windows中int类型大小为4字节）cout &lt;&lt; &amp;A+1 &lt;&lt; endl; //&amp;A+1地址比A大16个字节（&amp;A指向整个数组） 若在定义时由初始化列表初始化，可不指定数组大小。此时数组大小确立由编译器完成。例如：1int a[] = &#123;1,2,3,4&#125;; //数组大小为4 C99标准中支持变长数组（VLA，variable length array），C89并不支持，GCC编译器同时支持了C和C++的语法，支持这一特性。而在VC++因为使用C++的编译器（对C语言只支持到了C89）可能不支持。也就是说下列代码在GCC编译器向下是可执行的。 1234567int n;int A[n];cin &gt;&gt; n;for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; A[i];&#125; 突然想到大一时C语言老师按照C89标准讲的知识，数组长度必须是常数，然后用VC++6.0写C。无力吐槽。 C语言中的数组并不提供越界检查，也就是说数组下标管理需要程序员来完成。数组下标越界属于未定义行为，在不同机器，不同编译器环境下可能出现不同结果。一般情况下可能出现程序能编译但运行时会崩溃。 在C/C++数组中，A[i]完全等价于*(A+i)，所以说存在下列有趣的现象。这在C语言/C++中是完全正确的语法，一定程度上来说并不安全，所以C++提供了可以代替数组的更安全的类。1234for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; i[A]; //等价于*(i+A),即*(A+i)&#125; C++中数组的替代C++提供了两个类来替代数组，array类(C++11)和vector类。本质上来说是对数组的封装，比C风格的数组更安全。array对象长度不可变，需包含头文件array，声明格式：1array&lt;typename,arraysize&gt; arr; //arraysize不能是变量 vector对象长度可变，并且在运行时可以改变长度，需包含头文件vector，声明格式：1vector&lt;typename&gt; vec(n); //n可以是整型变量或常量 array类和vector类可以通过和数组相同的访问方式——即[ ]运算符访问。由于vector类长度可变，所以array类性能高于vector类。 字符串C风格字符串C语言中用char数组表示字符串，字符串以空字符&#39;\\0&#39;结尾，不以&#39;\\0&#39;结尾的char数组不是字符串。对C风格字符串的操作结束标志都是&#39;\\0&#39;。与普通数组相同，字符串名称指向字符串的第一个字符地址（字符串首地址）。初始化：1char str[] = \"hello,world!\"; 则字符串长度为12，但字符数组大小为13，初始化时编译器会在末尾自动填’\\0’。C中库string.h，C++中cstring库（C中的标准库在C++中都加上了前缀c且不带后缀.h，如math.h变为cmath，string.h变为cstring）提供了一系列C风格字符串的操作。如求串长的strlen()，比较两个字符串的strcmp()，拷贝字符串的strcpy()，拼接字符串的strcat()等。 对于定义时初始化的字符串，字符串求串长的函数strlen()求得的是字符串长度，而用sizeof()方法求得的尺寸要包含末尾的&#39;\\0&#39;，既有sizeof(str) = strlen(str)+1。 在C++中，字符串常量同样是用字符串首地址来表示。比如可以通过如下方式来打印字符串第一个字符。12cout &lt;&lt; *\"hello\"; //打印结果为hcout &lt;&lt; \"world\"[2]; //打印结果为l C++中提供字符串按行输入方法cin.getline(str,len)，则字符串最长长度为len-1。 C++中的string类C++中提供的string类来更好的表示字符串，string对象无固定长度，可直接赋值，可使用[]运算符访问字符，提供了一系列处理字符串的方法。例如length()/size()方法求串长，可直接用+运算符拼接两个字符串，可直接使用==判断字符串相等/或者使用compare()方法,etc. 例如：1string str = \"hello,world!\"; string类同样有按行输入方法getline(cin,str)。 这里简要说明，以后会有标准模板库的详细介绍。 指针与自由存储空间指针（pointer）指针变量的定义使用运算符*，指针变量保存的内容是地址。定义格式如下。1typename *pointer; //则pointer是一个指向typename类型的指针 例如指向int类型的指针的意思是指针变量中存放着一个int变量的地址。通过取地址运算符&amp;可以将int类型变量的地址赋给指针，解除引用运算符*（或者说取内容）可以取出指针变量的地址指向的变量。123456int a = 1;int *p = &amp;a; //定义时初始化，指针变量p的值即为a的地址//p = &amp;a; //定以后初始化，与上面等价 cout &lt;&lt; *p &lt;&lt; endl; //*p等价于a，即会打印出1cout &lt;&lt; p &lt;&lt; endl; //打印指针变量保存的地址，即是&amp;a，格式为一个十六进制数cout &lt;&lt; &amp;a &lt;&lt; endl; //与p内容相同 对于上述指针变量p，我们称其类型为 int *类型，即指向int的指针。但是在同时定义多个指针变量时，需要在每一个指针前加上*。1int * b,c; //定义了一个指向int的指针b，和一个int型变量c 指针变量在定义时即被分配内存，但是计算机并不会分配指针所指向数据的内存，所以指针必须先初始化为一个变量的地址才可使用。所以以下代码是错误的，尽管编译器可能并不会报错，但很可能会崩溃。如果p指向内存中系统部分内存，则有可能造成系统崩溃。12int *p; //未初始化，初值随机*p = 20; //不能这样操作,将20存放在了一个未知的地址，将造成错误 上述指针是指向基础类型的，指针还可以指向对象、结构、或者指针。 自动存储（栈中分配）在函数内部（包括main函数）定义的变量称为局部变量。程序运行时局部变量在栈（stack）中分配，当程序离开变量所属代码块后便被释放（出栈）。局部变量的作用域为所属代码块，即用{ }括起来的部分。 静态存储全局变量或者用关键字static修饰的静态变量存储方式为静态存储，其在整个程序执行期间都存在。其中全局变量（在函数外定义）在整个程序中都可以使用。静态变量如果在局部代码块中定义，则为静态局部变量，则在整个程序执行期间都存在，但只能在该代码块中使用。 动态存储（堆中分配）在C++中，可以通过new运算符在堆（heap，或称为自由存储空间）上分配内存。这种存储方式成为动态存储。对应的释放所分配的内存的运算符为delete。123456int *p = new int; //申请一个int大小的内存int *pn = new int[Size]; //申请一块内存，大小为sizeof(int)*Sizedelete p; //释放内存delete [] pn; //释放内存块p = NULL; //释放内存后为避免以后再使用到该指针时造成错误应将指针置为空（NULL）pn = NULL; 申请了内存后便可使用指针访问，申请的内存块也叫作动态数组，可以通过数组的方式访问。 在C语言中使用malloc和free函数来申请和释放内存。格式如下：1234int *p = (int *)malloc(sizeof(int)); //使用(int *)强制类型转换将所分配到的内存块地址转换为int *类型int *pn = (int *)malloc(sizeof(int)*Size); //分配内存块大小作为参数传入malloc函数free(p); //释放方式相同free(pn); 结构体使用struct关键字定义，是OOP（面向对象）思想的基础【类是面向对象的基础，而结构体是类的基础】。结构（体）是对不同数据的封装。结构可以将任意类型任意数目的数据封装为一种数据类型。然后利用结构创建变量，通过这个变量即可调用它的数据成员。例如：1234567struct people&#123; string name; int age; double height; bool is_male;&#125;; 这里定义了一个people（人）的结构，包含人的四个属性：姓名、年龄、身高、性别。使用people结构创建了变量之后，便可以对其赋值，可以用.运算符调用其数据成员，如果有一个指向结构的指针，可以通过-&gt;算符来调用其指向的结构的数据成员。例如：1234567891011121314people Jim = &#123;\"Jim\",18,178.5,true&#125;; //可以使用初始化列表按顺序对其数据成员赋值cout &lt;&lt; \"name: \" &lt;&lt; Jim.name &lt;&lt; endl; //使用.运算符调用其数据成员cout &lt;&lt; \"age: \" &lt;&lt; Jim.age &lt;&lt; endl;cout &lt;&lt; \"height: \" &lt;&lt; Jim.height &lt;&lt; endl;cout &lt;&lt; \"gender: \" &lt;&lt; (Jim.is_male?\"boy\":\"girl\")&lt;&lt; endl;people *p_kim = new people; //动态分配 *p_kim = &#123;\"Kim\",20,165,false&#125;; cout &lt;&lt; \"name: \" &lt;&lt; p_kim-&gt;name &lt;&lt; endl; //还用-&gt;运算符调用p_kim指向的结构的数据成员cout &lt;&lt; \"age: \" &lt;&lt; p_kim-&gt;age &lt;&lt; endl;cout &lt;&lt; \"height: \" &lt;&lt; p_kim-&gt;height &lt;&lt; endl;cout &lt;&lt; \"gender: \" &lt;&lt; (p_kim-&gt;is_male?\"boy\":\"girl\")&lt;&lt; endl;delete p_kim;p_kim = NULL; 结构可以像基本数据类型那样相互赋值，或者作为函数的参数或者返回值。1people the_2nd_Jim = Jim; //赋值时对应所有数据项全部被拷贝 共用体公用体是一种数据格式，能够存储不同数据类型，但同时只能一种类型。节省了内存。可用在C语言/C++编写嵌入式程序。使用union关键字定义，定义格式类似于结构，这里不赘述。 枚举C++中可使用enum关键字创建符号常量，某些情况下这种方式可以替代const。如果按如下语句：1enum color&#123;red,green,blue,yellow,orange&#125;; 则color成为一种新数据类型的名称，即枚举。所以可以通过强类型转换将一个枚举中存在的整数转换为一个枚举量。默认情况下上面五个表示颜色的符号常量会被赋予相对应的整数值0~5，也可以被显式地赋予一个整数。从前往后，每个符号常量的值会依次增大1。 参考资料：C++ Primer Plus","categories":[{"name":"C++","slug":"C","permalink":"http://aojueliuyun.github.io/categories/C/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://aojueliuyun.github.io/tags/编程语言/"},{"name":"C++","slug":"C","permalink":"http://aojueliuyun.github.io/tags/C/"}]},{"title":"常识性算法一弹","slug":"2017.11.7--a-few-very-simple-algorithms","date":"2017-11-06T16:00:00.000Z","updated":"2018-03-14T08:00:11.620Z","comments":true,"path":"2017/11/07/2017.11.7--a-few-very-simple-algorithms/","link":"","permalink":"http://aojueliuyun.github.io/2017/11/07/2017.11.7--a-few-very-simple-algorithms/","excerpt":"刚开始学习算法，做一些题的时候，总会发现一些特别基础的可以说是常识性的东西自己没有掌握，写代码完全是靠模拟（意淫）。这些算法一般不涉及到数据结构，只是一些很基础的简单问题，是解决某些问题的一个步骤。所以是时候总结（积累）一波了，遇到一个加一个进来。适时再把这篇笔记发到博客。","text":"刚开始学习算法，做一些题的时候，总会发现一些特别基础的可以说是常识性的东西自己没有掌握，写代码完全是靠模拟（意淫）。这些算法一般不涉及到数据结构，只是一些很基础的简单问题，是解决某些问题的一个步骤。所以是时候总结（积累）一波了，遇到一个加一个进来。适时再把这篇笔记发到博客。 常识性的算法这里介绍几个常识性的算法，偶然遇到，相当基础。 求最大公约数这是一个经典的问题。可以说小学老师就已经手把手教过了。高中还学了辗转相除法和更相减损术。 其中辗转相除法（也称欧几里得算法）和更相减损术从原理上来说是一样的。主要区别就是使用算术不同（一个使用除法，一个使用减法），和结束条件不同（前者是以相除余数为0则得到，后者则以减数与差相等而得到）。 例题：XDOJ 1061: A+B of lw 暴力查找12345678910111213int gcd(int a,int b) //greatest common divisor&#123; int i,max; int min_ab = a&lt;b?a:b; for(i=1;i&lt;=min_ab;i++) &#123; if(a%i==0 &amp;&amp; b%i==0) &#123; max = i; &#125; &#125; return max;&#125; 辗转相除法使用递归实现（最简单，建议使用）：1234int gcd(int a,int b)&#123; return b==0 ? a : gcd(b,a%b);&#125; 使用循环实现：1234567891011int gcd(int a,int b)&#123; int temp; while(b != 0) &#123; temp = a; //必须先设置一个变量保存a，不然a就被覆盖了，这么基础想了半天（汗颜） a = b; b = temp%b; &#125; return a;&#125; 更相减损术1234567891011int gcd(int a,int b)&#123; while(a != b) &#123; if(a&gt;b) a = a-b; else b = b-a; &#125; return a;&#125; 例题代码1234567891011121314151617181920212223242526//XDOJ 1061 --2017.11.5#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;int gcd(int a,int b);int main(void)&#123; int a,b,c,d; int e,f; int i; while(scanf(\"%d/%d %d/%d\",&amp;a,&amp;b,&amp;c,&amp;d) != EOF) &#123; e = a*d+c*b; f = b*d; int i; int max = gcd(e,f); e = e/max; f = f/max; printf(\"%d/%d\\n\",e,f); &#125; return 0;&#125;int gcd(int a,int b)&#123; return b==0 ? a : gcd(b,a%b);&#125; 快速幂取模问题描述：求形如 $n^m \\%d$的问题。（%为求余mod） 当n&gt;1，m很大时，$n^m$可能超过最大数据范围（C/C++中），所以暴力求不可取。 模板题：XDOJ 1026: 修理OJ 普通求法思路：$n^m\\%d = (n\\%d)^m\\%d$ 或 ${(a\\ast b)}\\%d$ $=$ $({(a\\%d)}\\ast (b\\%d))\\%d$ 时间复杂度$O(m)$。 实现：12345678910int Power_Mod(int n,int m,int d)&#123; int ans = 1; n = n%d; for(int j=0;j&lt;m;j++) &#123; ans = (ans*n)%d; &#125; return ans;&#125; 快速幂思路（原理）：$ n^m\\%d = \\begin{cases} {(n^2)^{(m/2)}\\,\\%d\\qquad}&amp; \\text {$m是偶数$} \\\\{((n^2)^{(m/2)}*n)\\,\\%d} \\qquad &amp; \\text{$m是奇数$} \\end{cases} $ 上述公式只在高级编程语言中对整数m满足 $m/2 = \\lfloor\\ m/2\\rfloor$的情况下才成立。 时间复杂度$O(log_2m)$。 实现：123456789101112131415int Quick_Power_Mod(int n,int m,int d)&#123; int ans = 1; n = n%d; while(m &gt; 0) &#123; if(m%2 == 1) &#123; ans = (ans * n) % d; &#125; m = m/2; n = (n*n)%d; &#125; return ans;&#125; 求$n^m$的最高位和最低位例题：XDOJ 1029: 数一的逆袭 最高位思路：$x=n^m=10^{mlgn}$，而10的整数次方首位一定为1，所以x的首位取决于 $mlgn$ 的小数部分，而 x的小数部分$k= mlgn - \\lfloor\\ mlgn\\rfloor$。则x的最高位 $= \\lfloor\\ 10^k\\rfloor$。（记得注意精度） c++中采用floor函数即可实现向下取整，或者把浮点型数据强制类型转换为int即可。 实现：123456int Top_digit(double n,double m)&#123; double x = m*log10(n); double k = x-(int)x; return (int)(pow(10,k)+0.000001);&#125; //需包含头文件cmath 最低位求最高位时n和m都可以是浮点数，但如果求最低位，则必须要求n和m都是整型。 对于一个确定的整数n，其m次方的最后一位一定是循环的，而最后一位仅仅与n的最后一位（仅0~9这10个数）相关。 如n=2时，最低位为2，4，8，6循环当n=3时，最低位为3，9，7，1循环 如果预先存储了底数最低位为0~9的结果最低位及周期，则可以在O(1)的时间内找到最低位。 例如对于确定的n=2：123456int b[4] = &#123;2,4,8,6&#125;; //全局数组int loest_order(int m)&#123; t1 = (m-1)%4; return b[t1];&#125; 如果n不确定（作为输入），则最低位 $= n^m \\%10$，运用快速幂算法即可解决。1234int Lowest_digit(int n,int m)&#123; return Quick_Power_Mod(n,m,10);&#125; 例题实现123456789101112131415161718192021222324//XDOJ 1029 --2017.11.7#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;cmath&gt;using namespace std;int main(void)&#123; int T; cin &gt;&gt; T; int b[4] = &#123;2,4,8,6&#125;; int n,t1,max,min; //max最高位，min最低位 double x,k; while(T--) &#123; cin &gt;&gt; n; t1 = (n-1)%4; x = n*log10(2.0); k = x-(int)x; max = (int)(pow(10,k)+0.000001); min = b[t1]; cout &lt;&lt; max &lt;&lt; \" \" &lt;&lt; min &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"basic algorithms","slug":"basic-algorithms","permalink":"http://aojueliuyun.github.io/tags/basic-algorithms/"}]},{"title":"基本数据结构——堆","slug":"2017.11.1--heap","date":"2017-10-31T16:00:00.000Z","updated":"2018-03-24T03:01:29.153Z","comments":true,"path":"2017/11/01/2017.11.1--heap/","link":"","permalink":"http://aojueliuyun.github.io/2017/11/01/2017.11.1--heap/","excerpt":"堆（二叉堆）作为一种比较重要的数据结构，完全二叉树的线性存储。其典型的应用就是堆排序和优先队列。Wiki链接。","text":"堆（二叉堆）作为一种比较重要的数据结构，完全二叉树的线性存储。其典型的应用就是堆排序和优先队列。Wiki链接。 堆（Heap）堆（二叉堆）是一个数组，也可以被看做一个近似的完全二叉树。将二叉树从顶层向底层，从左向右，从1开始编号，直到二叉树节点个数n。得到完全二叉树的层序遍历序列，即是二叉堆。同理可拓展到n叉堆。 二叉堆中编号是从1到n的，所以节点 i 的父节点编号为$\\lfloor\\ i/2\\rfloor$（i/2向下取整，在高级语言中，整型运算i/2即可做到），左孩子为2i，右孩子为2i+1。即有：12Parent(i)return i/2 12Left(i)return 2*i 12Right(i)return 2*i+1 在实际应用中，我们主要考虑最大堆（也称大顶堆）和最小堆（小顶堆）。其中最大堆（Max Heap）的根节点关键字（key）为所有节点关键字中最大值，且要求所有节点关键字的值大于等于其左孩子和右孩子的关键字。最小堆同理。以下主要以最大堆为例。 定义堆中节点的高度为根节点到所有叶子节点的最长简单路径上边的数目，即对应完全二叉树的高度。可证明节点数为n的堆高度为$\\lfloor\\log_2n\\rfloor$。即堆高度为 $\\Theta(\\log_2n)$。 维护堆的性质Max_Heapify是用来维护最大堆性质的过程。 过程描述：输入数组A及下标i。假定此时节点 i 的左子树和右子树都是最大堆。但是节点 i 关键字可能小于其孩子。而Max_Heapify则可以通过让A[i]的值逐级下降，从而使根节点为 i 的子树重新遵循最大堆。 因为堆高度为$\\Theta(\\log_2n)$，所以Max_Heapify过程时间复杂度为$O(log_2n)$。 伪代码描述如下：1Max_Heapify(A,i) 12345678910l = Left(i)r = Right(i)largest = iif l&lt;=A.Heap_Size and A[l]&gt;A[i] //A.Heap_Size表示存放在数组A中的有效堆元素 largest = lif r&lt;=A.Heap_Size and A[r]&gt;A[i] largest = rif largest != i exchange A[i] with A[largest] Max_Heapify(A,largest) C++实现： 这里在实现中为了方便和清晰舍弃了下标为0的存储位置，从下标1开始存放元素，初始化时数组大小为n+1，使其下标等于节点标号。 1234567891011121314151617void Max_Heapify(int A[],int i,int n) //n即为A.Heap_Size&#123; int largest=i; if(2*i&lt;=n &amp;&amp; A[2*i]&gt;A[largest]) &#123; largest = 2*i; &#125; if(2*i+1&lt;=n &amp;&amp; A[2*i+1]&gt;A[largest]) &#123; largest = 2*i+1; &#125; if(largest != i) &#123; swap(A[i],A[largest]); Max_Heapify(A,largest,n); &#125;&#125; 建堆建堆指输入一个数组，将其转化为最大堆。利用上面的Max_Heapify过程完成。 思路：从n/2递减到1依次调用Max_Heapify即可实现。 伪代码：1234Build_Max_Heap(A)A.Heap_Size = A.lengthfor i=A.length/2 downto 1 Max_Heapify(A,i) C++实现：1234567void Build_Max_Heap(int A[],int n)&#123; for(int i=n/2;i&gt;=1;i--) &#123; Max_Heapify(A,i,n); &#125;&#125; 堆排序堆排序是一个经典的排序算法，借助最大堆（最小堆）完成。 过程描述：输入数组A，n=A.length,将数组中元素按升序排列。 思路：堆中的最大元素总是在根节点A1，将其与堆中最后一个元素（A[n]）交换，并从堆中去掉最后一个节点（通过A.Heap_Size自减1实现）。为了维护最大堆的性质，需要在交换后调用Max_Heapify(A,1)，从而使A[1…n-1]构造成一个新的最大堆。重复这一过程直到堆大小下降为2。 步骤： 将数组A建堆 交换A1和堆中最后一个元素，堆大小减1 维护根节点堆的性质，将最大元素置为根节点 重复2,3直到排序完成 伪代码：123456Heap_Sort(A)Build_Max_Heap(A)for i=A.length downto 2 exchange A[1] with A[i] A.Heap_Size -- Max_Heapify(A,1) C++实现：123456789101112131415void Heap_Sort(int A[],int n)&#123; Build_Max_Heap(A,n); for(int i=n;i&gt;=2;i--) &#123; swap(A[1],A[i]); //A[i]为堆中最后一个元素 Max_Heapify(A,1,i-1); //i-1为堆中元素个数 &#125; &#125;void swap(int &amp;x,int &amp;y)&#123; int temp = x; x = y; y = temp;&#125; 堆排序完整Test代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//堆排序#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;void Max_Heapify(int A[],int i,int n);void Build_Max_Heap(int A[],int n);void Heap_Sort(int A[],int n); void swap(int &amp;x,int &amp;y);void Disp(int A[],int n);int main(void)&#123; int n; cin &gt;&gt; n; int A[n+1]; for(int i=1;i&lt;=n;i++) &#123; cin &gt;&gt; A[i]; &#125; Disp(A,n); Heap_Sort(A,n); Disp(A,n); system(\"pause\"); return 0;&#125;void swap(int &amp;x,int &amp;y)&#123; int temp = x; x = y; y = temp;&#125;void Max_Heapify(int A[],int i,int n)&#123; int largest=i; if(2*i&lt;=n &amp;&amp; A[2*i]&gt;A[largest]) &#123; largest = 2*i; &#125; if(2*i+1&lt;=n &amp;&amp; A[2*i+1]&gt;A[largest]) &#123; largest = 2*i+1; &#125; if(largest != i) &#123; swap(A[i],A[largest]); Max_Heapify(A,largest,n); &#125;&#125;void Build_Max_Heap(int A[],int n)&#123; for(int i=n/2;i&gt;=1;i--) &#123; Max_Heapify(A,i,n); &#125;&#125;void Heap_Sort(int A[],int n)&#123; Build_Max_Heap(A,n); for(int i=n;i&gt;=2;i--) &#123; swap(A[1],A[i]); Max_Heapify(A,1,i-1); &#125; &#125;void Disp(int A[],int n)&#123; for(int i=1;i&lt;n;i++) &#123; cout &lt;&lt; A[i] &lt;&lt; \",\"; &#125; cout &lt;&lt; A[n] &lt;&lt; endl;&#125; 优先队列坑已填，见优先队列/堆——2017.3.24 参考资料：算法导论","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://aojueliuyun.github.io/tags/数据结构/"},{"name":"堆","slug":"堆","permalink":"http://aojueliuyun.github.io/tags/堆/"}]},{"title":"三大简单排序算法——插入、选择、冒泡","slug":"2017.10.27--three-simple-sort-algorithms","date":"2017-10-26T16:00:00.000Z","updated":"2018-02-20T10:33:13.889Z","comments":true,"path":"2017/10/27/2017.10.27--three-simple-sort-algorithms/","link":"","permalink":"http://aojueliuyun.github.io/2017/10/27/2017.10.27--three-simple-sort-algorithms/","excerpt":"排序作为一个如此经典与常见的问题，排序算法自然也是各种各样、各具特点。本文主要讨论三个时间复杂度为O(n2)的简单排序算法，即插入排序、选择排序和冒泡排序。在Wiki了排序算法之后，瞬间感觉世界之大排序算法之多。Wiki链接。 简单排序算法 最好时间复杂度 最坏时间复杂度 平均时间复杂度 是否原址 插入排序 O(n) O(n2) O(n2) 是 希尔排序 O(nlogn) O(nlog2n) O(nlog2n) or O(n5/4) 是 选择排序 O(n2) O(n2) O(n2) 是 冒泡排序 O(n) O(n2) O(n2) 是 地精排序 O(n) O(n2) O(n2) 是","text":"排序作为一个如此经典与常见的问题，排序算法自然也是各种各样、各具特点。本文主要讨论三个时间复杂度为O(n2)的简单排序算法，即插入排序、选择排序和冒泡排序。在Wiki了排序算法之后，瞬间感觉世界之大排序算法之多。Wiki链接。 简单排序算法 最好时间复杂度 最坏时间复杂度 平均时间复杂度 是否原址 插入排序 O(n) O(n2) O(n2) 是 希尔排序 O(nlogn) O(nlog2n) O(nlog2n) or O(n5/4) 是 选择排序 O(n2) O(n2) O(n2) 是 冒泡排序 O(n) O(n2) O(n2) 是 地精排序 O(n) O(n2) O(n2) 是 上图截自Wikipedia，足可见排序算法是如此得花式繁多。但这里只介绍常用的三种简单排序及其改进版本。 排序分为内排序和外排序，内排序为在内存中进行地排序，外排序主要是外存储器中大文件的排序。 内排序按照排序方式可以分为基于比较的排序，和不基于比较的排序。其中基于比较的排序算法有插入排序，交换排序，选择排序，归并排序等。不基于比较的排序有基数排序，桶排序等。以下算法均以升序排列为例。 如果一个排序算法在排序过程中只有常数个元素需要存储在数组之外，则称该排序算法为原址的。后面会介绍一些非原址的排序算法，如归并排序。（next time） 首先定义一个交换元素的函数供下面的函数调用：123456void swap(int &amp;x,int &amp;y)&#123; int temp = x; x = y; y = temp;&#125; 插入排序(Insertion Sort)直接插入排序在生活中我们也许经常用到插入排序，例如玩扑克牌时按照大小整理牌序的过程。 思路（步骤）： 对第一个元素不做任何处理，作为初始时的已排序列 从第二个元素开始，在已排序的序列中查找该元素其应该位于的位置 在查找过程中，将大元素依次往后移，直到遇到合适位置 将该元素插入该位置，已排序列元素个数加1 重复2，3，4直到最后一个元素 当已经排好序时，最好时间复杂度为O(n)。逆序时，最坏时间复杂度为O(n2)。平均时间复杂度也是O(n2)。 伪代码如下：1Insertion_Sort(A) 1234567for i=2 to A.length key = A[i] j = i-1 while j&gt;0 and A[j]&gt;key A[j+1] = A[j] j = j-1 A[j+1] = key 其中A表示一个数组，”.”号表示调用属性，比如A.length表示数组A的长度，伪代码中数组下标从1开始，即为数组元素的逻辑位序。采用缩进表示语句间的层次等特点。伪代码表示算法的优点： 简单易读，屏蔽了高级语言的细节，对于由程序设计语言基础的人来说根据伪代码写出对应的代码会非常容易。当遇到复杂问题时先写出伪代码也许会是解决问题的一个好途径。 采用C++/C实现上述伪代码：123456789101112131415void Insertion_Sort(int A[],int n)&#123; int i,j,key; for(i=1;i&lt;n;i++) &#123; key = A[i]; j = i-1; while(j&gt;=0 &amp;&amp; A[j]&gt;key) &#123; A[j+1] = A[j]; j --; &#125; A[j+1] = key; &#125;&#125; 排序过程的动图（以下均来自Wikipedia）演示如下： 折半插入排序(Binary Insertion Sort)可以看到上述插入排序中查找和移动是结合在一起的，并且在插入第i个元素时，前i-1个元素时有序的。那么可以使用有序表的二分查找代替逐项查找，并且先查找再移动。那么就可以改进其中查找过程的时间复杂度。但由于并没有改进移动过程。所以总体时间复杂度并不会产生变化，仍为O(n2)。伪代码如下：1Bin_Insertion_Sort(A) 1234567891011121314for i=2 to A.length if A[i-1] &gt; A[i] key = A[i] low = 1 high = i-1 while low &lt;= high mid = (high+low)/2 if key &gt; A[mid] //插入点在左半区 high = mid-1 else //插入点在于右半区 low = mid+1 while j=i-1 downto high+1 //元素集中后移 A[j+1] = A[j] A[high+1] = key //插入 C++实现如下：12345678910111213141516171819202122232425void Bin_Insertion_Sort(int A[],int n) //升序&#123; int i,j,low,high,mid; int key; for(i=1;i&lt;n;i++) &#123; if(A[i-1] &gt; A[i]) //反序时 &#123; key = A[i]; low = 0; high = i-1; while(low &lt;= high) &#123; mid = (low+high)/2; if(key &lt; A[mid]) high = mid-1; //插入点前半区 else low = mid+1; //插入点后半区 &#125; for(j=i-1;j&gt;=high+1;j--) //元素集中后移 A[j+1] = A[j]; A[high+1] = key; //插入 &#125; &#125;&#125; 希尔排序(Shell Sort)希尔排序也是一种插入排序，是简单插入排序经过改进后的一个高效版本，也称缩小增量排序。同时希尔排序也是冲破O(n2)的第一批算法之一。 思路（步骤）： d = n/2 将序列分为d个分组，在每个分组内进行直接插入排序 d=d/2，重复2，直到d=1 分析：对于一趟排序过程，A[1…n]被分为d个子序列。即A[1],A[1+d],A[1+2d]…、A[2],A[2+d],A[2+2d]…等d个序列。一趟排序完成之后，每个子序列内部有序，再将d缩小为d/2，重复这一过程。直到d=1时，会对整个数组进行一次直接插入排序。所以最后得到的结果一定是正确的。 时间复杂度：最好为O(nlogn)，平均O(n1.25)，证明过程复杂，这里不做证明。可参考ShellSort。 伪代码表示如下：1Shell_Sort(A) 12345678910d = A.length/2while d&gt;0 for i=d+1 to n //从第一个序列的第二个元素开始 temp = A[i] j = i-d while j&gt;0 and temp &lt; A[j] //对每一个序列进行插入排序 A[j+d] =A[j] j = j-d A[j+d] = temp d = d/2 C++实现如下：1234567891011121314151617181920void Shell_Sort(int A[],int n)&#123; int i,j,d,temp; d = n/2; while(d &gt; 0) &#123; for(i=d;i&lt;n;i++) &#123; temp = A[i]; j = i-d; while(j&gt;=0 &amp;&amp; temp&lt;A[j]) &#123; A[j+d] = A[j]; j = j-d; &#125; A[j+d] = temp; &#125; d = d/2; &#125; &#125; 动图演示： 选择排序(Selection Sort)思路（步骤）： 在所有n个元素中选出最小的元素排在第一个位置 选出次小元素排在下一位置 重复2直到排序完成 因为在排序过程的比较次数与n2成正比，仅仅是交换次数从0到n-1的变化。所以选择排序的最好、最坏和平均时间复杂度都是O(n2). 伪代码如下：1Selection_Sort(A) 1234567for i=1 to A.length-1 min = A[i] for j=i+1 to A.length if(A[j] &lt; min) min = A[j] k = j exchange A[j] with A[k] C++实现如下：123456789101112131415161718void Selection_Sort(int A[],int n)&#123; int i,j,k,min; for(i=0;i&lt;n;i++) &#123; min = A[i]; for(j=i+1;j&lt;n;j++) &#123; if(A[j]&lt;min) &#123; min = A[j]; k = j; &#125; &#125; if(min != A[i]) swap(A[i],A[k]); &#125;&#125; 动图演示： 冒泡排序(Bubble Sort)冒泡排序为交换排序中的最简单的一种。交换排序主要有冒泡排序和快速排序。（快速排序next time） 基础版本思路（步骤）： 将序列分为（全局）有序区和待排无序区，初始时所有元素位于待排无序区中 从待排无序区末尾开始将元素与前一元素比较，若小则交换 一轮循环后，无序区最小元素移到最前方并入有序区中，无序区缩小 重复2，3直到排序完成 最好时间复杂度在已排好的序列时取到为O(n)，平均和最坏时间复杂度均为O(n2) 伪代码如下：1Bubble_Sort(A) 1234for i=1 to A.length-1 for j=A.length downto i+1 if(A[j] &lt; A[j-1]) exchange A[j] with A[j-1] C++实现如下：1234567891011void Bubble_Sort(int A[],int n)&#123; for(int i=0;i&lt;n-1;i++) &#123; for(int j=n-1;j&gt;i;j--) &#123; if(A[j] &lt; A[j-1]) swap(A[j],A[j-1]); &#125; &#125;&#125; 动图演示（图中为从后往前）： 稍加改进改进思路：若在冒泡过程中那一轮循环结束后已经排好了序（不再冒泡/交换），则直接结束。增加一个表示本轮循环是否交换的变量即可。C++实现：123456789101112131415161718void Bubble_Sort(int A[],int n)&#123; bool exchange; for(int i=0;i&lt;n-1;i++) &#123; exchange = false; for(int j=n-1;j&gt;i;j--) &#123; if(A[j] &lt; A[j-1]) &#123; swap(A[j],A[j-1]); exchange = true; &#125; &#125; if(!exchange) return; &#125;&#125; 地精排序(Gnome Sort)地精排序号称最简单的排序。交换排序的一种。又称Stupid Sort。只使用一层循环。Wiki链接 思路：默认情况下前进冒泡，一旦遇到冒泡的情况就往回冒，直到把这个数放好为止。 分析：就排序过程而言，与插入排序基本一致，唯一区别就是地精排序通过交换元素实现元素的向后移动，而插入排序是借助了一个额外的存储空间使元素往后移动。所以说插入排运行时间略优于地精排序。 其时间复杂度同样是最好为O(n)，平均和最坏均为O(n2)。 步骤： 初始时，i为0，则直接自加1 然后将A[i]与A[i-1]比较，发生交换则i自减1，没发生交换则自加1 重复2直到排序完成 伪代码如下：1Gnome Sort(A) 1234567i=1while(i&lt;=A.length) if i==1 or A[i]&gt;=A[i-1] i++ else exchange A[i] with A[i-1] i-- C++实现如下：12345678910111213141516void Gnome_Sort(int A[],int n)&#123; int i=0; while(i&lt;n) &#123; if(i==0 || A[i]&gt;=A[i-1])//升序 &#123; i ++; &#125; else &#123; swap(A[i],A[i-1]); i --; &#125; &#125;&#125; 其中可改进的地方还很多，这里不做实现。动图演示： 参考资料：算法导论","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://aojueliuyun.github.io/tags/排序/"}]},{"title":"基本数据结构--栈","slug":"2017.10.16--stack","date":"2017-10-15T16:00:00.000Z","updated":"2018-03-15T14:28:05.982Z","comments":true,"path":"2017/10/16/2017.10.16--stack/","link":"","permalink":"http://aojueliuyun.github.io/2017/10/16/2017.10.16--stack/","excerpt":"这篇文章关于栈这种数据结构，承接上一篇队列，同样搬运自我的CSDN博客。原文链接","text":"这篇文章关于栈这种数据结构，承接上一篇队列，同样搬运自我的CSDN博客。原文链接 队列和栈作为一种最简单最基本的常用数据结构，可以说在许多方面都应用广泛。在程序运行时，他们可以保存程序运行路径中各个点的信息，以便用于回溯操作或其他需要访问已经访问过的节点信息的操作。这里对栈的特点、作用做出描述、并简单地用不同途径实现了栈的基本功能。本文的实现分别用了C语言（不是纯C，仍为cpp文件，仅仅只是采用了C语言中的部分思想）和C++，代码均在GCC编译器下验证通过。 什么是栈？栈是一种先进后出（FILO）的数据结构，与上一篇中的队列一样，同为最基础的数据结构之一。队列请参考常用数据结构——队列及其应用。详细定义请参考教科书。栈同样作为一种限制性的线性表。操作只能在一端进行，即栈顶。另一端为栈底，不进行操作。在栈顶插入元素的操作称为压栈或进栈（push），删除元素的操作称为出栈（pop）。 栈的结构类似于一个箱子，装入东西只能从上面加在最顶上，取出时也只能先取出箱子中最顶上的东西。 基本操作除了出栈，压栈外，还有取栈顶元素，初始化，销毁，判空，判满，清空，遍历等操作，可根据需求定义。类似于队列，栈对应于顺序存储结构和链式存储结构分别为顺序栈和链式栈。 C实现顺序栈在C语言中的实现很简单：其中栈顶指针top指向栈顶元素。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt; #include&lt;stdlib.h&gt; #define MaxSize 100 using namespace std; typedef struct//栈的定义 &#123; char data[MaxSize];//默认字符数组 int top;//指针 &#125;SqStack; void InitStack(SqStack *&amp;s);//初始化 void DestroyStack(SqStack *&amp;s); //销毁栈 bool StackEmpty(SqStack *s);//判空 bool Push(SqStack *&amp;s,char e);//压栈 bool Pop(SqStack *&amp;s,char &amp;e); //出栈 bool GetTop(SqStack *s,char &amp;e);//取得栈顶元素 int main(void) &#123; SqStack *s; InitStack(s); DestroyStack(s); system(\"pause\"); return 0; &#125; void InitStack(SqStack *&amp;s) &#123; s = (SqStack *)malloc(sizeof(SqStack)); s-&gt;top = -1; &#125; void DestroyStack(SqStack *&amp;s)//销毁栈 &#123; free(s); &#125; bool StackEmpty(SqStack *s)//判空 &#123; return s-&gt;top == -1; &#125; bool Push(SqStack *&amp;s,char e)//压栈 &#123; if(s-&gt;top == MaxSize-1)//栈满情况 return false; s-&gt;top ++; s-&gt;data[s-&gt;top] = e;//e赋给栈顶 return true; &#125; bool Pop(SqStack *&amp;s,char &amp;e)//出栈 &#123; if(s-&gt;top == -1)//为空 return false; e = s-&gt;data[s-&gt;top]; s-&gt;top --; return true; &#125; bool GetTop(SqStack *s,char &amp;e)//取栈顶元素 &#123; if(s-&gt;top == -1) return false; e = s-&gt;data[s-&gt;top]; return true; &#125; 链式栈在C语言中，采用带头节点的链表实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; typedef struct SNode &#123; int data; SNode *next; &#125;LinkedStack;//链式栈节点定义 void InitStack(LinkedStack *&amp;s);//初始化 void DestroyStack(LinkedStack *&amp;s);//销毁栈 bool StackEmpty(LinkedStack *s);//判空 void Push(LinkedStack *&amp;s,int e);//压栈/进栈 bool Pop(LinkedStack *&amp;s,int &amp;e);//出栈 bool GetTop(LinkedStack *&amp;s,int &amp;e);//get栈顶元素 int main(void) &#123; LinkedStack *Q; InitStack(Q); Push(Q,1); Push(Q,2); Push(Q,3); int a,b; Pop(Q,a); Pop(Q,b); cout &lt;&lt; a &lt;&lt; endl &lt;&lt; b &lt;&lt; endl; system(\"pause\"); return 0; &#125; void InitStack(LinkedStack *&amp;s) &#123; s = (LinkedStack *)malloc(sizeof(SNode)); s-&gt;next = NULL;//创建空栈 &#125; void DestroyStack(LinkedStack *&amp;s) &#123; LinkedStack *p =s, *q = s-&gt;next; while(q != NULL) &#123; free(p); p = q; q = q-&gt;next; &#125; free(p); &#125; bool StackEmpty(LinkedStack *s) &#123; return s-&gt;next == NULL; &#125; void Push(LinkedStack *&amp;s,int e)//链表头插法 &#123; SNode *p = (LinkedStack *)malloc(sizeof(SNode)); p-&gt;data = e; p-&gt;next = s-&gt;next; s-&gt;next = p; &#125; bool Pop(LinkedStack *&amp;s,int &amp;e) &#123; //首先判空 if(s-&gt;next == NULL) return false; SNode *p = s-&gt;next; e = p-&gt;data; s-&gt;next = p-&gt;next; free(p); return true; &#125; bool GetTop(LinkedStack *&amp;s,int &amp;e) &#123; if(s-&gt;next == NULL) return false; e = s-&gt;next-&gt;data; return true; &#125; C++实现后面的几个例子主要采用C++实现。 C++中与C语言中区别：C++中操作作为类的成员函数，默认传入this指针，少了一个参数。且初始化和销毁分别用构造函数和析构函数实现。利用C++中的类模板技术可以实现栈的重用，可以实例化出能装入不同类型对象的栈。这里主要实现顺序栈，而且栈顶指针指向的是栈顶的下一个位置。 顺序栈实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;iostream&gt; using namespace std; class MyStack &#123; public: MyStack(int size); //分配初始空间，设置栈容量，栈顶 ~MyStack();//析构函数，销毁栈 bool StackEmpty();//判空 bool StackFull();//判满 void ClearStack();//清空 int StackLength();//求长度 bool Push(char elem); //压栈 bool Pop(char &amp;elem); //出栈 void Traverse_Stack(bool IsFromButtom);//遍历，IsFromButtom参数表示是否从栈底遍历private: char *m_pBuffer; //栈空间指针 int m_iSize;//栈最大容量 int m_iTop; //栈顶 &#125;; int main(void) &#123; MyStack *pStack = new MyStack(5); pStack-&gt;Push('h'); pStack-&gt;Push('e'); pStack-&gt;Push('l'); pStack-&gt;Push('l'); pStack-&gt;Push('o'); pStack-&gt;Traverse_Stack(1); pStack-&gt;Traverse_Stack(0); cout &lt;&lt; pStack-&gt;StackLength() &lt;&lt; endl; char elem = 0; pStack-&gt;Pop(elem); cout &lt;&lt; elem &lt;&lt; endl; pStack-&gt;Traverse_Stack(1); pStack-&gt;Traverse_Stack(0); pStack-&gt;ClearStack(); if(pStack-&gt;StackEmpty()) &#123; cout &lt;&lt; \"The stack is empty!\" &lt;&lt; endl; &#125; if(pStack-&gt;StackFull()) &#123; cout &lt;&lt; \"The stack is full!\" &lt;&lt; endl; &#125; delete pStack;//在堆中分配内存一定要释放内存 pStack = NULL; return 0; &#125; MyStack::MyStack(int size) &#123; m_iSize = size; m_pBuffer = new char[size]; m_iTop = 0; //空栈 &#125; MyStack::~MyStack() &#123; delete []m_pBuffer; &#125; bool MyStack::StackEmpty() &#123; return m_iTop == 0; &#125; bool MyStack::StackFull() &#123; //栈顶指针m_iTop，栈空为0，压栈累加 if(m_iTop == m_iSize)//&gt;= &#123; return true; &#125; else return false; &#125; void MyStack::ClearStack() &#123; m_iTop = 0;//栈中值无效 &#125; int MyStack::StackLength() &#123; return m_iTop;//m_iTop即为栈高度 &#125; bool MyStack::Push(char elem) &#123; if(StackFull())//栈满，入栈失败，处理方法，bool类型返回值或者抛异常 &#123; return false; &#125; m_pBuffer[m_iTop] = elem; m_iTop++; return true; &#125; bool MyStack::Pop(char &amp;elem) &#123; if(StackEmpty()) &#123; return false; &#125; m_iTop--; elem = m_pBuffer[m_iTop]; return true; &#125; void MyStack::Traverse_Stack(bool IsFromButtom)//visit() &#123; if(IsFromButtom) &#123; //从栈底遍历 for(int i=0;i&lt;m_iTop;i++) &#123; cout &lt;&lt; m_pBuffer[i] &lt;&lt; \",\"; &#125; cout &lt;&lt; endl; &#125; else &#123; //从栈顶遍历 for(int i=m_iTop-1;i&gt;=0;i--) &#123; cout &lt;&lt; m_pBuffer[i] &lt;&lt; \",\"; &#125; cout &lt;&lt; endl; &#125; &#125; 使用类模板改造上面的顺序栈：使之能够装入任意类型的数据元素。这里定义了坐标类Coordinate,包含两个数据成员横坐标x，和纵坐标y。并重载了&lt;&lt;运算符，使之能够直接使用cout对象输出Coordinate对象。并用这个类实例化的一个存放可以存放Coordinate类型数据元素的栈。 实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include&lt;iostream&gt; using namespace std; /*************坐标类Coordinate**********/ class Coordinate &#123; //&lt;&lt;运算符只能用友元函数重载 friend ostream &amp;operator&lt;&lt;(ostream &amp;out,Coordinate &amp;coor); public: Coordinate(double x=0,double y=0) &#123; m_iX = x; m_iY = y; &#125; void print_Coor() &#123; cout &lt;&lt; \"(\" &lt;&lt; m_iX &lt;&lt; \",\" &lt;&lt; m_iY &lt;&lt; \")\" &lt;&lt; endl; &#125; private: double m_iX; double m_iY; &#125;; ostream &amp;operator&lt;&lt;(ostream &amp;out,Coordinate &amp;coor) &#123; out &lt;&lt; \"(\" &lt;&lt; coor.m_iX &lt;&lt; \",\" &lt;&lt; coor.m_iY &lt;&lt; \")\" &lt;&lt; endl; //coor.print_Coor(); return out; &#125; /***************类模板********************/ template &lt;typename T&gt; class MyStack &#123; public: MyStack(int size); //分配初始空间，设置栈容量，栈顶 ~MyStack(); bool StackEmpty(); bool StackFull(); void ClearStack(); int StackLength(); bool Push(T elem); //压栈 bool Pop(T &amp;elem); //出栈 void Traverse_Stack(bool IsFromButtom); private: T *m_pBuffer; //栈空间指针 int m_iSize; int m_iTop; //栈顶 &#125;; int main(void) &#123; MyStack&lt;Coordinate&gt; *pStack = new MyStack&lt;Coordinate&gt;(5); pStack-&gt;Push(Coordinate(1,2)); pStack-&gt;Push(Coordinate(3,4)); pStack-&gt;Push(Coordinate(4,5)); pStack-&gt;Traverse_Stack(1); pStack-&gt;Traverse_Stack(0); Coordinate c(0,0); pStack-&gt;Pop(c); cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; pStack-&gt;StackLength() &lt;&lt; endl; pStack-&gt;ClearStack(); if(pStack-&gt;StackEmpty()) &#123; cout &lt;&lt; \"The stack is empty!\" &lt;&lt; endl; &#125; if(pStack-&gt;StackFull()) &#123; cout &lt;&lt; \"The stack is full!\" &lt;&lt; endl; &#125; delete pStack;//在堆中分配内存一定要释放内存 pStack = NULL; return 0; &#125; template &lt;typename T&gt; MyStack&lt;T&gt;::MyStack(int size) &#123; m_iSize = size; m_pBuffer = new T[size]; m_iTop = 0; //空栈 &#125; template &lt;typename T&gt; MyStack&lt;T&gt;::~MyStack() &#123; delete []m_pBuffer; &#125; template &lt;typename T&gt; bool MyStack&lt;T&gt;::StackEmpty() &#123; return m_iTop == 0; &#125; template &lt;typename T&gt; bool MyStack&lt;T&gt;::StackFull() &#123; //栈顶指针m_iTop，栈空为0，压栈累加 if(m_iTop == m_iSize)//&gt;= &#123; return true; &#125; else return false; &#125; template &lt;typename T&gt; void MyStack&lt;T&gt;::ClearStack() &#123; m_iTop = 0;//栈中值无效 &#125; template &lt;typename T&gt; int MyStack&lt;T&gt;::StackLength() &#123; return m_iTop;//m_iTop即为栈高度 &#125; template &lt;typename T&gt; bool MyStack&lt;T&gt;::Push(T elem) &#123; if(StackFull())//栈满，入栈失败，处理方法，bool或者抛异常 &#123; return false; &#125; m_pBuffer[m_iTop] = elem; m_iTop++; return true; &#125; template &lt;typename T&gt; bool MyStack&lt;T&gt;::Pop(T &amp;elem) &#123; if(StackEmpty()) &#123; return false; &#125; m_iTop--; elem = m_pBuffer[m_iTop]; return true; &#125; template &lt;typename T&gt; void MyStack&lt;T&gt;::Traverse_Stack(bool IsFromButtom)//visit() &#123; if(IsFromButtom) &#123; //从栈底遍历 for(int i=0;i&lt;m_iTop;i++) &#123; //对于传入模板类中的封装数据类型必须重载&lt;&lt;运算符 cout &lt;&lt; m_pBuffer[i] &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; else &#123; //从栈顶遍历 for(int i=m_iTop-1;i&gt;=0;i--) &#123; cout &lt;&lt; m_pBuffer[i] &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; &#125; 典型应用栈的应用场景极其广泛，在程序运行时，使用new或者malloc动态分配的内存位于堆区，而栈区通常用来暂时存放为运行函数而分配的局部变量，函数参数，返回数据，返回地址等。下面主要介绍三个栈解决的很经典很简单的问题：进制转换、括号匹配、迷宫问题。 进制转换问题描述：输入任意十进制整数，将其转换为任意进制的数。方法：家喻户晓的除基数取余法。公式 N = (N div d) *d + N mod d。 这里的栈实现采用上面的类模板设计，不再重写。实现算法如下：12345678910111213141516171819202122char num[] = \"0123456789ABCDEF\" ;//定义全局数组，存放转换之后表示大于10进制的数字的字符， void RadixConvert(int n,int radix)//输入十进制数n和基数radix,打印出转换之后的数 &#123; MyStack&lt;int&gt; *pStack = new MyStack&lt;int&gt;(32); int mod = 0;//余数 while(n != 0) &#123; mod = n%radix; pStack-&gt;Push(mod);//余数进栈 n = n/radix; &#125; int elem = 0; while(!pStack-&gt;StackEmpty())//也可将结果用字符串保存返回给函数 &#123; pStack-&gt;Pop(elem); cout &lt;&lt; num[elem]; &#125; cout &lt;&lt; endl; delete pStack;//在堆中实例化对象一定要释放内存，也可以在栈中实例化 pStack = NULL; &#125; 括号匹配问题描述：输入字符串str，判断其中括号是否匹配。 类似于 ( [ { } [ ] ] )称之为匹配，类似于 ( [ ) ] 称之为不匹配。实现中只考虑英文半角括号 () [ ] { },如若想考虑全角符号或者半角与全角匹配之类的问题，请自行编写。 思路：遇到左括号依次进栈，如果碰到右括号就将上一个元素出栈，并查看是否与之匹配，匹配则继续，不匹配则结束。这里遇到右括号时可能出现栈为空的情况，此时是不匹配的，出栈会不成功，所以需要在遇到右括号时增加一个判断站是否为空的条件语句。default情况下，不执行直接break则会跳过中间不是括号的字符。 实现如下：匹配则返回true，不匹配返回false。这里的栈实现依然采用上面的类模板。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273bool BracketMatch(char *str) &#123; MyStack&lt;char&gt; *pStack = new MyStack&lt;char&gt;(30); bool matching = true;//表示当前是否匹配，如果不匹配，直接跳出for循环 for(int i=0;i&lt;strlen(str);i++) &#123; char elem = 0; switch(str[i]) &#123; case '[': case '(': case '&#123;': pStack-&gt;Push(str[i]); break; case ']': if(pStack-&gt;StackLength() == 0) &#123; matching = false; break; &#125; pStack-&gt;Pop(elem); if(elem == '[')//同栈顶元素匹配则继续 break; else &#123; matching = false;//不匹配 break; &#125; case ')': if(pStack-&gt;StackLength() == 0) &#123; matching = false; break; &#125; pStack-&gt;Pop(elem); if(elem == '(') break; else &#123; matching = false; break; &#125; case '&#125;': if(pStack-&gt;StackLength() == 0) &#123; matching = false; break; &#125; pStack-&gt;Pop(elem); if(elem == '&#123;') break; else &#123; matching = false; break; &#125; default: //包含异常字符，直接忽略，继续匹配，我们只管括号的！ break; &#125; if(!matching) break; &#125; if(pStack-&gt;StackLength() == 0 &amp;&amp; matching) &#123; return true;//括号匹配 &#125; else &#123; return false;//括号不匹配 &#125; &#125; 如果main函数中执行以下代码，则会打印出括号匹配！123456789char str[] = \"[(你)好][()( ) ]&#123;[(hello,world)] &#125; ([世界]!)\"; if(BracketMatch(str)) &#123; cout &lt;&lt; \"括号匹配！\"&lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"括号不匹配！\" &lt;&lt; endl; &#125; 迷宫问题问题描述：给定给定一个M×N的迷宫图、入口与出口、行走规则。求一条从指定入口到出口的路径。所求路径必须是简单路径，即路径不重复。 这个问题在上一篇队列中利用队列（基本数据结构——队列及其应用）求解过，而且利用队列求解出来的结果一定是最短路径中的一条。但这里用栈求解的结果不一定是最短路径。 迷宫采用二维数组来表示，其中路用0表示，墙用1表示。为了求解问题的方便，通常在数组的周围加上围墙，即在周围加上两行和两列。形成M+2行，N+2列的迷宫数组。 思路：对于每一个方块都优先查找其方位0上的方块的路径，如果这个方向上没有路径，就依次查找1,2,3方向，如果都没有路径，就将其出栈，表明经过这个格点无法找到出口。0-&gt;3的方向分别为上右下左。最后找到出口时栈底到栈顶的序列即为路径。 主要思想是从入口开始按照上右下左的优先顺序（优先顺序可以自行设置）依次查找其相邻方块，直到查找到出口打印路径返回true，或者将所有方位都查找过后发现没有路径返回false，表示没有路径。在求解时同样要将查找过的方格值赋为-1，避免重复访问。这样求出来的路径一般情况下不是最短路径。比如以下程序输入起点坐标(1,1)终点坐标(2,1)时，输出路径顺序为(1,1),(1,2),(1,3),(2,3),(2,4),(3,4),(4,4),(4,3),(4,2),(3,2),(3,1),(2,1)。 注意这里的坐标为（行号，列号），均从0开始。 实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; const int MaxSize = 100; typedef struct &#123; int i,j;//i表示行号，j表示列号 int di;//方位从0（上）开始，++顺时针旋转，即0-&gt;3为上右下左 &#125;Box; typedef struct &#123; Box data[MaxSize]; int top;//指向栈顶元素 &#125;Stack; //全局数组maze表示迷宫 const int M=4,N=4; int maze[M+2][N+2] = &#123; &#123;1, 1, 1, 1, 1, 1&#125;, //迷宫示例 &#123;1, 0, 0, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 0, 1&#125;, &#123;1, 0, 0, 1, 0, 1&#125;, &#123;1, 1, 0, 0, 0, 1&#125;, &#123;1, 1, 1, 1, 1, 1&#125; &#125;; bool MazePath(int xi,int yi,int xe,int ye); int main(void) &#123; if(!MazePath(1,1,4,4)) &#123; cout &lt;&lt; \"There is no path !\" &lt;&lt; endl; &#125; system(\"pause\"); return 0; &#125; bool MazePath(int xi,int yi,int xe,int ye)//(xi,yi)入口(xe,ye)出口 &#123; int i,j,di; bool find = false;//find为true表明找到了下一个可走方块 Stack St; St.top = -1; St.top ++; St.data[St.top].i = xi;//将入口进栈 St.data[St.top].j = yi; St.data[St.top].di = -1; maze[xi][yi] = -1;//将迷宫值赋为-1，避免重复访问 while(St.top != -1)//栈不空时循环 &#123; i = St.data[St.top].i; j = St.data[St.top].j; di = St.data[St.top].di; if(i==xe &amp;&amp; j==ye)//找到出口 &#123; cout &lt;&lt; \"迷宫路径如下：\" &lt;&lt; endl; for(int k=0;k&lt;=St.top;k++) &#123; cout &lt;&lt; \"(\"&lt;&lt; St.data[k].i &lt;&lt; \",\" &lt;&lt; St.data[k].j &lt;&lt; \")\" &lt;&lt;endl; &#125; cout &lt;&lt; endl; return true; &#125; find = false; while(di&lt;4 &amp;&amp; !find)//找到下一个可走方块 &#123; di ++; switch(di) &#123; case 0: i=St.data[St.top].i-1; j=St.data[St.top].j; break; case 1: i=St.data[St.top].i; j=St.data[St.top].j+1; break; case 2: i=St.data[St.top].i+1; j=St.data[St.top].j; break; case 3: i=St.data[St.top].i; j=St.data[St.top].j-1; break; &#125; if(maze[i][j]==0)//找到了下一个可走方块 &#123; find = true; &#125; &#125; if(find)//有路径可走 &#123; St.data[St.top].di = di; St.top ++; St.data[St.top].i = i; St.data[St.top].j = j; St.data[St.top].di = -1; maze[i][j] = -1; &#125; else//没有路径可走 &#123; //让该位置变为其他路径可走方块 maze[St.data[St.top].i][St.data[St.top].j] = 0; St.top --;//将该方块出栈 &#125; &#125; return false; &#125; 栈作为一种最简单最基础的家喻户晓的数据结构，是必须掌握的，后续应该会有树和图的文章，敬请期待。","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://aojueliuyun.github.io/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"http://aojueliuyun.github.io/tags/栈/"}]},{"title":"基本数据结构--队列","slug":"2017.10.15--queue","date":"2017-10-14T16:00:00.000Z","updated":"2018-03-15T14:27:20.877Z","comments":true,"path":"2017/10/15/2017.10.15--queue/","link":"","permalink":"http://aojueliuyun.github.io/2017/10/15/2017.10.15--queue/","excerpt":"这应该算是这个博客的第一篇文章，为了偷懒，本文搬运自我的CSDN博客。原文链接","text":"这应该算是这个博客的第一篇文章，为了偷懒，本文搬运自我的CSDN博客。原文链接 队列和栈作为一种最简单最基本的常用数据结构，可以说在许多方面都应用广泛。在程序运行时，他们可以保存程序运行路径中各个点的信息，以便用于回溯操作或其他需要访问已经访问过的节点信息的操作。这里对队列的特点、作用做出描述、并简单地用不同途径实现了队列的基本功能。本文的代码实现均为类C语言（数据结构用结构体封装，部分语法为C++，比如引用），或者纯C++。 什么是队列？队列以一种先入先出（FIFO）的线性表，还有一种先入后出的线性表（FILO）叫做栈。（参见上一篇）教科书上有明确的定义与描述。类似于现实中排队时的队列（队尾进，队头出），队列只在线性表两端进行操作，插入元素的一端称为队尾（rear），删除（取出）元素的一端称为队头（front）。分别对应于 入队和出队操作。 存储结构对应于线性存储结构，称为顺序队列，链式存储结构称为链队。实现分别用数组和链表。 顺序队列的实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt; #include&lt;stdlib.h&gt; #define MaxSize 100 using namespace std; typedef struct &#123; int data[MaxSize]; int front,rear; //队首、队尾 指针 &#125;SqQueue; //队列中两端都会发生变化，所以用头尾指针表示两端的变化 void InitQueue(SqQueue *&amp;q); void DestroyQueue(SqQueue *&amp;q); bool QueueEmpty(SqQueue *q); bool InQueue(SqQueue *&amp;q,int e); //入队insert bool DeQueue(SqQueue *&amp;q,int &amp;e);//出队delete int main(void) &#123; system(\"pause\"); return 0; &#125; void InitQueue(SqQueue *&amp;q) &#123; q = (SqQueue *)malloc(sizeof(SqQueue)); q-&gt;front = q-&gt;rear = -1; &#125; void DestroyQueue(SqQueue *&amp;q) &#123; free(q); q = NULL; &#125; bool QueueEmpty(SqQueue *q) &#123; return q-&gt;front == q-&gt;rear;//为空 &#125; bool InQueue(SqQueue *&amp;q,int e) &#123; if(q-&gt;rear == MaxSize-1)//队满上溢出 //环形队列--------if((p-&gt;rear+1)%MaxSize == front) return false; q-&gt;rear ++; //环形队列--------q-&gt;rear = (q-&gt;rear+1)%MaxSize; q-&gt;data[q-&gt;rear] = e; return true; &#125; bool DeQueue(SqQueue *&amp;q,int &amp;e) &#123; if(q-&gt;front == q-&gt;rear)//队空下溢出 return false; q-&gt;front ++; //环形队列---------p-&gt;front = (p-&gt;front+1)%MaxSize; e = q-&gt;data[q-&gt;front]; return true; &#125; 而线性队列在使用中会出现假溢出。即判断队列已满，但实际上并非所有位置都存放了元素。可以通过每次出队后将队列中所有元素前移一个位置解决，但这样会造成很高的额外时间消耗。采用环形队列可以解决这一问题。 环形队列环形队列即将数组的头和尾连接起来构成环形。为了使队满的条件不与队空的条件（front == rear）冲突。可以舍弃一个元素的存储空间，队头front指向队头的上一个位置，队尾rear指向队尾元素。这样队满条件变为（rear+1）%MaxSize == front. 环形队列中，初始化队头队尾改为： 123q-&gt;front = q-&gt;rear = 0;//这时在开始时将舍弃队列第一个存储空间//q-&gt;front = MaxSize-1;//这时第一个存储空间是可用的//q-&gt;rear = -1; 环形队列只需更改下列函数即可。增加一个判满函数如下：12345678bool QueueFull(SqQueue *q) &#123; if((q-&gt;rear+1)%MaxSize == q-&gt;front) &#123; return true; &#125; return false; &#125; 插入函数修改为：12345678bool InQueue(SqQueue *&amp;q,int e) &#123; if(QueueFull(q)) return false; q-&gt;rear = (q-&gt;rear+1)%MaxSize; q-&gt;data[q-&gt;rear] = e; return true; &#125; 删除函数修改为：1234567bool DeQueue(SqQueue *&amp;q,int &amp;e) &#123; if(QueueEmpty(q)) return false; q-&gt;front = (q-&gt;front+1)%MaxSize; e = q-&gt;data[q-&gt;front]; &#125; 遍历函数为：12345678void TraverseQueue(SqQueue *q)//从表头到表尾 &#123; for(int i=0;i&lt;QueueLength(q);i++) &#123; cout &lt;&lt; q-&gt;data[(i+q-&gt;front+1)%MaxSize] &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; 其余函数均与顺序队列一致。 在C++中采用类实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; /*******************实现环形队列*************/ class MyQueue &#123; public: MyQueue(int queueCapacity);//创建队列 virtual ~MyQueue();//销毁队列 void ClearQueue();//清空队列 bool QueueEmpty() const;//判断队列是否为空 bool QueueFull() const;//判满队列 int QueueLength() const;//队列长度 bool InQueue(int element);//新元素入队 bool DeQueue(int &amp;element);//首元素出队 void QueueTraverse();//遍历队列 private: int *m_pQueue; //队列数组指针 int m_iQueueLen; //队列元素个数 int m_iQueueCapacity; //队列数组容量 int m_iHead;//队头，实质是数组下标 int m_iTail; //队尾 &#125;; //构造函数，创建队列 MyQueue::MyQueue(int queueCapacity) &#123; m_iQueueCapacity = queueCapacity; m_iHead = 0; m_iTail = 0; m_iQueueLen = 0;//ClearQueue(); m_pQueue = new int[m_iQueueCapacity]; &#125; // 析构函数，销毁队列 MyQueue::~MyQueue() &#123; delete []m_pQueue; m_pQueue = NULL; &#125; //清空队列 void MyQueue::ClearQueue() &#123; m_iHead = 0 ; m_iTail = 0 ; m_iQueueLen = 0; &#125; //判空队列 bool MyQueue::QueueEmpty() const &#123; return m_iQueueLen == 0; //m_iQueueLen == 0 ? true : false; &#125; //判满 bool MyQueue::QueueFull() const &#123; if(m_iQueueCapacity == m_iQueueLen) &#123; return true; &#125; else &#123; return false; &#125; &#125; //获取队列长度 int MyQueue::QueueLength() const &#123; return m_iQueueLen; &#125; //新元素入队 bool MyQueue::InQueue(int element) &#123; if(QueueFull()) &#123; return false; &#125; else &#123; m_pQueue[m_iTail] = element; m_iTail ++; m_iTail %= m_iQueueCapacity; m_iQueueLen ++; return true; &#125; &#125; //首元素出队 bool MyQueue::DeQueue(int &amp;element) &#123; if(QueueEmpty()) &#123; return false; &#125; else &#123; element = m_pQueue[m_iHead]; m_iHead ++ ; m_iHead %= m_iQueueCapacity; m_iQueueLen --; return true; &#125; &#125; //遍历队列 void MyQueue::QueueTraverse() &#123; for(int i=m_iHead; i &lt; m_iHead + m_iQueueLen; i++) &#123; cout &lt;&lt; m_pQueue[i%m_iQueueCapacity] &lt;&lt; endl; &#125; &#125; int main(void) &#123; //检测一下环形队列是否写正确了 MyQueue *p = new MyQueue(4); p-&gt;InQueue(10); p-&gt;InQueue(20); p-&gt;InQueue(23); p-&gt;InQueue(78); p-&gt;QueueTraverse(); int e = 0; p-&gt;DeQueue(e); cout &lt;&lt; endl; cout &lt;&lt; e &lt;&lt; endl; cout &lt;&lt; endl; p-&gt;QueueTraverse(); p-&gt;ClearQueue(); if(p-&gt;QueueEmpty()) &#123; cout &lt;&lt; \"The queue is empty!\" &lt;&lt; endl; &#125; p-&gt;InQueue(238); p-&gt;InQueue(34); p-&gt;QueueTraverse(); cout &lt;&lt; \"The length of the queue is \" &lt;&lt; p-&gt;QueueLength() &lt;&lt; endl; p-&gt;InQueue(100); p-&gt;InQueue(299); if(p-&gt;QueueFull()) &#123; cout &lt;&lt; \"The queue is full！\" &lt;&lt; endl; &#125; p-&gt;QueueTraverse(); p-&gt;~MyQueue(); cout &lt;&lt; \"You have destroyed your queue successfully!\" &lt;&lt; endl; system(\"pause\"); return 0; &#125; 如果数据元素是多个数据项组成，在C语言中可采用结构体将多个数据项封装在节点中，C++中可以用类将多个数据元素封装为一个数据对象。如果在不同应用场景下数据元素数据类型（封装类型或原有类型）不同，可以采用类模板设计实现代码重用。有兴趣的话可以自行完成。 链队在队列的链式存储结构中，可用不含头节点的链表表示。定义队列包含两个节点，其中一个为front指针指向表头，另一个为rear指针指向表尾。链队不存在满队的情况。实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; //链队 //用不含头节点的链表实现 //数据节点定义 typedef struct qnode &#123; int data; qnode *next; &#125;QNode; //链队定义 typedef struct Queue &#123; QNode *front; QNode *rear; &#125;LiQueue; void InitQueue(LiQueue *&amp;q)//初始化 &#123; q = (LiQueue *)malloc(sizeof(Queue)); q-&gt;front = NULL; q-&gt;rear = NULL; &#125; void DestroyQueue(LiQueue *&amp;q)//销毁 &#123; QNode *p = q-&gt;front,*r; while(p != NULL) &#123; r = p; p = p-&gt;next; free(r); &#125; free(q); &#125; bool QueueEmpty(LiQueue *q) &#123; return NULL == q-&gt;rear; &#125; void InQueue(LiQueue *&amp;q,int e)//入队不会失败 &#123; QNode *p = (QNode *)malloc(sizeof(QNode)); p-&gt;data = e; p-&gt;next = NULL; if(QueueEmpty(q)) &#123; q-&gt;front = p; q-&gt;rear = p; &#125; else &#123; q-&gt;rear-&gt;next = p; q-&gt;rear = p; &#125; &#125; bool DeQueue(LiQueue *&amp;q,int &amp;e)//出队 &#123; if(QueueEmpty(q))//队为空 &#123; return false; &#125; QNode *t = q-&gt;front; if(q-&gt;front == q-&gt;rear)//队中只含一个数据元素 &#123; q-&gt;front = q-&gt;rear = NULL; &#125; else//队中含有两个及以上数据元素 &#123; q-&gt;front = t-&gt;next; &#125; e = t-&gt;data; free(t); t = NULL; return true; &#125; bool TraverseQueue(LiQueue *q) &#123; if(QueueEmpty(q)) &#123; return false; &#125; QNode *p = q-&gt;front; while(p != NULL) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = p-&gt;next; &#125; cout &lt;&lt; endl; return true; &#125; int main(void) &#123; LiQueue *q; InitQueue(q); InQueue(q,1); InQueue(q,2); InQueue(q,3); InQueue(q,4); TraverseQueue(q); int elem = 0; DeQueue(q,elem); cout &lt;&lt; \"The element you deleted is :\" &lt;&lt; elem &lt;&lt; endl; TraverseQueue(q); DeQueue(q,elem); DeQueue(q,elem); DeQueue(q,elem); if(QueueEmpty(q)) &#123; cout &lt;&lt; \"The List Queue is empty!\" &lt;&lt; endl; &#125; TraverseQueue(q); DestroyQueue(q); system(\"pause\"); return 0; &#125; 典型应用在具体的程序设计中，只要涉及到先进先出的设计，即采用了队列的思想。队列的一个典型应用就是求解——迷宫问题。 迷宫问题是指：给定给定一个M×N的迷宫图、入口与出口、行走规则。求一条从指定入口到出口的路径。所求路径必须是简单路径，即路径不重复。 迷宫问题可以用栈或者队列来求解。其中使用队列求解出的路径是最短路径。迷宫采用二维数组来表示，其中路用0表示，墙用1表示。为了求解问题的方便，通常在数组的周围加上围墙，即在周围加上两行和两列。形成M+2行，N+2列的迷宫数组。 求解思路：使用顺序队列（使用顺序队列的原因是：出队入队操作并不会删除结点，只是改变了队首队尾指针的值，最终还要通过队列中已出队节点来回溯得到路径），队列中的数据元素类型为格点坐标(i,j)和路径中上一格点在队列中的位置pre的封装。pre的设置是为了找到终点后由终点通过pre回溯到起点从而逆序打印出路径（采用递归实现）。在将一个能走的格点入队后，循环搜索它周围的四个格点，并将其中能走的入队，所以必须制定四个方向的搜索顺序（最后若有多条最短路径，则打印出哪一条由搜索顺序决定）。由于路径不重复，所以在在入队后将一个迷宫格点的值赋为-1，避免重复搜索。整体思路类似于图的广度优先搜索或者树的层次遍历。 实现如下：由于队列操作简单，其中并没有定义出出队，入队等函数。注意最后打印出的坐标为（行号，列号）,并不是惯用的横纵坐标。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; const int MaxSize = 100; typedef struct &#123; int i,j;//迷宫块坐标 int pre;//当前路径中前一方块在队列中的位置 &#125;Box; typedef struct Queue &#123; Box data[MaxSize]; int rear,front;//front指向当前队头的前一元素，rear指向队尾 &#125;SqQueue; //全局数组maze表示迷宫 const int M=4,N=4; int maze[M+2][N+2] = &#123; &#123;1, 1, 1, 1, 1, 1&#125;, //迷宫示例 &#123;1, 0, 0, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1&#125;, &#123;1, 1, 0, 0, 0, 1&#125;, &#123;1, 1, 1, 1, 1, 1&#125; &#125;; bool MazePath(int xi,int yi,int xe,int ye); void print(SqQueue q,int n); int main(void) &#123; if(MazePath(1,1,4,4)) &#123; cout &lt;&lt; \"有路径，如上~\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"没有路径~\" &lt;&lt; endl; &#125; system(\"pause\"); return 0; &#125; //求迷宫路径算法，xi,yi入口坐标，xe，ye出口坐标 bool MazePath(int xi,int yi,int xe,int ye)//x表行号，y表列号 //搜索路径(xi,yi)-&gt;(xe,ye) &#123; int i,j; bool find = false;//找到出口置1 SqQueue qu;//在栈中分配内存 qu.rear = qu.front = -1; qu.rear ++; qu.data[qu.rear].i = xi; qu.data[qu.rear].j = yi;//(xi,yi)入队 qu.data[qu.rear].pre = -1;//表示在队列中没有位于它之前的元素，作为搜索路径时的结束条件 maze[xi][yi] = -1;//将0置为-1，避免重复搜索 while(qu.front != qu.rear &amp;&amp; !find)//当队列不空且没有找到出口时循环 &#123; qu.front ++; i = qu.data[qu.front].i; j = qu.data[qu.front].j;//i表行，j表列 if(i==xe &amp;&amp; j==ye) &#123; find = true; print(qu,qu.front);//打印路径,从当前格点(终点)开始追溯递归打印路径 return true;//找到出口 &#125; //将(i,j)周围四个格点中为路且没有走过的格点进队 for(int di=0;di&lt;4;di++)//di表示查找方向，0-&gt;3顺时针旋转，分别为上右下左 &#123; switch(di) &#123; case 0: i=qu.data[qu.front].i-1; j=qu.data[qu.front].j; break; case 1: i=qu.data[qu.front].i; j=qu.data[qu.front].j+1; break; case 2: i=qu.data[qu.front].i+1; j=qu.data[qu.front].j; break; case 3: i=qu.data[qu.front].i; j=qu.data[qu.front].j-1; break; &#125; if(maze[i][j] == 0) &#123; qu.rear ++; qu.data[qu.rear].i = i; qu.data[qu.rear].j = j; qu.data[qu.rear].pre = qu.front;//上一个出队元素在队列中的标号 maze[i][j] = -1; &#125; &#125; &#125; return false;//未找到路径返回false &#125; //递归打印路径 void print(SqQueue q,int n) &#123; if(q.data[n].pre == -1) &#123; cout &lt;&lt; \"(\" &lt;&lt; q.data[n].i &lt;&lt; \",\" &lt;&lt; q.data[n].j &lt;&lt; \")\" &lt;&lt; endl; return;//return 必须写 &#125; print(q,q.data[n].pre); cout &lt;&lt; \"(\" &lt;&lt; q.data[n].i &lt;&lt; \",\" &lt;&lt; q.data[n].j &lt;&lt; \")\" &lt;&lt; endl; &#125; 队列的应用可谓是非常广泛，比如在图的广度优先遍历中。作为一种最简单的家喻户晓的数据结构，限制性的线性表，当然用线性表也可以实现队列的所有功能，但正是由于栈和队列太常用，才单独抽象成一种数据结构。后续会有关于栈、树、图的文章。 以后的文章估计会CSDN博客和独立博客同步更新。欢迎mark。CSDN博客","categories":[{"name":"数学与算法","slug":"数学与算法","permalink":"http://aojueliuyun.github.io/categories/数学与算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://aojueliuyun.github.io/tags/数据结构/"},{"name":"队列","slug":"队列","permalink":"http://aojueliuyun.github.io/tags/队列/"}]},{"title":"Hello World","slug":"2017.10.12--hello-world","date":"2017-10-11T16:00:00.000Z","updated":"2017-10-15T13:27:10.593Z","comments":true,"path":"2017/10/12/2017.10.12--hello-world/","link":"","permalink":"http://aojueliuyun.github.io/2017/10/12/2017.10.12--hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post12$ hexo new \"My New Post\" More info: Writing Run server12$ hexo server More info: Server Generate static files12$ hexo generate More info: Generating Deploy to remote sites12$ hexo deploy More info: Deployment","categories":[{"name":"博客","slug":"博客","permalink":"http://aojueliuyun.github.io/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://aojueliuyun.github.io/tags/hexo/"}]}]}